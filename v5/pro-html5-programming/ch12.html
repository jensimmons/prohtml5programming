<!doctype html>

<!--[if lt IE 7]>      <html class="ie6 ie6-7 ie6-8"> <![endif]-->
<!--[if IE 7]>         <html class="ie7 ie6-7 ie7-8 ie6-8"> <![endif]-->
<!--[if IE 8]>         <html class="ie8 ie7-8 ie6-8"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

    <title>Pro HTML5 Programming: Chapter 12 | Creating HTML5 Offline Web Applications</title>

    <meta name="description" content="">
    <meta name="author" content="">

    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- CSS -->
    <link rel="stylesheet" href="../assets/libraries/codemirror/lib/codemirror.css">
    <link rel="stylesheet" href="../assets/libraries/codemirror/theme/ambiance.css">
    <link rel="stylesheet" href="../assets/libraries/codemirror/theme/static.css">
  	<link rel="stylesheet" href="../assets/stylesheets/style.css" />

    <!-- JavaScript -->
    <!--[if (lt IE 9) & (!IEMobile)]>
    <script src="js/selectivizr-min.js"></script>
    <![endif]-->
    
    <script type="text/javascript" charset="utf-8">
      (function () {
        "use strict";
        window.ISBNOnline = '978-1-4302-3865-2';
      })();
    </script>
    
    <!-- MOD: LOAD JQUERY + COLORBOX SUPPORT FOR CODE VIEW -->
    <script src="../assets/js/jquery-1.8.0.min.js"></script>
    <script src="../assets/js/modernizr-latest.js"></script>
    <script src="../assets/js/navigation.js"></script>
    <script src="../assets/js/jpanelmenu-1.0.0.js"></script>
    <script src="../assets/js/bootstrap-dropdown.js"></script>
    <script src="../assets/libraries/codemirror/lib/codemirror.js"></script>
    <script src="../assets/libraries/codemirror/mode/xml/xml.js"></script>
    <script src="../assets/libraries/codemirror/mode/javascript/javascript.js"></script>
    <script src="../assets/libraries/codemirror/mode/css/css.js"></script>
    <script src="../assets/libraries/codemirror/mode/htmlmixed/htmlmixed.js"></script>
    <script src="../assets/js/code_editor.js"></script>
    <!-- ADD CHAPTER CODE LISTINGS JS FILE HERE //-->
    <script src="toc.js"></script>  


    <!-- For iPhone 4 -->
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="images/icons/apple-touch-icon-114x114-precomposed.png">
    <!-- For iPad 1-->
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="images/icons/apple-touch-icon-72x72-precomposed.png">
    <!-- For the new iPad -->
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="images/icons/apple-touch-icon-144x144-precomposed.png">
    <!-- For iPhone 3G, iPod Touch and Android -->
    <link rel="apple-touch-icon-precomposed" href="images/icons/apple-touch-icon-precomposed.png">
    <!-- For Nokia -->
    <link rel="shortcut icon" href="images/icons/apple-touch-icon.png">
    <!-- For everything else -->
    <link rel="shortcut icon" href="/favicon.ico">
    
    <!--iOS -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-startup-image" href="images/cover/cover.jpg">
    
    <meta http-equiv="cleartype" content="on">

  </head>

  <body>

    <header class="controls-bar">
      <h1 class="book-title">Pro HTML5 Programming</h1>
      
      <div class="menu-link orig-menu menu-trigger">
        <a class="svg-menu" href="#main-navigation">Chapter Contents</a>
      </div>
      
      <div class="font-size-controls">
        <a href="#" class="btn btn-fs fs-smaller">Smaller</a>
        <a href="#" class="btn btn-fs fs-larger">Larger</a>
      </div>
    
      <div class="btn-group toc-link" id="toc">
        <a class="btn dropdown-toggle" data-toggle="dropdown" href="#">
          Table of Contents
          <span class="caret"></span>
        </a>
      </div>
    
    </header>
  
<!--======================== CONTENT ========================-->

<article role="main">
<div id="wrapper">


<hgroup>
  <a id="chapter_title" class="section-anchor"></a>
  <h1>Chapter 12</h1>
  <h1>Creating HTML5 Offline Web Applications</h1>
</hgroup>

<p>In this chapter, we will explore what you can do with offline HTML5 applications. HTML5 applications do not necessarily require constant access to the network, and loading cached resources can now be more flexibly controlled by developers.</p>

<section id="sec1_12">
<a id="hdr_sec1_12" class="section-anchor"></a>

<h2>Overview of HTML5 Offline Web Applications</h2>
<p>The first, and most obvious, reason to use the application cache is offline support. In the age of universal connectivity<span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">universal connectivity</span></span>, offline applications are still desirable. What do you do when you do not have a network connection? Before you say the days of intermittent connectivity are over, consider the following:</p>
<ul>
<li>
<p>Do all of the flights you take have onboard Wi-Fi?</p>
</li>
<li>
<p>Do you have perfect signal coverage on your mobile Internet device (when was the last time you saw zero bars)?</p>
</li>
<li>
<p>Can you count on having an Internet connection when you give presentations?</p>
</li>
</ul>
<p>As more applications move to the Web, it is tempting to assume 24/7 uninterrupted connectivity for all users, but the reality of the Internet is that interruptions happen and, in situations like air travel, can happen predictably for several hours at a time.</p>

<p>Intermittent connectivity<span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">intermittent connectivity</span></span> has been the Achilles’ heel of network computing systems. If your applications depend on communication with remote hosts, and those hosts are unreachable, you’re out of luck. However, when you do have an Internet connection, web applications can always be up-to-date, because the code loads from a remote location on each use.</p>

<p>If your applications require only occasional communication, they can still be useful as long as the application resources are stored locally. With the advent of browser-only devices<span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">browser-only devices</span></span>, web applications that continue to function without continuous connectivity will only grow more important. Desktop applications that do not require continuous connectivity have historically held that advantage over web applications.</p>

<p>HTML5 exposes control over application caching<span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">application caching</span></span> to get the best of both worlds: applications built with web technology that run in the browser and update when they are online but can also be used offline. However, this new offline application feature must be used explicitly, because current web servers do not provide any default caching behavior for offline applications.</p>

<p>The HTML5 offline application cache makes it possible to augment an application to run without a network connection. You do not need a connection to the Internet just to draft an e-mail. HTML5 introduces the offline application cache that allows a Web application to run without network connectivity.</p>

<p>An application developer can specify specific additional resources comprising an HTML5 application (HTML, CSS, JavaScript, and images) to make an application available for offline use. There are many use cases for this, for example:</p>
<ul>
<li>
<p>Read and compose e-mail</p>
</li>
<li>
<p>Edit documents</p>
</li>
<li>
<p>Edit and display presentations</p>
</li>
<li>
<p>Create to-do lists</p>
</li>
</ul>
<p>Using offline storage<span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">offline storage</span></span> can avoid the normal network requests needed to load an application. If the cache manifest is up to date, the browser knows it does not need to check if the other resources are also up to date, and most of the application can load very quickly out of the local application cache. Additionally, loading resources out of a cache (instead of making multiple HTTP requests to see if resources have been updated) saves bandwidth, which can be especially important for mobile web applications. Currently, slower loading is one way that web applications suffer in comparison with desktop applications. Caching can offset that.</p>

<p>The application cache gives developers explicit control over caching. The <em>cache manifest</em> file allows you to group related resources into a logical application. This is a powerful concept that can give web applications some of the characteristics of desktop applications. You can use this additional power in new, creative ways.</p>

<p>Resources identified in the cache manifest file<span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">cache manifest file</span></span> create what is known as an <em>application cache</em>, which is the place where browsers store the resources persistently, typically on disk. Some browsers give users a way to view the data in the application cache. For example, the Offline cache device section in the internal <code>about:cache</code> page<span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">about\</span><tertiary>cache page, Firefox</tertiary></span> in Firefox shows you details about the application cache and a way to view individual files in the cache, as shown in Figure<span class="internal-reference" id="ir_fig1_12">
12-1</span>.
</p>
<figure id="fig1_12" class="image"><img src="images/ch12/fig12-1.png"><figcaption>Figure 12-1. Viewing application cache entries in Firefox<span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">about\</span><tertiary>cache page, Firefox</tertiary></span>
</figcaption></figure><p>Similarly, the internal page <code>chrome://appcache-internals/</code> provides details about the contents of the different application caches stored on your system. It also provides a way to view the contents and remove these caches entirely as shown in Figure <span class="internal-reference" id="ir_fig2_12">12-2</span>.<span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">application cache entries</span></span>

</p>
<figure id="fig2_12" class="image"><img src="images/ch12/fig12-2.png"><figcaption>Figure 12-2. Viewing application cache entries<span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">application cache entries</span></span> <em>in Chrome</em>
</figcaption></figure><section id="sec3_12">
<a id="hdr_sec3_12" class="section-anchor"></a>

<h3>Browser Support<span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">browser support</span></span> for HTML5 Offline Web Applications</h3>
<p>For a complete overview of the current browser support, including mobile support, refer to <code>http://caniuse.com</code> and search for Offline Web Applications or Application Cache. If you have to support older browsers, it’s always a good idea to first see whether Application Cache is supported before you use the API. The section “Checking for Browser Support” later in this chapter will show you how you can programmatically check for browser support.</p>

</section>
</section>

<section id="sec4_12">
<a id="hdr_sec4_12" class="section-anchor"></a>

<h2>Using the HTML5 Application Cache API</h2>
<p>In this section, we will explore the specifics of how you can use the Offline Web Applications API.</p>

<section id="sec5_12">
<a id="hdr_sec5_12" class="section-anchor"></a>

<h3>Checking for Browser Support<span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">application cache API</span><tertiary>browser support</tertiary></span>
</h3>
<p>Before you try to use the Offline Web Applications API, it is a good idea to check for browser support. Listing 12-1 shows how you can do that.</p>

<figure class="listing"><figcaption>Listing 12-1. Checking Browser Support for the Offline Web Applications API</figcaption><pre><code>if(window.applicationCache) {
  // this browser supports offline applications
}</code></pre></figure>
</section>

<section id="sec6_12">
<a id="hdr_sec6_12" class="section-anchor"></a>

<h3>Creating a Simple Offline Application</h3>
<p>Let’s say that you want to create a one-page application that consists of an HTML document, a style sheet, and a JavaScript file. To add offline support to your HTML5 application, you include a <code>manifest</code> attribute on the <code>html</code> element<span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">application cache API</span><tertiary>manifest attribute, html element</tertiary></span> as shown in the Listing 12-2.</p>

<figure class="listing"><figcaption>Listing 12-2. The manifest Attribute on the HTML Element</figcaption><pre><code>&lt;!DOCTYPE html&gt;
&lt;html manifest="application.appcache"&gt;
  .
  .
  .
&lt;/html&gt;</code></pre></figure><p>Alongside the HTML document, provide a manifest file with the <code>*.appcache</code> extension) specifying which resources to cache. Listing 12-3 shows the contents of an example cache manifest file.</p>

<figure class="listing"><figcaption>Listing 12-3. Contents of an Example Cache Manifest File <span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">application cache API</span><tertiary>cache manifest file contents</tertiary></span>
</figcaption><pre><code>CACHE MANIFEST
example.html
example.js
example.css
example.gif</code></pre></figure>
</section>

<section id="sec7_12">
<a id="hdr_sec7_12" class="section-anchor"></a>

<h3>Going Offline</h3>
<p>To make applications aware of intermittent connectivity, there are additional events exposed by HTML5 browsers. Your applications may have different modes for online and offline behavior. Some additions to the <code>window.navigator</code> object<span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">application cache API</span><tertiary>window.navigator object</tertiary></span> make that easier. First, <code>navigator.onLine</code><span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">application cache API</span><tertiary>navigator.onLine property</tertiary></span> is a Boolean property that indicates whether the browser believes it is online. Of course, a <code>true</code> value of <code>onLine</code> is not a definite assurance that the servers that your web application must communicate with are reachable from the user’s machine. On the other hand, a <code>false</code> value means the browser will not even attempt to connect out over the network. Listing 12-4 shows how you can check to see if your page is online or offline.</p>

<figure class="listing"><figcaption>Listing 12-4. Checking Online Status <span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">application cache API</span><tertiary>online status</tertiary></span><span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">application cache API</span><tertiary>online status</tertiary></span>
</figcaption><pre><code>// When the page loads, set the status to online or offline
function loadDemo() {
  if (navigator.onLine) {
    log("Online");
  } else {
    log("Offline");
  }
}
// Now add event listeners to notify a change in online status
window.addEventListener("online", function(e) {
  log("Online");
}, true);
window.addEventListener("offline", function(e) {
  log("Offline");
}, true);</code></pre></figure>
</section>

<section id="sec8_12">
<a id="hdr_sec8_12" class="section-anchor"></a>

<h3>Manifest Files</h3>
<p>Offline applications consist of a manifest listing one or more resources that browser will cache for offline use. Manifest files have the MIME type <code>text/cache-manifest</code>. The <span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">application cache API</span><tertiary>SimpleHTTPServer module</tertiary></span><code>SimpleHTTPServer</code> module<span class="index-term"><span class="primary">SimpleHTTPServer module</span></span> in the Python standard library will serve files with the <code>.manifest</code> extension with the header <code>Content-type: text/cache-manifest</code><span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">application cache API</span><tertiary>Content-type\</tertiary><span class="primary">text/cache-manifest</span></span>. To configure settings, open the file <code>PYTHON_HOME/Lib/mimetypes.py</code>, and add the following line:</p>

<pre><code>'.appcache'    : 'text/cache-manifest manifest',</code></pre>
<p>Other web servers may require additional configuration. For example, for Apache HTTP Server, you can update the <span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">application cache API</span><tertiary>mime.types</tertiary></span><code>mime.types</code> file<span class="index-term"><span class="primary">mime.types file</span></span> in the conf folder by adding the following line:</p>

<pre><code>text/cache-manifest appcache</code></pre>
<p>If you are using Microsoft IIS, in your website’s home, double-click the MIME Types icon, then add the <code>.appcache</code> extension<span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">application cache API</span><tertiary>.appcache extension</tertiary></span> with MIME type <code>text/cache-manifest</code> in the Add MIME Type dialog.</p>

<p>The manifest syntax is simple line separated text that starts with CACHE MANIFEST (as the first line). Lines can end in CR LF or CRLF—the format is flexible—but the text must be UTF-8 encoded, which is the typical output for most text editors. Comments begin with the hash symbol and must be on their own lines; you cannot append a comment to other non-comment lines in the file.</p>

<figure class="listing"><figcaption>Listing 12-5. Example Manifest File <span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">application cache API</span><tertiary>manifest file</tertiary></span> with All Possible Sections</figcaption><pre><code>CACHE MANIFEST
# files to cache
about.html
html5.css
index.html
happy-trails-rc.gif
lake-tahoe.JPG
#do not cache signup page
NETWORK
signup.html
FALLBACK
signup.html     offline.html
/app/ajax/      default.html</code></pre></figure><p>Let’s look at the different sections.</p>

<p>If no CACHE: heading is specified, the files that are listed will be treated as files to be cached (caching is the default behavior). The following simple manifest specifies that three files (<code>index.html</code>, <code>application.js</code>, and <code>style.css</code>) must be cached:</p>

<pre><code>CACHE MANIFEST
index.html
application.js
style.css</code></pre>



<p>Similarly, the following section would do the same (you can use the same CACHE, NETWORK, and FALLBACK headers multiple times in a manifest file if you want to):</p>

<pre><code>CACHE MANIFEST
# Cache section
CACHE:
Index.html
application.js
style.css</code></pre>





<p><span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">application cache API</span><tertiary>manifest file</tertiary></span>By listing a file in the CACHE section, you instruct the browser to serve the file from the application cache, even if the application is online. It is unnecessary to specify the application's main HTML resource. The HTML document that initially pointed to the manifest file is implicitly included (this is called a Master entry). However, if you want to cache multiple HTML documents or if you would like multiple HTML documents to act as possible entry points for the cacheable application, they should all be explicitly listed in the cache manifest file.</p>

<p>FALLBACK entries<span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">application cache API</span><tertiary>FALLBACK entries</tertiary></span> allow you to give alternate paths to replace resources that cannot be fetched. The manifest in Listing 12-5 would cause requests to <code>/app/ajax/</code> or subpaths beginning with <code>/app/ajax/</code> to fall back to <code>default.html</code> when <code>/app/ajax/*</code> is unreachable.</p>

<p>NETWORK specifies<span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">application cache API</span><tertiary>NETWORK specification</tertiary></span> resources that are always fetched using the network. The difference with simply omitting these files from the manifest is that master entries are cached without being explicitly listed in the manifest file. To ensure that the application requests the file from the server even if the cached resource is cached in the application cache, you can place that file in the NETWORK: section.<span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">application cache API</span><tertiary>NETWORK specification</tertiary></span>
</p>
</section>

<section id="sec9_12">
<a id="hdr_sec9_12" class="section-anchor"></a>

<h3>The ApplicationCache API</h3>
<p>The ApplicationCache API is an interface for working with the application cache. A new <code>window.applicationCache</code> object<span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">application cache API</span><tertiary>window.applicationCache object</tertiary></span> fires several events related to the state of the cache. The object has a numerical property, <code>window.applicationCache.status</code><span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">application cache API</span><tertiary>window.applicationCache.status</tertiary></span>, which indicates the state of the cache. The six states a cache can have are shown in Table <span class="internal-reference" id="ir_tab1_12">12-1</span>.</p>
<table id="tab1_12">
<thead><tr>
<td>Numerical Property</td>
<td>Cache Status</td>
</tr></thead>
<tbody>
<tr>
<td>0</td>
<td>UNCACHED</td>
</tr>
<tr>
<td>1</td>
<td>IDLE</td>
</tr>
<tr>
<td>2</td>
<td>CHECKING</td>
</tr>
<tr>
<td>3</td>
<td>DOWNLOADING</td>
</tr>
<tr>
<td>4</td>
<td>UPDATEREADY</td>
</tr>
<tr>
<td>5</td>
<td>OBSOLETE</td>
</tr>
</tbody>
</table>
<p>Most pages on the Web today do not specify cache manifests and are uncached. Idle is the typical state for an application with a cache manifest. An application in the idle state has all its resources stored by the browser with no updates in progress. A cache enters the obsolete state if there was at one point a valid cache but the manifest is now missing. There are events (and callback attributes) in the API that correspond to some of these states. For instance, when the cache enters the idle state after an update, the cached event fires. At that time, an application might notify the user that they can disconnect from the network and still expect the application to be available in offline mode. Table <span class="internal-reference" id="ir_tab2_12">12-2</span> shows some common events and their associated caches states.
</p>
<table id="tab2_12">
<thead><tr>
<td>Event</td>
<td>Associated Cache State</td>
</tr></thead>
<tbody>
<tr>
<td>onchecking</td>
<td>CHECKING</td>
</tr>
<tr>
<td>ondownloading</td>
<td>DOWNLOADING</td>
</tr>
<tr>
<td>onupdateready</td>
<td>UPDATEREADY</td>
</tr>
<tr>
<td>onobsolete</td>
<td>OBSOLETE</td>
</tr>
<tr>
<td>oncached</td>
<td>IDLE</td>
</tr>
</tbody>
</table>
<p><span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">application cache API</span><tertiary>common events</tertiary></span>Additionally, there are events indicating update progress, when no update is available, or when an error has occurred:</p>
<ul>
<li>
<p>onerror</p>
</li>
<li>
<p>onnoupdate</p>
</li>
<li>
<p>onprogress</p>
</li>
</ul>window.applicationCache has an   update() method<span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">application cache API</span><tertiary>update() method</tertiary></span><span class="index-term"><span class="primary">update() method</span></span>. Calling <code>update()</code> requests that the browser update the cache. This includes checking for a new version of the manifest file and downloading new resources if necessary. If there is no cache or if the cache is obsolete, an error will be thrown.</section>

<section id="sec10_12">
<a id="hdr_sec10_12" class="section-anchor"></a>

<h3>Application Cache in Action</h3>
<p>Although creating the manifest file and using it in an application is relatively simple, what happens when you update pages on the server is not as intuitive as you might think. The main thing to keep in mind is that once the browser has successfully cached the application’s resources in the application cache, it will <em>always</em> serve those pages from the cache first. After that, the browser will do only one more thing: check if the manifest file has been changed on the server.</p>

<p>To better understand how the process<span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">application cache API</span><tertiary>process, manifest file</tertiary></span> works, let’s step through an example scenario, using the manifest file shown in Listing 12-5.</p>
<ol>
<li>
<p>When you access the <code>index.html</code>  page for the very first time (while online), say on <code>http://www.example.com</code>, the browser loads the page and its subresources (CSS, JavaScript, and image files).</p>
</li>
<li>
<p>While parsing the page, the browser comes across the <code>manifest</code> attribute in the <code>html</code> element and proceeds to load all the files listed in the <code>CACHE</code> (default) and <code>FALLBACK</code> sections in the application cache for the <code>example.com</code> site (browsers allow about 5 MB of storage space).</p>
</li>
<li>
<p>From now on, when you navigate to <code>http://www.example.com</code>, the browser will <em>always</em> load the site from the application cache, and it will then attempt to check if the manifest file has been updated (it can only do the latter when you are online). This means that if you now go offline (voluntarily or otherwise) and point your browser at <code>http://www.example.com</code>, the browser will load the site from the application cache—yes, you can still use the site in its entirety in offline mode.<span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">application cache API</span><tertiary>process, manifest file</tertiary></span>
</p>
</li>
<li>
<p>If you try to access a cached resource while you’re offline, it will load from the application cache. When you try to access a <code>NETWORK</code> resource (<code>signup.html</code>), <code>FALLBACK</code> content (<code>offline.html</code>) will be served. <code>NETWORK</code> files will be available again only if you go back online.</p>
</li>
<li>
<p>So far so good. Everything works as expected. We will now try to step you through the digital minefield that you must cross when you change content on the server. When you change, for example, the <code>about.html</code> page on the server and access that page while you’re in online mode by reloading the page in the browser, it would be reasonable to expect the updated page to show up. After all, you’re online and have direct access to the server. However, you will just be looking at the same old page as before, possibly with a puzzled look on your face. The reason for this is that the browser will always load the page from the application cache, and after that it checks only one thing: whether the manifest file has been updated. Therefore, if you want updated resources to be downloaded you <em>must</em> make a change to the manifest file as well (do not just “touch” the file, because that will not be considered a change—it must be a byte-for-byte change). A common way to make this change is to add a version comment at the top of the file as shown in Listing 12.5. The browser does not actually understand the version comment, but it is a good best practice to follow. Because of this and because it is easy to overlook a new or removed file, it is recommended that you use some sort of build script to maintain the manifest file. HTML5 Boilerplate 2.0 (<code>http://html5boilerplate.com</code>) ships with a build file that can be used to automatically build and version the appcache file, a great addition to that already great resource.</p>
</li>
<li>
<p>When you make a change to both the <code>about.html</code> page <em>and</em> the <code>manifest</code> file and subsequently refresh the page in your browser while you’re online you will, once again, be disappointed to see the same old page. What happened? Well, even though the browser has now found that the manifest has been updated and downloaded all of the files again into a new version of the cache, the page was already loaded from the application cache before the server check was performed, and the browser does not automatically reload the page for you in the browser. You can compare this process to how a new version of a software program (for example, the Firefox browser) can be downloaded in the background but require a restart of the program to take effect. If you can’t wait for the next page refresh, you can programmatically add an event listener for the <code>onupdateready</code> event and prompt the user to refresh the page. A little confusing at first, but it all actually makes sense when you think about it.<span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">application cache API</span><tertiary>process, manifest file</tertiary></span>
</p>
</li>
</ol>
<aside>
<h3>Using Application Cache To Boost Performance</h3>
<p><strong>Peter says</strong>: “One nice side-effect of the application cache mechanism is that you can use it to prefetch resources. The regular browser cache stores pages that you have visited, but what is stored is dependent on both client and server configuration<span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">application cache API</span><tertiary>client and server configuration</tertiary></span> (browser settings and expires headers). Therefore, returning to specific pages by relying on regular browser caching is fickle to say the least—anyone who has ever attempted to rely on regular browser caching to navigate through the pages of a website while on an airplane will probably agree here.</p>

<p>Using application cache, however, allows you not only to cache pages as you visit them but also to cache pages <em>you have not even visited yet</em>; it can be used as an effective prefetching mechanism. When it is time to use one of those prefetched resources it will be loaded from the application cache on local disk and not from the server, speeding up the load time dramatically. Used wisely (don’t prefetch Wikipedia), you can use application cache to dramatically improve performance. One important thing to remember is that regular browser caching is also still in effect, so watch for false positives, especially if you are trying to debug application cache behavior.”</p>

</aside>
</section></section>

<section id="sec26_12">
<a id="hdr_sec26_12" class="section-anchor"></a>

<h2>Building an Application with HTML5 Offline Web Applications</h2>
<p>In this example application, we will track a runner’s location while out on the trail (with intermittent or no connectivity). For example, Peter goes running, and he will have his new Geolocation–enabled phone and HTML5 web browser with him, but there is not always a great signal out in the woods around his house. He wants to use this application to track and record his location even when he cannot use the Internet.</p>

<p>When offline, the Geolocation API<span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">geolocation API</span></span> should continue to work on devices with hardware geolocation (such as GPS) but obviously not on devices that use IP geolocation. IP geolocation<span class="index-term"><span class="primary">IP geolocation</span></span> requires network connectivity to map the client's IP address to coordinates. In addition, offline applications can always access persistent storage on the local machine through APIs such as local storage or Indexed Database.</p>

<p>The example files for this application are located on the book’s page at <code>www.apress.com</code> and at the book‘s website in the <code>offline</code> code folder, and you can start the demo by navigating to the code/offline folder and issuing the command:</p>

<pre><code>Python –m SimpleHTTPServer 9999.</code></pre>
<p>Prior to starting the web server, make sure you have configured Python to serve the manifest files (files with the *.appcache extension) with the correct mime type as described earlier. This is the most common cause of failure for offline web applications. If it does not work as expected, check the console in Chrome Developer tools for possible descriptive error messages.</p>

<p>This starts Python’s HTTP server module on port 9999 (you can start it on any port, but you may need admin privileges to bind to ports lower than 1024. After starting the HTTP server, you can navigate to <code>http://localhost :9999/tracker.html</code> to see the application in action.</p>

<p>Figure <span class="internal-reference" id="ir_fig3_12">12-3</span> shows what happens in Firefox<span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">Python –m SimpleHTTPServer 9999</span><tertiary>Firefox</tertiary></span> when you access the site for the first time: you are prompted to opt in to storing data on your computer (note, however, that not all browsers will prompt you before storing data).

</p>
<figure id="fig3_12" class="image"><img src="images/ch12/fig12-3.png"><figcaption>Figure 12-3. Firefox prompting to store data for the web application<span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">Python –m SimpleHTTPServer 9999</span><tertiary>Firefox</tertiary></span>
</figcaption></figure><p>After allowing the application to store data, the application cache process starts and the browser starts downloading the files referenced in the application cache manifest file (this happens after the page is loaded, and, therefore, it has minimal impact on the responsiveness of the page. Figure <span class="internal-reference" id="ir_fig4_12">12-4</span> shows how Chrome Developer Tools<span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">Python –m SimpleHTTPServer 9999</span><tertiary>chrome developer tools</tertiary></span> provide a detailed overview of what is cached for the <code>localhost</code> origin in the Resources pane. It also provides information in the console about the application cache events that fire while the page and the manifest were processed.

</p>
<figure id="fig4_12" class="image"><img src="images/ch12/fig12-4.png"><figcaption>Figure 12-4. The Offline Page in Chrome with details about the application cache in Chrome Developer Tools<span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">Python –m SimpleHTTPServer 9999</span><tertiary>chrome developer tools</tertiary></span>
</figcaption></figure><p>To run this application, you will need a web server serving these static resources. Remember that the manifest file must be served with the content type <code>text/cache-manifest</code><span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">Python –m SimpleHTTPServer 9999</span><tertiary>text/cache-manifest content type</tertiary></span>. If your browser supports the application cache, but the file is served with the incorrect content type, you will receive a cache error. An easy way to test this is to view the events that fire in the Chrome Developer Tools console as shown in Figure<span class="internal-reference" id="ir_fig4_12">12-4</span>; it will tell you if the appcache file is served with the wrong mime type.</p>

<p>To run this application with complete functionality, you will need a server that can receive geolocation data. The server-side complement to this example would presumably store, analyze, and make available this data. It may or may not be served from the same origin as the static application. Figure<span class="internal-reference" id="ir_fig5_12">12-5</span> shows the example application running in offline mode<span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">Python –m SimpleHTTPServer 9999</span><tertiary>offline mode</tertiary></span> in Firefox. You can use File ä Work Offline to turn this mode on in Firefox and Opera. Other browsers do not have this convenience function, but you can disconnect from the network. Note, however, that disconnecting from the network does not interrupt the connection to a Python server running on localhost.

</p>
<figure id="fig5_12" class="image"><img src="images/ch12/fig12-5.png"><figcaption>Figure 12-5. The application in offline mode<span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">Python –m SimpleHTTPServer 9999</span><tertiary>offline mode</tertiary></span>
</figcaption></figure><section id="sec11_12">
<a id="hdr_sec11_12" class="section-anchor"></a>

<h3>Creating a Manifest File for the Application Resources<span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">application resources</span></span>
</h3>
<p>First, in a text editor, create the <code>tracker.appcache</code> file as follows. This manifest file will list the files that are part of this application:</p>

<pre><code>CACHE MANIFEST
# JavaScript
./offline.js
#./tracker.js
./log.js
# stylesheets
./html5.css
# images</code></pre>





</section>

<section id="sec12_12">
<a id="hdr_sec12_12" class="section-anchor"></a>

<h3>Creating the HTML Structure and CSS for the UI<span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">HTML structure and CSS, UI</span></span>
</h3>
<p>This is the basic UI structure of the example. Both <code>tracker.html</code> and <code>html5.css</code> will be cached, so the application will be served from the application cache.</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en" manifest="tracker.appcache"&gt;
&lt;head&gt;
    &lt;title&gt; HTML5 Offline Application&lt;/title&gt;
    &lt;script src="log.js"&gt; &lt;/script&gt;
    &lt;script src="offline.js"&gt; &lt;/script&gt;
    &lt;script src="tracker.js"&gt; &lt;/script&gt;
    &lt;link rel="stylesheet" href="html5.css"&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;header&gt;
      &lt;h1&gt; Offline Example&lt;/h1&gt;
    &lt;/header&gt;
    &lt;section&gt;
      &lt;article&gt;
        &lt;button id="installButton"&gt; Check for Updates&lt;/button&gt;
        &lt;h3&gt; Log&lt;/h3&gt;
        &lt;div id="info"&gt;
       &lt;/div&gt;
      &lt;/article&gt;
    &lt;/section&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>






















<p>There are a couple of things to note in this HTML that pertain to this application's offline capabilities. The first is the <code>manifest</code> attribute on the HTML element. Most of the HTML examples in this book omit the <code>&lt;html&gt;</code> element because it is optional in HTML5. However, the ability to cache offline depends on specifying the manifest file there.</p>

<p>The second thing to note is the button. That will give the user control over configuring this application for offline use.</p>
</section>

<section id="sec13_12">
<a id="hdr_sec13_12" class="section-anchor"></a>

<h3>Creating the Offline JavaScript<span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">offline JavaScript</span></span>
</h3>
<p>For this example, the JavaScript is contained in multiple <code>.js</code> files included with <code>&lt;script&gt;</code> tags. These scripts are cached along with the HTML and CSS.</p>

<pre><code>&lt;offline.js&gt;
/*
 * log each of the events fired by window.applicationCache
 */
window.applicationCache.onchecking = function(e) {
    log("Checking for application update");
}
window.applicationCache.onnoupdate = function(e) {
    log("No application update found");
}
window.applicationCache.onupdateready = function(e) {
    log("Application update ready");
}
window.applicationCache.onobsolete = function(e) {
    log("Application obsolete");
}
window.applicationCache.ondownloading = function(e) {
    log("Downloading application update");
}
window.applicationCache.oncached = function(e) {
    log("Application cached");
}
window.applicationCache.onerror = function(e) {
    log("Application cache error");
}
window.addEventListener("online", function(e) {
    log("Online");
}, true);
window.addEventListener("offline", function(e) {
    log("Offline");
}, true);
/*
 * Convert applicationCache status codes into messages
 */
showCacheStatus = function(n) {
    statusMessages = ["Uncached","Idle","Checking","Downloading","Update Ready","Obsolete"];
    return statusMessages[n];
}<span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">offline JavaScript</span></span>
install = function() {
    log("Checking for updates");
    try {
        window.applicationCache.update();
    } catch (e) {
        applicationCache.onerror();
    }
}
onload = function(e) {
    // Check for required browser features
    if (!window.applicationCache) {
        log("HTML5 Offline Applications are not supported in your browser.");
        return;
    }
    if (!navigator.geolocation) {
        log("HTML5 Geolocation is not supported in your browser.");
        return;
    }
    if (!window.localStorage) {
        log("HTML5 Local Storage not supported in your browser.");
        return;
    }
    log("Initial cache status: " + showCacheStatus(window.applicationCache.status));
    document.getElementById("installButton").onclick = checkFor;
}
&lt;log.js&gt;
log = function() {
    var p = document.createElement("p");
    var message = Array.prototype.join.call(arguments, " ");
    p.innerHTML = message;
    document.getElementById("info").appendChild(p);
}<span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">offline JavaScript</span></span></code></pre>



































































</section>

<section id="sec14_12">
<a id="hdr_sec14_12" class="section-anchor"></a>

<h3>Check for ApplicationCache Support<span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">applicationCache support</span></span>
</h3>
<p>In addition to the offline application cache, this example uses geolocation and local storage. We ensure that the browser supports all of these features when the page loads.</p>

<pre><code>onload = function(e) {
    // Check for required browser features
    if (!window.applicationCache) {
        log("HTML5 Offline Applications are not supported in your browser.");
        return;
    }
    if (!navigator.geolocation) {
        log("HTML5 Geolocation is not supported in your browser.");
        return;
    }
    if (!window.localStorage) {
        log("HTML5 Local Storage is not supported in your browser.");
        return;
    }
    if (!window.WebSocket) {
        log("HTML5 WebSocket is not supported in your browser.");
        return;
    }
    log("Initial cache status: " + showCacheStatus(window.applicationCache.status));
    document.getElementById("installButton").onclick = install;<span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">applicationCache support</span></span>
}</code></pre>


















</section>

<section id="sec15_12">
<a id="hdr_sec15_12" class="section-anchor"></a>

<h3>Adding the Update Button Handler<span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">update button handler</span></span>
</h3>
<p>Next, add an update handler that updates the application cache as follows:</p>

<pre><code>install = function() {
    log("Checking for updates");
    try {
        window.applicationCache.update();
    } catch (e) {
        applicationCache.onerror();
    }
}</code></pre>







<p>Clicking this button will explicitly start the cache check that will cause all cache resources to be downloaded if necessary. When available updates have completely downloaded, a message is logged in the UI. At this point, the user knows that the application has successfully installed and can be run in offline mode.</p>
</section>

<section id="sec16_12">
<a id="hdr_sec16_12" class="section-anchor"></a>

<h3>Add Geolocation Tracking Code<span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">geolocation tracking code</span></span>
</h3>
<p>This code is based on the geolocation code from <span class="external-reference">
<span class="ref-source">Chapter 4</span>
<span class="ref-target">DOI::10.1007/978-1-4302-3865-2_4</span>
</span>. It is contained in the <code>tracker.js</code> JavaScript file.</p>

<pre><code>/*
 * Track and report the current location
 */
    var handlePositionUpdate = function(e) {
    var latitude = e.coords.latitude;
    var longitude = e.coords.longitude;
    log("Position update:", latitude, longitude);
    if(navigator.onLine) {
        uploadLocations(latitude, longitude);
    }
    storeLocation(latitude, longitude);
}
var handlePositionError = function(e) {
    log("Position error");
}
var uploadLocations = function(latitude, longitude) {
    var request = new XMLHttpRequest();
    request.open("POST", "http://geodata.example.net:8000/geoupload", true);
    request.send(localStorage.locations);
}
var geolocationConfig = {"maximumAge":20000};
navigator.geolocation.watchPosition(handlePositionUpdate,
                                    handlePositionError,
                                    geolocationConfig);<span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">geolocation tracking code</span></span>
</code></pre>





















</section>

<section id="sec17_12">
<a id="hdr_sec17_12" class="section-anchor"></a>

<h3>Adding Storage Code<span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">storage code</span></span>
</h3>
<p>Next, add the code that writes updates to <code>localStorage</code> when the application is in offline mode.</p>

<pre><code>var storeLocation = function(latitude, longitude) {
    // load stored location list
    var locations = JSON.parse(localStorage.locations || "[]");
    // add location
    locations.push({"latitude" : latitude, "longitude" : longitude});
    // save new location list
    localStorage.locations = JSON.stringify(locations);
}</code></pre>







<p> This application stores coordinates using HTML5 local storage as described in <span class="external-reference">
<span class="ref-source">Chapter 9</span>
<span class="ref-target">DOI::10.1007/978-1-4302-3865-2_9</span>
</span>. Local storage is a natural fit for offline-capable applications, because it provides a way to persist data locally in the browser. The data will be available in future sessions. When network connectivity is restored, the application can synchronize with a remote server.</p>

<p>Using storage here has the added benefit of allowing recovery from failed upload requests. If the application experiences a network error for any reason, or if the application is closed (by user action, browser or operating system crash, or page navigation) the data is stored for future transmission.</p>
</section>

<section id="sec18_12">
<a id="hdr_sec18_12" class="section-anchor"></a>

<h3>Adding Offline Event Handling<span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">offline event handling</span></span>
</h3>
<p>Every time the location update handler runs, it checks the connectivity status. If the application is online, it will store and upload the coordinates. If the application is offline, it will merely store the coordinates. When the application comes back online, it can update the UI to show the online status and upload any data is stored while online.</p>

<pre><code>window.addEventListener("online", function(e) {
    log("Online");
}, true);
window.addEventListener("offline", function(e) {
    log("Offline");
}, true);</code></pre>





<p>The connectivity status may change while the application is not actively running. For instance, the user may have closed the browser, refreshed, or navigated to a different site. To handle these cases, our offline application checks to see if it has come back online on each page load. If it has, it will attempt to synchronize with the remote server.</p>

<pre><code>// Synchronize with the server if the browser is now online
if(navigator.onLine) {
    uploadLocations();
}<span class="index-term"><span class="primary">HTML5 offline web applications</span><span class="secondary">offline event handling</span></span></code></pre>

</section>

</section>
<section id="sec19_12">
<a id="hdr_sec19_12" class="section-anchor"></a>

<h2>Summary</h2>
<p>In this chapter, you have seen how HTML5 Offline Web Applications can be used to create compelling applications that can be used even when there is no Internet connection. You can ensure that all your files are cached by specifying the files that are part of the web application in the cache manifest file and then referencing the files from the main HTML page of the application. Then, by adding event listeners for online and offline status changes, you can make your site behave differently based on whether an Internet connection is available or not.</p>

<p>In the final chapter, we will discuss the future of HTML5 programming.</p>

</section>

<footer class="next-chapter">
  <p><a href="ch13.html">Go to the Next Chapter</a></p>
</footer>

</div>
</article>

<!--====================== END CONTENT ======================-->

<a id="main-navigation"></a>
<div class="nav-container">
<nav id="menu" role="navigation">
  <ul>
    <li class="current">
      <a href="#chapter_title">Chapter 12</a>
      <ul>
        <li>
          <a href="#hdr_sec1_12">Overview of HTML5 Offline Web Applications</a>
          <ul>
            <li><a href="#hdr_sec3_12">Browser Support for HTML5 Offline Web Applications</a></li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
          <a href="#hdr_sec4_12">Using the HTML5 Application Cache API</a>
          <ul>
            <li><a href="#hdr_sec5_12">Checking for Browser Support</a></li>
            <li><a href="#hdr_sec6_12">Creating a Simple Offline Application</a></li>
            <li><a href="#hdr_sec7_12">Going Offline</a></li>
            <li><a href="#hdr_sec8_12">Manifest Files</a></li>
            <li><a href="#hdr_sec9_12">The ApplicationCache API</a></li>
            <li><a href="#hdr_sec10_12">Application Cache in Action</a></li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>
          <a href="#hdr_sec26_12">Building an Application with HTML5 Offline Web Applications</a>
          <ul>
            <li><a href="#hdr_sec11_12">Creating a Manifest File for the Application Resources</a></li>
            <li><a href="#hdr_sec12_12">Creating the HTML Structure and CSS for the UI</a></li>
            <li><a href="#hdr_sec13_12">Creating the Offline JavaScript</a></li>
            <li><a href="#hdr_sec14_12">Check for ApplicationCache Support</a></li>
            <li><a href="#hdr_sec15_12">Adding the Update Button Handler</a></li>
            <li><a href="#hdr_sec16_12">Add Geolocation Tracking Code</a></li>
            <li><a href="#hdr_sec17_12">Adding Storage Code</a></li>
            <li><a href="#hdr_sec18_12">Adding Offline Event Handling</a></li>
          </ul>
        </li>
        <li><a href="#hdr_sec19_12">Summary</a></li>
      </ul>
    </li>
  </ul>
</nav>
</div>

  </body>

</html>
