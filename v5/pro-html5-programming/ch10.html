<!doctype html>

<!--[if lt IE 7]>      <html class="ie6 ie6-7 ie6-8"> <![endif]-->
<!--[if IE 7]>         <html class="ie7 ie6-7 ie7-8 ie6-8"> <![endif]-->
<!--[if IE 8]>         <html class="ie8 ie7-8 ie6-8"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

    <title>Pro HTML5 Programming: Chapter 10 | Using the Web Workers API</title>

    <meta name="description" content="">
    <meta name="author" content="">

    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="cleartype" content="on">
    
    <meta name="apple-mobile-web-app-title" content="Pro HTML5">

    <!-- Tile icon for Win8 (144x144 + tile color) -->
    <meta name="msapplication-TileImage" content="apple-touch-icon-144x144.png">
    <meta name="msapplication-TileColor" content="#da2f1e">

    <link rel="shortcut icon" href="favicon.ico">    

    <!-- CSS -->
    <link rel="stylesheet" href="../assets/libraries/codemirror/lib/codemirror.css">
    <link rel="stylesheet" href="../assets/libraries/codemirror/theme/ambiance.css">
    <link rel="stylesheet" href="../assets/libraries/codemirror/theme/static.css">
  	<link rel="stylesheet" href="../assets/stylesheets/style.css" />

    <!-- JavaScript -->
    <!--[if (lt IE 9) & (!IEMobile)]>
    <script src="js/selectivizr-min.js"></script>
    <![endif]-->

    <!-- THIRD-PARTY JS: JPANELMENU + BOOTSTRAP (NAV), CODEMIRROR (CODE EDITOR) //-->
    <script src="../assets/js/jquery-1.8.0.min.js"></script>
    <script src="../assets/js/modernizr-latest.js"></script>
    <script src="../assets/js/jpanelmenu-1.0.0.js"></script>
    <script src="../assets/js/jquery.popbox.js"></script>
    <script src="../assets/libraries/codemirror/lib/codemirror.js"></script>
    <script src="../assets/libraries/codemirror/mode/xml/xml.js"></script>
    <script src="../assets/libraries/codemirror/mode/javascript/javascript.js"></script>
    <script src="../assets/libraries/codemirror/mode/css/css.js"></script>
    <script src="../assets/libraries/codemirror/mode/htmlmixed/htmlmixed.js"></script>
    <!-- APP JS //-->
    <script type="text/javascript" charset="utf-8">
      "use strict";
      var APRI = { // APRess Interactive
        ISBNOnline: '978-1-4302-3865-2'
      };
    </script>
    <script src="../assets/js/application.js"></script>
    <!-- ADD CHAPTER CODE LISTINGS JS FILE HERE //-->
    <script src="toc.js"></script>

  </head>

  <body>

    <header class="controls-bar">
      <h1 class="book-title">Pro HTML5 Programming</h1>
      
      <div class="menu-link orig-menu menu-trigger">
        <a class="svg-menu" href="#main-navigation">Chapter Contents</a>
      </div>
      
      <div class="font-size-controls">
        <a href="#" class="btn btn-fs fs-smaller">Smaller</a>
        <a href="#" class="btn btn-fs fs-larger">Larger</a>
      </div>
    
      <div class="btn-group toc-link popbox" id="toc">
        <a class="btn dropdown-toggle trigger" data-toggle="dropdown" href="#">
          Table of Contents
          <span class="caret"></span>
        </a>
      </div>
    
    </header>
  
<!--======================== CONTENT ========================-->

<article role="main">
<div id="wrapper">


<hgroup>
  <a id="chapter_title" class="section-anchor"></a>
  <h1>Chapter 10</h1>
  <h1>Using the Web Workers API</h1>
</hgroup>

<p>JavaScript is single-threaded. As a result, long-lasting computations (not necessarily due to poorly written code) will block the UI thread and make it impossible to add text to text boxes, click buttons, use CSS effects, and, in most browsers, open new tabs until control has returned. As an answer to that problem, HTML5 Web Workers provide background-processing capabilities to web applications and typically run on separate threads so that JavaScript applications using Web Workers can take advantage of multicore CPUs. Separating long-running tasks into Web Workers also avoids the dreaded slow-script warnings<span class="index-term"><span class="primary">slow-script warnings</span></span>, shown in Figure <span class="internal-reference" id="ir_fig1_10">10-1</span>, that display when JavaScript loops continue for several seconds.
</p>
<figure id="fig1_10" class="image">
<img src="images/ch10/fig10-1.jpg">
<figcaption>Figure 10-1. Slow script warning in Firefox</figcaption></figure><p>As powerful as Web Workers are, there are also certain things they cannot do. For example, when a script is executing inside a Web Worker it cannot access the web page’s <code>window</code> object (<code> window.document</code>), which means that Web Workers don’t have direct access to the web page and the DOM API. Although Web Workers cannot block the browser UI, they can still consume CPU cycles and make the system less responsive.</p>

<p>Let’s say you want to create a web application that has to perform some background number crunching, but you do not want those tasks to interfere with the interactivity of the web page itself. Using Web Workers, you can spawn a Web Worker to perform the tasks and add an event listener to listen to messages from the Web Worker as they are sent.</p>

<p>Another use case for Web Workers could be an application that listens for broadcast news messages from a back-end server, posting messages to the main web page as they are received from the back-end server. This Web Worker might use Web Sockets or Server-Sent Events to talk to the back-end server.</p>

<p>In this chapter, we’ll explore what you can do with Web Workers. First, we’ll discuss how Web Workers work and the level of browser support available at the time of this writing. Then, we’ll discuss how you can use the APIs to create new workers and how to communicate between a worker and the context that spawned it. Finally, we’ll show you how you can build an application with Web Workers.</p>

<section id="sec2_10">
<a id="hdr_sec2_10" class="section-anchor"></a>

<h2>Browser Support for Web Workers</h2>
<p><span class="index-term"><span class="primary">Web Workers API</span><span class="secondary">browser support for</span></span>The majority of the modern web browsers support Web Workers. Check the web site <code>http://caniuse.com</code> (search for Web Workers) for the most up-to-date support matrix. While there are polyfill (emulation) libraries available for most other APIs—for example, for HTML5 Canvas there are libraries such as <code>excanvas.js</code> and <code>flashcanvas.js</code> that provide an emulation of the Canvas APIs (using Flash under the covers)—an emulation for Web Workers does not make a lot of sense, however. You can either call your worker code as a worker, or run the same code inline in your page, blocking the UI thread. The improved responsiveness of the worker-based page may just be enough to have people upgrade to a more modern browser (at least we hope it will).</p>
</section>

<section id="sec3_10">
<a id="hdr_sec3_10" class="section-anchor"></a>

<h2>Using the Web Workers API</h2>
<p>In this section, we’ll e<span class="index-term"><span class="primary">Web Workers API</span></span>xplore the use of the Web Workers API in more detail. For the sake of illustration, we’ve created a simple browser page: <code> echo.html</code>. Using Web Workers is fairly straightforward—you create a Web Worker object and pass in a JavaScript file to be executed. Inside the page you set up an event listener to listen to incoming messages and errors that are posted by the Web Worker and if you want to communicate from the page to the Web Worker, you call <code>postMessage</code> to pass in the required data. The same is true for the code in the Web Worker JavaScript file—event handlers must be set up to process incoming messages and errors, and communication with the page is handled with a call to <code>postMessage</code>.</p>

<section id="sec4_10">
<a id="hdr_sec4_10" class="section-anchor"></a>

<h3>Checking for Browser Support</h3>
<p>Before you call the Web Workers API<span class="index-term"><span class="primary">Web Workers API</span><span class="secondary">checking for browser support</span></span> functions, you will want to make sure there is support in the browser for what you’re about to do. This way, you can provide some alternate text, prompting the users of your application to use a more up-to-date browser. Listing 10-1 shows the code you can use to test for browser support.</p>

<figure class="listing"><figcaption>Listing 10-1. Checking for Browser Support</figcaption><pre><code>function loadDemo() {
  if (typeof(Worker) !== "undefined") {
    document.getElementById("support").innerHTML =
            "Excellent! Your browser supports Web Workers";
  }
}</code></pre></figure><p>In this example, you test for browser support in the <code>loadDemo</code> function, which might be called when the page is loaded. A call to <code>typeof(Worker)</code> will return the window’s global <code>Worker</code> property, which will be undefined if the browser doesn’t support the Web Workers API. In this example, the page is updated to reflect whether there is browser support by updating a previously defined <code>support</code> element on the page with a suitable message, as shown at the top of Figure <span class="internal-reference" id="ir_fig2_10">10-2</span>.

</p>
<figure id="fig2_10" class="image">
<img src="images/ch10/fig10-2.jpg">
<figcaption>Figure 10-2. Example of showing <span class="index-term"><span class="primary">Web Workers API</span><span class="secondary">checking for browser support</span></span>whether Web Workers is supported</figcaption></figure>
</section>

<section id="sec5_10">
<a id="hdr_sec5_10" class="section-anchor"></a>

<h3>Creating Web Workers</h3>
<p>Web Workers<span class="index-term"><span class="primary">Web Workers API</span><span class="secondary">creating Web Workers</span></span> are initialized with the URL of a JavaScript file, which contains the code the worker will execute. This code sets event listeners and communicates with the script that spawned it. The URL for the JavaScript file can be a relative or absolute URL with the same origin (the same scheme, host, and port) as the main page:</p>

<pre><code>worker = new Worker("echoWorker.js");</code></pre>
</section>

<section id="sec6_10">
<a id="hdr_sec6_10" class="section-anchor"></a>

<h3>Inline Workers</h3>
<p><span class="index-term"><span class="primary">Web Workers API</span><span class="secondary">creating Web Workers</span><tertiary>inline workers</tertiary></span>To start a worker you need to point to a file. You may have seen some examples of script elements that have the type <code>javascript/worker</code>, as shown in the following example:</p>

<pre><code> &lt;script id="myWorker" type="javascript/worker"&gt;</code></pre>
<p>Don’t let this fool you into thinking that you can simply set the type of a script element to run the JavaScript code as a Web Worker. In this case, the type information is used to signal the browser and its JavaScript engine <em>not</em> to parse and run the script. In fact, the type may as well have been <em>anything</em> other than <code>text/javascript</code>. The script example shown is a building block for <em>inline Web Workers</em>—a feature that can be used only if your browser also supports the File System API (Blob Builder or File Writer). In that case you can programmatically find the script block (in the previous case, the element with the <code>myWorker</code> id) and write the Web Worker JavaScript file to disk. After that, you can call the inline Web Worker<span class="index-term"><span class="primary">Web Workers API</span><span class="secondary">creating Web Workers</span><tertiary>inline workers</tertiary></span> in your code.</p>
</section>

<section id="sec7_10">
<a id="hdr_sec7_10" class="section-anchor"></a>

<h3>Shared Workers</h3>
<p><span class="index-term"><span class="primary">Web Workers API</span><span class="secondary">creating Web Workers</span><tertiary>shared workers</tertiary></span>There is yet another type of worker, which is not widely supported at the time of this writing: the shared Web Worker. A shared Web Worker is like a normal Web Worker, but it can be shared across multiple pages on the same origin. Shared Web Workers introduce the notion of <em>ports</em> that are used for <code>PostMessage</code> communication. Shared Web Workers can be useful for data synchronization among multiple pages (or tabs) on the same origin or to share a long-lived resource (like a WebSocket) among several tabs.</p>

<p>The syntax for starting a shared Web Worker is as follows:</p>

<pre><code>sharedWorker = new SharedWorker(sharedEchoWorker.js');</code></pre>
</section>

<section id="sec8_10">
<a id="hdr_sec8_10" class="section-anchor"></a>

<h3>Loading and Executing Additional JavaScript</h3>
<p>An application composed <span class="index-term"><span class="primary">Web Workers API</span><span class="secondary">loading and executing JavaScript</span></span>of several JavaScript files can contain <code>&lt;script&gt;</code> elements that synchronously load JavaScript files as the page loads. However, because Web Workers do not have access to the <code>document</code> object, there is an alternative mechanism for synchronously importing additional JavaScript files from within workers– <code>importScripts</code>:</p>

<pre><code>importScripts("helper.js");</code></pre>
<p>Importing a JavaScript file simply loads and executes JavaScript into an existing worker. Multiple scripts can be imported by the same call to <code>importScripts</code>. They are executed in the order specified:</p>

<pre><code>importScripts("helper.js", "anotherHelper.js");</code></pre>
</section>

<section id="sec9_10">
<a id="hdr_sec9_10" class="section-anchor"></a>

<h3>Communicating with Web Workers</h3>
<p>Once the Web Worker<span class="index-term"><span class="primary">Web Workers API</span><span class="secondary">communicating with web workers</span></span> is spawned, you can use the <code>postMessage</code> API to send data to and from Web Workers. This is the same <code>postMessage</code> API<span class="index-term"><span class="primary">postMessage API</span></span> that is used for cross-frame and cross-window communication. <code> postMessage</code> can be used to send most JavaScript objects, but not functions or objects with cyclic references.</p>

<p>Let’s say that you want to build a simple Web Worker example that allows users to send a message to a worker, which in turn echoes back the message. This example may not be very useful in real life, but it’s useful enough to explain the concepts you need to build more complex examples. Figure <span class="internal-reference" id="ir_fig3_10">10-3</span> shows this example web page and its Web Worker in action. The code for this simple page is listed at the end of this section. 
</p>
<figure id="fig3_10" class="image"><img src="images/ch10/fig10-3.jpg"><figcaption>Figure 10-3. A simple web page that uses Web Workers</figcaption></figure><p>To set up proper communication with your Web Worker, code has to be added to the <em>main page</em> (the page that calls the Web Worker) as<span class="index-term"><span class="primary">Web Workers API</span><span class="secondary">communicating with web workers</span></span> well as the worker JavaScript file.</p>

</section>
</section>

<section id="sec10_10">
<a id="hdr_sec10_10" class="section-anchor"></a>

<h2>Coding the Main Page</h2>
<p>To communicate from the page to the Web Worker, you call <code>postMessage</code> to pass in the required data. To listen to incoming messages and errors that are sent by the Web Worker to the page, you set up an event listener.</p>

<p>To set up communication between the main page and the Web Worker, first add the call to <code>postMessage</code> to the main page, as follows:</p>

<pre><code>document.getElementById("helloButton").onclick = function() {
  worker.postMessage("Here's a message for you");
}</code></pre>


<p>In the preceding example, a message is sent to the Web Worker when the user clicks the <strong>Post a Message</strong> button. Next, add an event <span class="index-term"><span class="primary">Web Workers API</span><span class="secondary">communicating with web workers</span></span>listener to the page that listens for messages from the Web Worker:</p>

<pre><code>worker.addEventListener("message", messageHandler, true);
function messageHandler(e) {
    // process message from worker
}</code></pre>



<section id="sec11_10">
<a id="hdr_sec11_10" class="section-anchor"></a>

<h3>Coding the Web Worker JavaScript File</h3>
<p>You must now add similar<span class="index-term"><span class="primary">Web Workers API</span><span class="secondary">coding JavaScript file</span></span> code to the Web Worker JavaScript file—event handlers must be set up to process incoming messages and errors, and communication with the page is handled with a call to <code>postMessage</code>.</p>

<p>To complete the communication between the page and the Web Worker, first, add the call to <code>postMessage</code>; for example, inside a <code>messageHandler</code> function:</p>

<pre><code>function messageHandler(e) {
  postMessage("worker says: " + e.data + " too");
}</code></pre>


<p>Next, add an event listener to the Web Worker JavaScript file that handles messages coming from the main page:</p>

<pre><code>addEventListener("message", messageHandler, true);</code></pre>
<p>In this example, the <code>messageHandler</code> function<span class="index-term"><span class="primary">messageHandler function</span></span> is called immediately when the message is received so that the message can be echoed back.</p>

<p>Note that if this was a shared worker, you would use a slightly different syntax (using a <code>port</code>):</p>

<pre><code>sharedWorker.port.addEventListener("message", messageHandler, true);
sharedWorker.port.postMessage("Hello HTML5");</code></pre>

<p>In addition, the worker can listen to a <code>connect</code> event for incoming connections. You can use this to count active connections.</p>
</section>

<section id="sec12_10">
<a id="hdr_sec12_10" class="section-anchor"></a>

<h3>Handling Errors</h3>
<p><span class="index-term"><span class="primary">Web Workers API</span><span class="secondary">handling errors</span></span>Unhandled errors in a Web Worker script fire error events on the Web Worker object. Listening for these error events is especially important when you are debugging scripts that make use of Web Workers. The following shows an example of an error handling function in a Web Worker JavaScript file that logs errors to the console:</p>

<pre><code>function errorHandler(e) {
    console.log(e.message, e);
}
    To handle the errors, you must add an event listener to the main page:
worker.addEventListener("error", errorHandler, true);</code></pre>




<p> Most browsers don’t have a great way to step through Web Worker code yet, but Google Chrome offers Web Worker debugging capabilities in its Chrome Developer Tools (in the Scripts tab, look for Worker inspectors), as shown in Figure <span class="internal-reference" id="ir_fig4_10">10-4</span>. 
</p>
<figure id="fig4_10" class="image"><img src="images/ch10/fig10-4.png"><figcaption>Figure 10-4. Web Worker debugging options in Chrome Developer ToolsStopping Web Workers</figcaption></figure><p>Web Workers don’t <span class="index-term"><span class="primary">Web Workers API</span><span class="secondary">stopping Web Workers</span></span>stop by themselves; but the page that started them can stop them. If the page is closed, Web Workers will be garbage-collected, so rest assured you won’t have any zombie workers hanging around performing background tasks. However, you may want to reclaim resources when a Web Worker is no longer needed―perhaps when the main page is notified that the Web Worker has finished its tasks. You may also wish to cancel a long-running task in response to user actions. Calling <code>terminate</code> stops the Web Worker. A terminated Web Worker will no longer respond to messages or perform any additional computations. You cannot restart a worker; instead, you can create a new worker using the same URL.</p>

<pre><code>worker.terminate();</code></pre>
</section>

<section id="sec13_10">
<a id="hdr_sec13_10" class="section-anchor"></a>

<h3>Using Web Workers within Web Workers</h3>
<p>The Worker API can be <span class="index-term"><span class="primary">Web Workers API</span><span class="secondary">within Web Workers</span></span>used inside Web Worker scripts to create subworkers:</p>

<pre><code>var subWorker = new Worker("subWorker.js");</code></pre>
<aside>
<h3>Lots of Workers</h3>
<p><strong>Peter says</strong>: “If you spawn a Worker that <em>recursively</em> spawns subworker with the same JavaScript source file, you will see some interesting results, to say the least.”</p>

</aside>
</section>

<section id="sec16_10">
<a id="hdr_sec16_10" class="section-anchor"></a>

<h3>Using Timers</h3>
<p>Although Web <span class="index-term"><span class="primary">Web Workers API</span><span class="secondary">timers</span></span>Workers cannot access the <code>window</code> object, they can make use of the full JavaScript timing API, typically found on the global window:</p>

<pre><code>var t = setTimeout(postMessage, 2000, "delayed message");</code></pre>
</section>

<section id="sec17_10">
<a id="hdr_sec17_10" class="section-anchor"></a>

<h3>Example Code</h3>
<p>For completeness, Listings 10-2 and 10-3 <span class="index-term"><span class="primary">Web Workers API</span><span class="secondary">example code</span></span>show the code for the simple page and the Web Worker JavaScript file.</p>

<figure class="listing"><figcaption>Listing 10-2. Simple HTML Page That Calls a Web Worker</figcaption><pre><code>&lt;!DOCTYPE html&gt; 
&lt;title&gt;Simple Web Workers Example&lt;/title&gt;
&lt;link rel="stylesheet" href="styles.css"&gt;
&lt;h1&gt;Simple Web Workers Example&lt;/h1&gt;
&lt;p id="support"&gt;Your browser does not support Web Workers.&lt;/p&gt;
&lt;button id="stopButton"&gt;Stop Task&lt;/button&gt;
&lt;button id="helloButton"&gt;Post a Message&lt;/button&gt;
&lt;script&gt;
   function stopWorker() {
       worker.terminate();
   }
   function messageHandler(e) {
       console.log(e.data);
   }
   function errorHandler(e) {
       console.warn(e.message, e);
   }
   function loadDemo() {
       if (typeof(Worker) !== "undefined") {
           document.getElementById("support").innerHTML = "Excellent! Your browser supports Web Workers";
           worker = new Worker("echoWorker.js");
           worker.addEventListener("message", messageHandler, true);
           worker.addEventListener("error", errorHandler, true);
           document.getElementById("helloButton").onclick = function() {
               worker.postMessage("Here's a message for you");
       }
          document.getElementById("stopButton").onclick = stopWorker;
    }
}
window.addEventListener("load", loadDemo, true);
&lt;/script&gt;</code></pre></figure><figure class="listing"><figcaption>Listing 10-3. Simple Web Worker JavaScript File</figcaption><pre><code>function messageHandler(e) {
  postMessage("worker says: " + e.data + " too");
}
addEventListener("message", messageHandler, true);</code></pre></figure>

</section>
</section>

<section id="sec18_10">
<a id="hdr_sec18_10" class="section-anchor"></a>

<h2>
<span class="index-term"><span class="primary">Web Workers API</span><span class="secondary">example code</span></span>Building an Application with Web Workers</h2>
<p>So far, we’ve focused on using <span class="index-term"><span class="primary">Web Workers API</span><span class="secondary">building application with</span></span>the different Web Worker APIs. Let’s see how powerful the Web Workers API can really be by building an application: a web page with an image-blurring filter, parallelized to run on multiple Web Workers. Figure <span class="internal-reference" id="ir_fig5_10">10-5</span> shows what this application looks like when you start it. 
</p>
<figure id="fig5_10" class="image"><img src="images/ch10/fig10-5.jpg"><figcaption>Figure 10-5. Web Worker–based web page with image-blurring filter</figcaption></figure><p>This application sends <span class="index-term"><span class="primary">Web Workers API</span><span class="secondary">building application with</span></span>image data from a canvas to several Web Workers (you can specify how many). The Web Workers then process the image with a simple box-blur filter. This may take several seconds, depending on the size of the image and the computational resources available (even machines with fast CPUs may have load from other processes, causing JavaScript execution to take more wall-clock time to complete). Figure <span class="internal-reference" id="ir_fig6_10">10-6</span> shows the same page after running the blur filtering process for a while. 
</p>
<figure id="fig6_10" class="image"><img src="images/ch10/fig10-6.jpg"><figcaption>Figure 10-6. Image-Blurring web page after running for a while</figcaption></figure><p>However, because the heavy lifting takes place in Web Workers, there is no danger of slow-script warnings and, therefore, no need to manually partition the task into scheduled slices—something you would have to consider if you could not use Web Workers.<span class="index-term"><span class="primary">Web Workers API</span><span class="secondary">building application with</span></span>
</p>

<section id="sec19_10">
<a id="hdr_sec19_10" class="section-anchor"></a>

<h3>Coding the blur.js Helper Script</h3>
<p>Inside the <code>blur.js</code> application page, we <span class="index-term"><span class="primary">Web Workers API</span><span class="secondary">building application with</span><tertiary>coding blur.js helper script</tertiary></span>can use a straightforward implementation of a blur filter that loops until it has completely processed its input, as shown in Listing 10-4.</p>

<figure class="listing"><figcaption>Listing 10-4. A JavaScript Box-blur Implementation in the File blur.js</figcaption><pre><code>function inRange(i, width, height) {
    return ((i&gt;=0) &amp;&amp; (i &lt; width*height*4));
}
function averageNeighbors(imageData, width, height, i) {
    var v = imageData[i];
    // cardinal directions
    var north = inRange(i-width*4, width, height) ? imageData[i-width*4] : v;
    var south = inRange(i + width*4, width, height) ? imageData[i + width*4] : v;
    var west = inRange(i-4, width, height) ? imageData[i-4] : v;
    var east = inRange(i + 4, width, height) ? imageData[i + 4] : v;
    // diagonal neighbors
    var ne = inRange(i-width*4 + 4, width, height) ? imageData[i-width*4 + 4] : v;
    var nw = inRange(i-width*4-4, width, height) ? imageData[i-width*4-4] : v;
    var se = inRange(i + width*4 + 4, width, height) ? imageData[i + width*4 + 4] : v;
    var sw = inRange(i + width*4-4, width, height) ? imageData[i + width*4-4] : v;
    // average
    var newVal = Math.floor((north + south + east + west + se + sw + ne + nw + v)/9);
    if (isNaN(newVal)) {
        sendStatus("bad value " + i + " for height " + height);
        throw new Error("NaN");
    }
    return newVal;
}
function boxBlur(imageData, width, height) {
    var data = [];
    var val = 0;
    for (var i=0; i&lt;width*height*4; i++) {
        val = averageNeighbors(imageData, width, height, i);
        data[i] = val;
    }
    return data;
}</code></pre></figure><p>In brief, this algorithm blurs an image by averaging nearby pixel values. For a large image with millions of pixels, this takes a substantial amount of time. It is very undesirable to run a loop such as this in the UI thread. Even if a slow-script warning did not appear, the page UI would be unresponsive until the loop terminated. For this reason, it makes a good example of<span class="index-term"><span class="primary">Web Workers API</span><span class="secondary">building application with</span><tertiary>coding blur.js helper script</tertiary></span> background computation in Web Workers.</p>
</section>

<section id="sec20_10">
<a id="hdr_sec20_10" class="section-anchor"></a>

<h3>Coding the blur.html Application Page</h3>
<p>Listing 10-5 shows the<span class="index-term"><span class="primary">Web Workers API</span><span class="secondary">building application with</span><tertiary>coding blur.html application page</tertiary></span> code for the HTML page that calls the Web Worker. The HTML for this example is kept simple for reasons of clarity. The purpose here is not to build a beautiful interface, but to provide a simple skeleton that can control the Web Workers and demonstrate them in action. In this application, a <code>canvas</code> element that displays the input image is injected into the page. We have buttons to start blurring the image, stop blurring, reset the image, and specify the number of workers to spawn.</p>

<figure class="listing"><figcaption>Listing 10-5. Code for the Page blur.html</figcaption><pre><code>&lt;!DOCTYPE html&gt;
&lt;title&gt;Web Workers&lt;/title&gt;
&lt;link rel="stylesheet" href = "styles.css"&gt;
&lt;h1&gt;Web Workers&lt;/h1&gt;
&lt;p id="status"&gt;Your browser does not support Web Workers.&lt;/p&gt;
&lt;button id="startBlurButton" disabled&gt;Blur&lt;/button&gt;
&lt;button id="stopButton" disabled&gt;Stop Workers&lt;/button&gt;
&lt;button onclick="document.location = document.location;"&gt;Reload&lt;/button&gt;
&lt;label for="workerCount"&gt;Number of Workers&lt;/label&gt;
&lt;select id="workerCount"&gt;
    &lt;option&gt;1&lt;/option&gt;
    &lt;option selected&gt;2&lt;/option&gt;
    &lt;option&gt;4&lt;/option&gt;
    &lt;option&gt;8&lt;/option&gt;
    &lt;option&gt;16&lt;/option&gt;
&lt;/select&gt;
&lt;div id="imageContainer"&gt;&lt;/div&gt;
&lt;div id="logOutput"&gt;&lt;/div&gt;</code></pre></figure><p>Next, let’s add the code to create workers to the file <code>blur.html</code>. We instantiate a <code>worker</code> object, passing in a URL of a JavaScript file. Each instantiated worker will run the same code but be responsible for processing different parts of the input image:</p>

<pre><code>function initWorker(src) {
    var worker = new Worker(src);
    worker.addEventListener("message", messageHandler, true);
    worker.addEventListener("error", errorHandler, true);
    return worker;
}</code></pre>





<p>Let’s add the error handling code to the file <code>blur.html</code>, as follows. In the event of an error in the worker, the page will be able to display an error message instead of continuing unaware. Our example shouldn’t encounter any trouble, but listening for error events is generally <span class="index-term"><span class="primary">Web Workers API</span><span class="secondary">building application with</span><tertiary>coding blur.html application page</tertiary></span>a good practice and is invaluable for debugging.</p>

<pre><code>function errorHandler(e) {
    log("error: " + e.message);
}</code></pre>
</section>

<section id="sec39_10">
<a id="hdr_sec39_10" class="section-anchor"></a>

<h3>Coding the blurWorker.js Web Worker Script</h3>
<p>Next, we add the code that <span class="index-term"><span class="primary">Web Workers API</span><span class="secondary">building application with</span><tertiary>coding blurWorker.js Web Worker script</tertiary></span>our workers use to communicate with the page to the file <code>blurWorker.js</code> (see Listing 10-6). As the Web Workers finish blocks of computation, they can use <code>postMessage</code> to inform the page that they have made progress. We will use this information to update the image displayed on the main page. After creation, our Web Workers wait for a message containing image data and the instruction to commence blurring. This message is a JavaScript object containing the type of message and the image data represented as an array of Numbers.</p>

<figure class="listing"><figcaption>Listing 10-6. Sending and Handling Image Data in the File blurWorker.js</figcaption><pre><code>function sendStatus(statusText) {
    postMessage({"type" : "status",
                 "statusText" : statusText}
                );
}
function messageHandler(e) {
    var messageType = e.data.type;
    switch (messageType) {
        case ("blur"):
            sendStatus("Worker started blur on data in range: " +
                            e.data.startX + "-" + (e.data.startX + e.data.width));
            var imageData = e.data.imageData;
            imageData = boxBlur(imageData, e.data.width, e.data.height, e.data.startX);
            postMessage({"type" : "progress",
                         "imageData" : imageData,
                         "width" : e.data.width,
                         "height" : e.data.height,
                         "startX" : e.data.startX
                        });
            sendStatus("Finished blur on data in range: " +
                            e.data.startX + "-" + (e.data.width + e.data.startX));
            break;
        default:
            sendStatus("Worker got message: " + e.data);
    }
}
addEventListener("message", messageHandler, true);Web Workers APIbuilding application withcoding blurWorker.js Web Worker script
</code></pre></figure>
</section>

<section id="sec21_10">
<a id="hdr_sec21_10" class="section-anchor"></a>

<h3>Communicating with the Web Workers</h3>
<p>In the file <code>blur.html</code>, we can<span class="index-term"><span class="primary">Web Workers API</span><span class="secondary">building application with</span><tertiary>communicating with Web Workers</tertiary></span> use our workers by sending them some data and arguments that represent a blur task. This is done by using <code>postMessage</code> to send a JavaScript object containing the Array of RGBA image data, the <span class="index-term"><span class="primary">image data</span></span><span class="index-term"><span class="primary">Canvas image data</span></span><span class="index-term"><span class="primary">images processing</span></span>dimensions of the source image, and the range of pixels for which the worker is responsible. Each worker processes a different section of the image based on the message it receives:</p>

<pre><code>function sendBlurTask(worker, i, chunkWidth) {
        var chunkHeight = image.height;
        var chunkStartX = i * chunkWidth;
        var chunkStartY = 0;
        var data = ctx.getImageData(chunkStartX, chunkStartY,
                                    chunkWidth, chunkHeight).data;
        worker.postMessage({'type' : 'blur',
                            'imageData' : data,
                            'width' : chunkWidth,
                            'height' : chunkHeight,
                            'startX' : chunkStartX});
}</code></pre>











<aside>
<h3>Canvas image data</h3>
<p><strong>Frank says</strong>: “<code> postMessage</code> is <span class="index-term"><span class="primary">postMessage API</span></span>specified to allow efficient serialization of <code>imageData</code> objects for<span class="index-term"><span class="primary">imageData objects</span></span> use with the canvas API. Some browsers that include the Worker and <code>postMessage</code> APIs may not support the extended serialization capabilities of <code>postMessage</code> yet.</p>

<p>Because of this, our image processing example presented in this chapter sends <code>imageData.data</code><span class="index-term"><span class="primary">imageData.data</span></span> (which serializes like a JavaScript Array) instead of sending the <code>imageData</code> object itself. As the Web Workers compute their tasks, they communicate their status and results back to the page. Listing 10-6 shows how data is sent from the worker(s) to the page after the blur filter has processed it. Again, the message contains a JavaScript object with fields for image data and coordinates marking the boundaries of the processed section.”</p>

</aside><p>On the HTML page side, a message<span class="index-term"><span class="primary">Web Workers API</span><span class="secondary">building application with</span><tertiary>communicating with Web Workers</tertiary></span> handler consumes this data and uses it to update the canvas with the new pixel values. As processed image data comes in, the result is immediately visible. We now have a sample application that can process images while potentially taking advantage of multiple CPU cores. Moreover, we didn’t lock up the UI and make it unresponsive while the Web Workers were active. Figure <span class="internal-reference" id="ir_fig7_10">10-7</span> shows the application in action.

</p>
<figure id="fig7_10" class="image"><img src="images/ch10/fig10-7.jpg"><figcaption>Figure 10-7. The blur application in action</figcaption></figure>
</section>

<section id="sec22_10">
<a id="hdr_sec22_10" class="section-anchor"></a>

<h3>The Application in Action</h3>
<p>To see this example<span class="index-term"><span class="primary">Web Workers API</span><span class="secondary">building application with</span><tertiary>application in action</tertiary></span> in action, the page <code>blur.html</code> has to be served up by a web server (for example, Apache or Python’s SimpleHTTPServer). To following steps show how you can use Python SimpleHTTPServer to run the application:</p>
<ol>
<li>
<p>Install Python.</p>
</li>
<li>
<p>Navigate to the directory that contains the example file (<code> blur.html</code>).</p>
</li>
<li>
<p>Start Python as follows:</p>
</li>
</ol>python -m SimpleHTTPServer 9999<ol>
<li>
<p>Open a browser and navigate to <code>http://localhost:9999/blur.html</code>. You should now see the page shown in Figure <span class="internal-reference" id="ir_fig7_10">10-7</span>.</p>
</li>
<li>
<p>If you leave it running for a while, you will see the different quadrants of the image blur slowly. The number of quadrants that blur at the same time depends on the number of workers you started.<span class="index-term"><span class="primary">Web Workers API</span><span class="secondary">building application with</span><tertiary>application in action</tertiary></span>
</p>
</li>
</ol>
</section>

<section id="sec23_10">
<a id="hdr_sec23_10" class="section-anchor"></a>

<h3>Example Code</h3>
<p>For <span class="index-term"><span class="primary">Web Workers API</span><span class="secondary">building application with</span><tertiary>example code</tertiary></span>completeness, Listings 10-7, 10-8, and 10-9 contain the full code for the example application.</p>

<figure class="listing"><figcaption>Listing 10-7. Content of the File blur.html</figcaption><pre><code>&lt;!DOCTYPE html&gt;
&lt;title&gt;Web Workers&lt;/title&gt;
&lt;link rel="stylesheet" href = "styles.css"&gt;
&lt;h1&gt;Web Workers&lt;/h1&gt;
&lt;p id="status"&gt;Your browser does not support Web Workers.&lt;/p&gt;
&lt;button id="startBlurButton" disabled&gt;Blur&lt;/button&gt;
&lt;button id="stopButton" disabled&gt;Stop Workers&lt;/button&gt;
&lt;button onclick = "document.location = document.location;"&gt;Reload&lt;/button&gt;
&lt;label for="workerCount"&gt;Number of Workers&lt;/label&gt;
&lt;select id="workerCount"&gt;
    &lt;option&gt;1&lt;/option&gt;
    &lt;option selected&gt;2&lt;/option&gt;
    &lt;option&gt;4&lt;/option&gt;
    &lt;option&gt;8&lt;/option&gt;
    &lt;option&gt;16&lt;/option&gt;
&lt;/select&gt;
&lt;div id="imageContainer"&gt;&lt;/div&gt;
&lt;div id="logOutput"&gt;&lt;/div&gt;
&lt;script&gt;
var imageURL = "example2.png";
var image;
var ctx;
var workers = [];
function log(s) {
    var logOutput = document.getElementById("logOutput");
    logOutput.innerHTML = s + "&lt;br&gt;" + logOutput.innerHTML;
}
function setRunningState(p) {
    // while running, the stop button is enabled and the start button is not
    document.getElementById("startBlurButton").disabled = p;
    document.getElementById("stopButton").disabled = !p;
}
function initWorker(src) {
    var worker = new Worker(src);
    worker.addEventListener("message", messageHandler, true);
    worker.addEventListener("error", errorHandler, true);
    return worker;
}
function startBlur() {
    var workerCount = parseInt(document.getElementById("workerCount").value);
    var width = image.width/workerCount;
for (var i=0; i&lt;workerCount; i++) {
        var worker = initWorker("blurWorker.js");
        worker.index = i;
        worker.width = width;
        workers[i] = worker;
        sendBlurTask(worker, i, width);
    }
    setRunningState(true);
}
function sendBlurTask(worker, i, chunkWidth) {
        var chunkHeight = image.height;
        var chunkStartX = i * chunkWidth;
        var chunkStartY = 0;
        var data = ctx.getImageData(chunkStartX, chunkStartY,
                                    chunkWidth, chunkHeight).data;
        worker.postMessage({'type' : 'blur',
                            'imageData' : data,
                            'width' : chunkWidth,
                            'height' : chunkHeight,
                            'startX' : chunkStartX});
}
function stopBlur() {
    for (var i=0; i&lt;workers.length; i++) {
        workers[i].terminate();
    }
    setRunningState(false);
}
function messageHandler(e) {
    var messageType = e.data.type;
    switch (messageType) {
        case ("status"):
            log(e.data.statusText);
            break;
        case ("progress"):
            var imageData = ctx.createImageData(e.data.width, e.data.height);
            for (var i=0; i&lt;imageData.data.length; i++) {
                var val = e.data.imageData[i];
                if (val === null || val &gt; 255 || val &lt; 0) {
                    log("illegal value: " + val + " at " + i);
                    return;
                }
                imageData.data[i] = val;
            }
            ctx.putImageData(imageData, e.data.startX, 0);
            // blur the same tile again
            sendBlurTask(e.target, e.target.index, e.target.width);
            break;
        default:
            break;
    }
}
function errorHandler(e) {
    log("error: " + e.message);
}
function loadImageData(url) {
    var canvas = document.createElement('canvas');
    ctx = canvas.getContext('2d');
    image = new Image();
    image.src = url;
    document.getElementById("imageContainer").appendChild(canvas);
    image.onload = function(){
        canvas.width = image.width;
        canvas.height = image.height;
        ctx.drawImage(image, 0, 0);
        window.imgdata = ctx.getImageData(0, 0, image.width, image.height);
        n = ctx.createImageData(image.width, image.height);
        setRunningState(false);
        log("Image loaded: " + image.width + "x" + image.height + " pixels");
    };
}
function loadDemo() {
    log("Loading image data");
    if (typeof(Worker) !== "undefined") {
        document.getElementById("status").innerHTML = "Your browser supports Web Workers";
        document.getElementById("stopButton").onclick = stopBlur;
        document.getElementById("startBlurButton").onclick = startBlur;
        loadImageData(imageURL);
        document.getElementById("startBlurButton").disabled = true;
        document.getElementById("stopButton").disabled = true;
    }
}
window.addEventListener("load", loadDemo, true);
&lt;/script&gt;</code></pre></figure><figure class="listing"><figcaption>Listing 10-8. Content of the File blurWorker.js</figcaption><pre><code>importScripts("blur.js");
function sendStatus(statusText) {
    postMessage({"type" : "status",
                 "statusText" : statusText}
                );
}
function messageHandler(e) {
    var messageType = e.data.type;
    switch (messageType) {
        case ("blur"):
            sendStatus("Worker started blur on data in range: " +
                            e.data.startX + "-" + (e.data.startX + e.data.width));
            var imageData = e.data.imageData;
            imageData = boxBlur(imageData, e.data.width, e.data.height, e.data.startX);
            postMessage({"type" : "progress",
                         "imageData" : imageData,
                         "width" : e.data.width,
                         "height" : e.data.height,
                         "startX" : e.data.startX
                        });
            sendStatus("Finished blur on data in range: " +
                            e.data.startX + "-" + (e.data.width + e.data.startX));
            break;
        default:
            sendStatus("Worker got message: " + e.data);
    }
}
addEventListener("message", messageHandler, true);</code></pre></figure><figure class="listing"><figcaption>Listing 10-9. Content of the File blur.js</figcaption><pre><code>function inRange(i, width, height) {
    return ((i&gt;=0) &amp;&amp; (i &lt;width*height*4));
}
function averageNeighbors(imageData, width, height, i) {
    var v = imageData[i];
    // cardinal directions
    var north = inRange(i-width*4, width, height) ? imageData[i-width*4] : v;
    var south = inRange(i + width*4, width, height) ? imageData[i + width*4] : v;
    var west = inRange(i-4, width, height) ? imageData[i-4] : v;
    var east = inRange(i + 4, width, height) ? imageData[i + 4] : v;
    // diagonal neighbors
    var ne = inRange(i-width*4 + 4, width, height) ? imageData[i-width*4 + 4] : v;
    var nw = inRange(i-width*4-4, width, height) ? imageData[i-width*4-4] : v;
    var se = inRange(i + width*4 + 4, width, height) ? imageData[i + width*4 + 4] : v;
    var sw = inRange(i + width*4-4, width, height) ? imageData[i + width*4-4] : v;
    // average
    var newVal = Math.floor((north + south + east + west + se + sw + ne + nw + v)/9);
    if (isNaN(newVal)) {
        sendStatus("bad value " + i + " for height " + height);
        throw new Error("NaN");
    }
    return newVal;
}
function boxBlur(imageData, width, height) {
    var data = [];
    var val = 0;
    for (var i=0; i &lt; width*height*4; i++) {
        val = averageNeighbors(imageData, width, height, i);
        data[i] = val;
    }
    return data;
}</code></pre></figure>

</section>
</section>
<section id="sec24_10">
<a id="hdr_sec24_10" class="section-anchor"></a>

<h2>Summary</h2>

<p>In this chapter, you have<span class="index-term"><span class="primary">Web Workers API</span><span class="secondary">building application with</span><tertiary>example code</tertiary></span> seen how Web Workers can be used to create web applications with background processing. This chapter showed you how Web Workers (and inline and shared Web Workers) work. We discussed how you can use the APIs to create new workers and how you communicate between a worker and the context that spawned it. Finally, we showed you how you can build an application with Web Workers. In the next chapter, we’ll demonstrate more ways that HTML5 lets you keep local copies of data and reduce the amount of network overhead in your applications.</p>

</section>

<footer class="next-chapter">
  <p><a href="ch11.html">Go to the Next Chapter</a></p>
</footer>

</div>
</article>

<!--====================== END CONTENT ======================-->

<a id="main-navigation" class="nav-anchor"></a>
<div class="nav-container">
<nav id="menu" role="navigation">
  <ul>
    <li class="current">
      <a href="#chapter_title">Chapter 10</a>
      <ul>
        <li><a href="#hdr_sec2_10">Browser Support for Web Workers</a></li>
        <li>
          <a href="#hdr_sec3_10">Using the Web Workers API</a>
          <ul>
            <li><a href="#hdr_sec4_10">Checking for Browser Support</a></li>
            <li><a href="#hdr_sec5_10">Creating Web Workers</a></li>
            <li><a href="#hdr_sec6_10">Inline Workers</a></li>
            <li><a href="#hdr_sec7_10">Shared Workers</a></li>
            <li><a href="#hdr_sec8_10">Loading and Executing Additional JavaScript</a></li>
            <li><a href="#hdr_sec9_10">Communicating with Web Workers</a></li>
          </ul>
        </li>
        <li>
          <a href="#hdr_sec10_10">Coding the Main Page</a>
          <ul>
            <li><a href="#hdr_sec11_10">Coding the Web Worker JavaScript File</a></li>
            <li><a href="#hdr_sec12_10">Handling Errors</a></li>
            <li><a href="#hdr_sec13_10">Using Web Workers within Web Workers</a></li>
            <li><a href="#hdr_sec16_10">Using Timers</a></li>
            <li><a href="#hdr_sec17_10">Example Code</a></li>
          </ul>
        </li>
        <li>
          <a href="#hdr_sec18_10">Building an Application with Web Workers</a>
          <ul>
            <li><a href="#hdr_sec19_10">Coding the blur.js Helper Script</a></li>
            <li><a href="#hdr_sec20_10">Coding the blur.html Application Page</a></li>
            <li><a href="#hdr_sec39_10">Coding the blurWorker.js Web Worker Script</a></li>
            <li><a href="#hdr_sec21_10">Communicating with the Web Workers</a></li>
            <li><a href="#hdr_sec22_10">The Application in Action</a></li>
            <li><a href="#hdr_sec23_10">Example Code</a></li>
          </ul>
        </li>
        <li><a href="#hdr_sec24_10">Summary</a></li>
      </ul>
    </li>
  </ul>
</nav>
</div>


  </body>

</html>
