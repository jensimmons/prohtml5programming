<!doctype html>

<!--[if lt IE 7]>      <html class="ie6 ie6-7 ie6-8"> <![endif]-->
<!--[if IE 7]>         <html class="ie7 ie6-7 ie7-8 ie6-8"> <![endif]-->
<!--[if IE 8]>         <html class="ie8 ie7-8 ie6-8"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" manifest="application.appcache"> <!--<![endif]-->

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

    <title>Pro HTML5 Programming: Chapter 11 | Using the Web Storage API</title>

    <meta name="description" content="">
    <meta name="author" content="">

    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="cleartype" content="on">
    
    <meta name="apple-mobile-web-app-title" content="Pro HTML5">

    <!-- Tile icon for Win8 (144x144 + tile color) -->
    <meta name="msapplication-TileImage" content="apple-touch-icon-144x144.png">
    <meta name="msapplication-TileColor" content="#da2f1e">

    <link rel="shortcut icon" href="favicon.ico">    

    <!-- CSS -->
    <link rel="stylesheet" href="../assets/libraries/codemirror/lib/codemirror.css">
    <link rel="stylesheet" href="../assets/libraries/codemirror/theme/ambiance.css">
    <link rel="stylesheet" href="../assets/libraries/codemirror/theme/static.css">
  	<link rel="stylesheet" href="../assets/stylesheets/style.css" />

    <!-- JavaScript -->
    <!--[if (lt IE 9) & (!IEMobile)]>
    <script src="js/selectivizr-min.js"></script>
    <![endif]-->

    <!-- THIRD-PARTY JS: JPANELMENU + BOOTSTRAP (NAV), CODEMIRROR (CODE EDITOR) //-->
    <script src="../assets/js/jquery-1.8.0.min.js"></script>
    <script src="../assets/js/modernizr-latest.js"></script>
    <script src="../assets/js/jpanelmenu-1.0.0.js"></script>
    <script src="../assets/js/jquery.popbox.js"></script>
    <script src="../assets/libraries/codemirror/lib/codemirror.js"></script>
    <script src="../assets/libraries/codemirror/mode/xml/xml.js"></script>
    <script src="../assets/libraries/codemirror/mode/javascript/javascript.js"></script>
    <script src="../assets/libraries/codemirror/mode/css/css.js"></script>
    <script src="../assets/libraries/codemirror/mode/htmlmixed/htmlmixed.js"></script>
    <!-- APP JS //-->
    <script type="text/javascript" charset="utf-8">
      "use strict";
      var APRI = { // APRess Interactive
        ISBNOnline: '978-1-4302-3865-2'
      };
    </script>
    <script src="../assets/js/application.js"></script>
    <!-- ADD CHAPTER CODE LISTINGS JS FILE HERE //-->
    <script src="toc.js"></script>

  </head>

  <body>

    <header class="controls-bar">
      <h1 class="book-title">Pro HTML5 Programming</h1>
      
      <div class="menu-link orig-menu menu-trigger">
        <a class="svg-menu" href="#main-navigation">Chapter Contents</a>
      </div>
      
      <div class="font-size-controls">
        <a href="#" class="btn btn-fs fs-smaller">Smaller</a>
        <a href="#" class="btn btn-fs fs-larger">Larger</a>
      </div>
    
      <div class="btn-group toc-link popbox" id="toc">
        <a class="btn dropdown-toggle trigger" data-toggle="dropdown" href="#">
          Table of Contents
          <span class="caret"></span>
        </a>
      </div>
    
    </header>
  
<!--======================== CONTENT ========================-->

<article role="main">
<div id="wrapper">

  <hgroup>
    <a id="chapter_title" class="section-anchor"></a>
    <h1>Chapter 11</h1>
    <h1>Using the Web Storage API</h1>
  </hgroup>

  <p>In this chapter, we will explore what you can do with HTML5 Web Storage&#x2014;sometimes referred to as DOMStorage&#x2014;an API that makes it easy to retain data across web requests. Before the Web Storage API, remote web servers needed to store any data that persisted by sending it back and forth from client to server. With the advent of the Web Storage API, developers can now store data directly on the client side in the browser for repeated access across requests or to be retrieved long after you completely close the browser, thus reducing network traffic.</p>
  <p>We&#x2019;ll first look at how Web Storage differs from cookies and then explore how you can store and retrieve data. Next, we will look at the differences between <code>localStorage</code> and <code>sessionStorage</code>, the attributes and functions that the storage interface provides, and how you can handle Web Storage events. We wrap up with a look at Web SQL Database API and a few practical extras.</p>
  <section id="sec2_11">
<a id="hdr_sec2_11" class="section-anchor"></a>

  <h2>Overview of Web Storage</h2>
  <p>To explain the Web Storage API, it is best to review its predecessor, the intriguingly named cookie. Browser cookies&#x2014;named after an age-old programming technique for passing small data values between programs&#x2014;are a built-in way of sending text values back and forth from server to browser. Servers can use the values they put into these cookies to track user information across web pages. Cookie values are then transmitted back and forth every time a user visits a domain. For example, cookies can store a session identifier that allows a web server to know which shopping cart belongs to a user by storing a unique ID in a browser cookie that matches the server&#x2019;s own shopping cart database. Then, as a user moves from page to page, the shopping cart can be updated consistently. Another use for cookies is to store local values into an application so that these values can be used on subsequent page loads.</p>
  <p>Cookie values can also be used for operations that are slightly less desirable to users, such as tracking which pages a user visits for the sake of targeted advertising. As such, some users have demanded that browsers include functionality to allow them to block or remove cookies either all of the time or for specific sites.</p>
  <p>Love them or hate them, cookies have been supported by browsers since the earliest days of the Netscape browser, back in the mid-1990s. Cookies are also one of the few features that have been consistently supported across browser vendors since the early days of the Web. Cookies allow data to be tracked across multiple requests, as long as that data is carefully coordinated between the server and the browser code. Despite their ubiquity, cookies have some well-known drawbacks:</p>

  <ul>
  <li>Cookies are extremely limited in size. Generally, only about 4 KB of data can be set in a cookie, meaning they are unacceptable for large values such as documents or mail.</li>
  <li>Cookies are transmitted back and forth from server to browser on every request scoped to that cookie. Not only does this mean that cookie data is visible on the network, making them a security risk when not encrypted, but also that any data persisted as cookies will be consuming network bandwidth every time a URL is loaded. As such, the relatively small size of cookies makes more sense.</li>
  </ul>

  <p>In many cases, the same results could be achieved without involving a network or remote server. This is where the HTML5 Web Storage API comes in. By using this simple API, developers can store values in easily retrievable JavaScript objects that persist across page loads. By using either <code>sessionStorage</code> or <code>localStorage</code>, developers can choose to let those values survive either across page loads in a single window or tab or across browser restarts, respectively. Stored data is not transmitted across the network, and is easily accessed on return visits to a page. Furthermore, larger values can be persisted using the Web Storage API values as high as a few megabytes. This makes Web Storage suitable for document and file data that would quickly blow out the size limit of a cookie.</p>
  </section>
  <section id="sec3_11">
<a id="hdr_sec3_11" class="section-anchor"></a>

  <h2>Browser Support for Web Storage</h2>
  <p>Web Storage is one of the most widely adopted features of HTML5. In fact, since the arrival of Internet Explorer 8 in 2009 all currently shipping browser versions support Web Storage in some capacity. At the time of this publication, the market share of browsers that do not support storage is dwindling down into single digit percentages.</p>
  <p>Web Storage is one of the safest new APIs to use in your web applications today because of its widespread support. As usual, though, it is a good idea to first test if Web Storage is supported before you use it. The subsequent section &#x201C;Checking for Browser Support&#x201D; will show you how you can programmatically check if Web Storage is supported.</p>
  </section>
  <section id="sec4_11">
<a id="hdr_sec4_11" class="section-anchor"></a>

  <h2>Using the Web Storage API</h2>
  <p>The Web Storage API is surprisingly simple to use. We&#x2019;ll start by covering basic storage and retrieval of values and then move on to the differences between <code>sessionStorage</code> and <code>localStorage</code>. Finally, we&#x2019;ll look at the more advanced aspects of the API, such as event notification when values change.</p>
  <section id="sec5_11">
<a id="hdr_sec5_11" class="section-anchor"></a>

  <h3>Checking for Browser Support</h3>
  <p>The storage database for a given domain is accessed directly from the <code>window</code> object. Therefore, determining if a user&#x2019;s browser supports the Web Storage API is as easy as checking for the existence of <code>window.sessionStorage</code> or <code>window.localStorage</code>. Listing 11-1 shows a routine that checks for storage support and displays a message about the browser&#x2019;s support for the Web Storage API. Instead of using this code, you can also use the JavaScript utility library Modernizr, which handles some cases that may result in a false positive.</p>

<figure class="listing">
<figcaption>Listing 11-1. Checking for Web Storage Support</figcaption>
<pre><code data-cm-mode="javascript">function checkStorageSupport() {
  //sessionStorage
  if (window.sessionStorage) {
    alert('This browser supports sessionStorage');
  } else {
    alert('This browser does NOT support sessionStorage');
  }
  //localStorage
  if (window.localStorage) {
    alert('This browser supports localStorage');
  } else {
    alert('This browser does NOT support localStorage');
  }
}</code></pre>
</figure>

  <p>Figure 11-1 shows this check for storage support in action.</p>


  <figure class="image">
    <img src="images/ch11/fig11-1.png" />
    <figcaption>Figure 11-1. Checking for browser support</figcaption>
  </figure>

  <p>Some browsers do not support <code>sessionStorage</code> for files accessed directly from the file system. Make sure you serve up the pages from a web server when you run the examples in this chapter! For example, you can start Python&#x2019;s simple HTTP server in the <code>code/storage</code> directory as follows:</p>

  <p><code>python -m SimpleHTTPServer 9999</code></p>

  <p>After that, you can access the files at <code>http://localhost:9999/</code>. For example, <code>http://localhost:9999/browser-test.html</code>.</p>
  <p>However, you are free to use any server or URL location to run the examples.</p>

  <aside>
    <h3>Note</h3>
    <p>If a user is browsing with his browser set to &#x201C;private&#x201D; mode, then localStorage values will not actually persist once the browser is shut down. This is by design, as users of this mode have explicitly chosen to leave no traces behind. Nonetheless, your application should respond gracefully if storage values are not available in a later browsing session.</p>
  </aside>

  </section>
  <section id="sec6_11">
<a id="hdr_sec6_11" class="section-anchor"></a>

  <h3>Setting and Retrieving Values</h3>
  <p>To begin, we&#x2019;ll focus on the session storage capability as you learn to set and retrieve simple values in a page. Setting a value can easily be done in a single statement, which we&#x2019;ll initially write using the long-hand notation:</p>
  <p>sessionStorage.setItem(&#x2018;myFirstKey&#x2019;, &#x2018;myFirstValue&#x2019;);</p>
  <p>There are a few important points to notice from this storage access statement:</p>
  
  <ul>
  <li>We can omit the reference to the <code>window</code> for a shorthand notation, as the storage objects are made available in the default page context.</li>
  <li>The function we are calling is <code>setItem</code>, which takes a key string and a value string. Although some browsers might support passing in nonstring values, the specification only allows strings as values.</li>
  <li>This particular call will set into the session storage the string <code>myFirstValue</code>, which can later be retrieved by the key <code>myFirstKey</code>.</li>
  </ul>

  <p>To retrieve the value, the long-hand notation involves making a call to the <code>getItem</code> function. For example, if we augmented our previous example with the following statement</p>

  <p><code>alert(sessionStorage.getItem(&#x2018;myFirstKey&#x2019;));</code></p>

  <p>The browser raises a JavaScript alert displaying the text <code>myFirstValue</code>. As you can see, setting and retrieving values from the Web Storage API is very straightforward.</p>
  <p>However, there is an even simpler way to access the storage objects in your code. You are also able to use expando-properties to set values in storage. Using this approach, the <code>setItem</code> and <code>getItem</code> calls can be avoided entirely by simply setting and retrieving values corresponding to the key-value pair directly on the <code>sessionStorage</code> object. Using this approach, our value set call can be rewritten as follows:</p>

  <p><code>sessionStorage.myFirstKey = &#x2018;myFirstValue&#x2019;;</code></p>
  <p>Or even</p>
  <p><code>sessionStorage[&#x2018;myFirstKey&#x2019;] = &#x2018;myFirstValue&#x2019;;</code></p>
  <p>Similarly, the value retrieval call can be rewritten as:</p>
  <p><code>alert(sessionStorage.myFirstKey);</code></p>

  <p>We&#x2019;ll use these formats interchangeably in the chapter for the sake of readability.</p>
  <p>That&#x2019;s it for the basics. You now have all the knowledge you need to use session storage in your application. However, you might be wondering what&#x2019;s so special about this <code>sessionStorage</code> object. After all, JavaScript allows you to set and get properties on nearly any object. The difference is in the scope. What you may not have realized is that our example set and get calls do not need to occur in the same web page. As long as pages are served from the same origin&#x2014;the combination of scheme, host, and port&#x2014;then values set on <code>sessionStorage</code> can be retrieved from other pages using the same keys. This also applies to subsequent loads of the same page. As a developer, you are probably used to the idea that changes made in script will disappear whenever a page is reloaded. That is no longer true for values that are set in the Web Storage API; they will continue to exist across page loads.</p>
  </section>
  <section id="sec7_11">
<a id="hdr_sec7_11" class="section-anchor"></a>

  <h3>Plugging Data Leaks</h3>
  <p>How long do the values persist? For objects set into <code>sessionStorage</code>, they will persist as long as the browser window (or tab) is not closed. As soon as a user closes the window&#x2014;or browser, for that matter&#x2014;the <code>sessionStorage</code> values are cleared out. It is useful to consider a <code>sessionStorage</code> value to be somewhat like a sticky note reminder. Values put into <code>sessionStorage</code> won&#x2019;t last long, and you should not put anything truly valuable into them, as the values are not guaranteed to be around whenever you are looking for them.</p>
  <p>Why, then, would you choose to use the session storage area in your web application? Session storage is perfect for short-lived processes that would normally be represented in wizards or dialogs. If you have data to store over the course of a few pages, that you would not be keen to have resurface the next time a user visits your application, feel free to store them in the session storage area. In the past, these types of values might be submitted by forms and cookies and transmitted back and forth on every page load. Using storage eliminates that overhead.</p>
  <p>The <code>sessionStorage</code> API has another very specific use that solves a problem that has plagued many web-applications:scoping of values. Take, for example, a shopping application that lets you purchase airline tickets. In such an application, preference data such as the ideal departure date and return date could be sent back and forth from browser to server using cookies. This allows the server to remember previous choices as the user moves through the application, picking seats and a choice of meals.</p>
  <p>However, it is very common for users to open multiple windows as they shop for travel deals, comparing flights from different vendors for the same departure time. This causes problems in a cookie system, because if a user switches back and forth between browser windows while comparing prices and availability, they are likely to set cookie values in one window that will be unexpectedly applied to another window served from the same URL on its next operation. This is sometimes referred to as leaking data and is caused by the fact that cookies are shared based on the origin where they are stored. Figure 11-2 shows how this can play out.</p>

  <figure class="image">
    <img src="images/ch11/fig11-2.png" />
    <figcaption>Figure 11-2. Data leakage while using a travel site to compare prices</figcaption>
  </figure>

  <p>Using <code>sessionStorage</code>, on the other hand, allows temporary values like a departure date to be saved across pages that access the application but not leak into other windows where the user is also browsing for flights. Therefore, those preferences will be isolated to each window where the corresponding flights are booked.</p>
  </section>
  <section id="sec8_11">
<a id="hdr_sec8_11" class="section-anchor"></a>

  <h3>Local Versus Session Storage</h3>
  <p>Sometimes, an application needs values that persist beyond the life of a single tab or window or need to be shared across multiple views. In these cases, it is more appropriate to use a different Web Storage implementation: <code>localStorage</code>. The good news is that you already know how to use <code>localStorage</code>. The only programmatic difference between <code>sessionStorage</code> and <code>localStorage</code> is the name by which each is accessed&#x2014;through the <code>sessionStorage</code> and <code>localStorage</code> objects, respectively. The primary behavioral differences are how long the values persist and how they are shared. Table 11-1 shows the differences between the two types of storage.</p>
  
  
  <figure>
    <figcaption>Table 11-1. Differences Between sessionStorage and localStorage</figcaption>
    <table>
      <thead>
        <tr>
          <th>sessionStorage</th>
          <th>localStorage</th>
        </tr>
      </thead>
      <tr>
        <td data-label="sessionStorage">Values persist only as long as the window or tab in which they were stored.</td>
        <td data-label="localStorage">Values persist beyond window and browser lifetimes.</td>
      </tr>
      <tr>
        <td data-label="sessionStorage">Values are only visible within the window or tab that created them.</td>
        <td data-label="localStorage">Values are shared across every window or tab running at the same origin.</td>
      </tr>
    </table>
  </figure>

  <p>Keep in mind that browsers sometimes redefine the lifespan of a tab or window. For example, some browsers will save and restore the current session when a browser crashes, or when a user shuts down the display with many open tabs. In these cases, the browser may choose to keep the <code>sessionStorage</code> around when the browser restarts or resumes. So, in effect, <code>sessionStorage</code> may live longer than you think!</p>
  </section>
  <section id="sec9_11">
<a id="hdr_sec9_11" class="section-anchor"></a>

  <h3>Other Web Storage API Attributes and Functions</h3>
  <p>The Web Storage API is one of the simplest in the HTML5 set. We have already looked at both explicit and implicit ways to set and retrieve data from the session and local storage areas. Let&#x2019;s complete our survey of the API by looking at the full set of available attributes and function calls.</p>
  <p>The <code>sessionStorage</code> and <code>localStorage</code> objects can be retrieved from the <code>window</code> object of the document in which they are being used. Other than their names and the duration of their values, they are identical in functionality. Both implement the <code>Storage</code> interface, which is shown in Listing 11-2.</p>


<figure class="listing">
<figcaption>Listing 11-2. The Storage Interface</figcaption>
<pre><code data-cm-mode="javascript">interface Storage {
  readonly attribute unsigned long length;
  getter DOMString key(in unsigned long index);
  getter any getItem(in DOMString key);
  setter creator void setItem(in DOMString key, in any data);
  deleter void removeItem(in DOMString key);
  void clear();
};</code></pre>
</figure>

  <p>Let&#x2019;s look at the attributes and functions here in more detail.</p>
  
  <ul>
  <li>The <code>length</code> attribute specifies how many key-value pairs are currently stored in the storage object. Remember that storage objects are specific to their origin, so that implies that the items (and length) of the storage object only reflect the items stored for the current origin.</li>
  <li>The <code>key(index)</code> function allows retrieval of a given key. Generally, this is most useful when you wish to iterate across all the keys in a particular storage object. Keys are zero-based, meaning that the first key is at index (0) and the last key is at index (length &#x2013; 1). Once a key is retrieved, it can be used to fetch its corresponding value. Keys will retain their indices over the life of a given storage object unless a key or one of its predecessors is removed.</li>
  <li>As you&#x2019;ve already seen, <code>getItem(key)</code> function is one way to retrieve the value based on a given key. The other is to reference the key as an array index to the storage object. In both cases, the value <code>null</code> will be returned if the key does not exist in storage.</li>
  <li>Similarly, <code>setItem(key, value)</code> function will put a value into storage under the specified key name, or replace an existing value if one already exists under that key name. Note that it is possible to receive an error when setting an item value; if the user has storage turned off for that site, or if the storage is already filled to its maximum amount, a <code>QUOTA_EXCEEDED_ERR</code> error will be thrown during the attempt. Make sure to handle such an error should your application depend on proper storage behavior.</li>
  <li>The <code>removeItem(key)</code> function does exactly as you might expect. If a value is currently in storage under the specified key, this call will remove it. If no item was stored under that key, no action is taken.</li>
  </ul>  



  <aside>
    <h3>Note</h3>
    <p>Unlike some collection and data frameworks, removing an item does not return the old value as a result of the call to remove it. Make sure you&#x2019;ve stored any copy you need independent of the removal.</p>
  </aside>

  <ul>
    <li>Finally, the <code>clear()</code> function removes all values from the storage list. It is safe to call this on an empty storage object; as such, a call will simply do nothing.</li>
  </ul>

  <aside>
    <h3>Disk Space Quota</h3>
    <p><strong>Peter says:</strong> &#x201C;The specification recommends that browsers allow five megabytes per origin. Browsers should prompt the user when the quota is reached in order to grant more space and may also provide ways for users to see how much space each origin is using.</p>
    <p>In reality, the behavior is still a bit inconsistent. Some browsers silently allow a larger quota or prompt for a space increase, while others simply throw the <code>QUOTA_EXCEEDED_ERR</code> error shown in Figure 11-3, while others, like Opera, shown in Figure 11-4, implement a nice way to allocate more quota on the fly. The test file <code>testQuota.html</code> used in this example is located in the <code>code/storage</code> directory.&#x201D;</p>
  </aside>

  <figure class="image">
    <img src="images/ch11/fig11-3.png" />
    <figcaption>Figure 11-3. Quota Exceeded Error in Chrome</figcaption>
  </figure>

  <figure class="image">
    <img src="images/ch11/fig11-4.png" />
    <figcaption>Figure 11-4. On-the-fly Quota increase in Opera</figcaption>
  </figure>

  </section>
  <section id="sec10_11">
<a id="hdr_sec10_11" class="section-anchor"></a>

  <h3>Communicating Web Storage Updates</h3>
  <p>Sometimes, things get a little more complicated, and storage needs to be accessed by more than one page, browser tab, or worker. Perhaps your application needs to trigger many operations in succession whenever a storage value is changed. For just these cases, the Web Storage API includes an event mechanism to allow notifications of data updates to be communicated to interested listeners. Web Storage events are fired on the window object for every window of the same origin as the storage operation, regardless of whether or not the listening window is doing any storage operations itself.</p>

  <aside>
    <h3>Note</h3>
    <p>Web Storage events can be used to communicate between windows on the same origin. This will be explored a bit more thoroughly in the &#x201C;Practical Extras&#x201D; section.</p>
  </aside>


  <p>To register to receive the storage events of a window&#x2019;s origin, simply register an event listener, for example:</p>
  <p><code>window.addEventListener("storage", displayStorageEvent, true);</code></p>
  <p>As you can see, the name <code>storage</code> is used to indicate interest in storage events. Any time a <code>Storage</code> event&#x2014;either <code>sessionStorage</code> or <code>localStorage</code> &#x2014;for that origin is raised any registered event listener will receive the storage event as the specified event handler. The storage event itself takes the form shown in Listing 11-3.</p>

<figure class="listing">
<figcaption>Listing 11-3. The StorageEvent Interface</figcaption>
<pre><code data-cm-mode="javascript">interface StorageEvent : Event {
  readonly attribute DOMString key;
  readonly attribute any oldValue;
  readonly attribute any newValue;
  readonly attribute DOMString url;
  readonly attribute Storage storageArea;
};</code></pre>
</figure>


  <p>The <code>StorageEvent</code> object will be the first object passed to the event handler, and it contains all the information necessary to understand the nature of the storage change.</p>
  
  
  <ul>
    <li>The <code>key</code> attribute contains the key value that was updated or removed in the storage.</li>
    <li>The <code>oldValue</code> contains the previous value corresponding to the key before it was updated, and the <code>newValue</code> contains the value after the change. If the value was newly added, the <code>oldValue</code> will be null, and if the value has been removed, the <code>newValue</code> will be null.</li>
    <li>The <code>url</code> will point to the origin where the <code>storage</code> event occurred.</li>
    <li>Finally, the <code>storageArea</code> provides a convenient reference to the <code>sessionStorage</code> or <code>localStorage</code> where the value was changed. This gives the handler an easy way to query the storage for current values or make changes based on other storage changes.</li>
  </ul>

  <p>Listing 11-4 shows a simple event handler, which will raise an alert dialog with the contents of any storage event fired on the page&#x2019;s origin.</p>

<figure class="listing">
<figcaption>Listing 11-4. Event Handler that Displays Content of a Storage Event</figcaption>
<pre><code data-cm-mode="javascript">// display the contents of a storage event
function displayStorageEvent(e) {
  var logged = "key:" + e.key + ", newValue:" + e.newValue + ", oldValue:" + e.oldValue + ", url:" + e.url + ", storageArea:" + e.storageArea;
  alert(logged);
}
// add a storage event listener for this origin
window.addEventListener("storage", displayStorageEvent, true);</code></pre>
</figure>


  </section>
  <section id="sec11_11">
<a id="hdr_sec11_11" class="section-anchor"></a>

  <h3>Exploring Web Storage</h3>
  <p>Since Web Storage is very similar in function to cookies, it is not too surprising that the most advanced browsers are treating them in a very similar manner. Values that are stored into <code>localStorage</code> or <code>sessionStorage</code> can be browsed similar to cookies in the latest browsers, as shown in Figure 11-5.</p>
  
  
  <figure class="image">
    <img src="images/ch11/fig11-5.png" />
    <figcaption>Figure 11-5. Storage values in Google Chrome&#x2019;s Storage Panel</figcaption>
  </figure>



  <p>This interface also grants users the ability to remove storage values as desired and easily see what values a given web site is recording while they visit the pages. Not surprisingly, the Safari browser from Apple has a similar, unified display for cookies and storage, as it is based on the same underlying WebKit rendering engine as Chrome is. Figure 11-6 shows the Safari Storage panel.</p>

  <figure class="image">
    <img src="images/ch11/fig11-6.png" />
    <figcaption>Figure 11-6. Storage values in Safari&#x2019;s Storage panel</figcaption>
  </figure>


  <p>Like the other browsers, the Opera Dragonfly storage display allows users to not only browse and delete storage values but also create them as shown in Figure 11-7.</p>

  <figure class="image">
    <img src="images/ch11/fig11-7.png" />
    <figcaption>Figure 11-7. Storage values in Opera&#x2019;s Storage panel</figcaption>
  </figure>

  <p>As Web Storage becomes more widely implemented by the various browser vendors, expect both the capacity and tooling available to users and developers to expand rapidly.</p>
  </section>
  </section>
  <section id="sec12_11">
<a id="hdr_sec12_11" class="section-anchor"></a>

  <h2>Building an Application with Web Storage</h2>
  <p>Now, let&#x2019;s put together what you&#x2019;ve learned by integrating storage into a web application. As applications grow more complex, it becomes increasingly important to manage as much data as possible without server interaction. Keeping data local to the client reduces network traffic and increases responsiveness by fetching data from a local machine instead of a remote location.</p>
  <p>One common problem developers grapple with is how to manage data as users move from page to page within an application. Traditionally, web applications achieve this by storing data on a server and moving it back and forth while the user navigates pages. Alternatively, the application may attempt to keep the user in a single page and update everything dynamically. However, users are prone to wander, and getting data back into the display quickly when a user returns to your application&#x2019;s page is a great way to enhance the user experience.</p>
  <p>In our sample application, we&#x2019;ll show how to store temporary application data locally while the user moves from page to page on a web site and quickly load it from storage on each page. To accomplish this, we&#x2019;ll build on the examples of previous chapters. In Chapter 5, we showed how easy it is to gather a user&#x2019;s current location. Then, in Chapter 7, we demonstrated how to take location data and send it to a remote server so that it can be viewed by any number of interested users. Here, we will go one step further: we will listen for broadcasted location data delivered via a WebSocket and store it in local storage so that it is immediately available as users move from page to page.</p>
  <p>Imagine that our running club has live location information from its race participants being broadcast from their mobile devices and shared via a WebSocket server. It would be simple for a web application to display the current position of every racer live and in real time, as the racers upload new position information during the race. And a smart web site would cache those race positions to display them quickly as a user navigated among the pages of the site. That&#x2019;s exactly what we&#x2019;re going to build.</p>
  <p>In order to achieve this, we&#x2019;ll need to introduce a demonstration web site that can save and restore our racer data. We&#x2019;ve created a three-page example running race site and placed it in our online resources in the folder <code>code/storage</code>, but you can use any site of your choosing for your own demonstration. The key here is merely that you have multiple web pages that are easily traversed by a user. We will insert a bit of dynamic content into those pages to represent a live leader board, or a list of race participants and their current distance from the finish line. Figure 11-8 shows the three pages that make up the race site.</p>

  <figure class="image">
    <img src="images/ch11/fig11-8.gif" />
    <figcaption>Figure 11-8. The example race website</figcaption>
  </figure>

  <p>Each of our web pages will contain a common section to display the leader board data. Each entry in the leader board will show the name of one of our racers and his or her current distance from the finish line. When any of our pages is loaded, it will make a WebSocket connection to a race broadcast server and listen for messages indicating the position of a racer. The racers, in turn, will be sending their current position to the same broadcast server, causing the position data to stream down to the page in real time.</p>
  <p>All of this has been covered in previous chapters related to Geolocation and WebSockets. In fact, much of the demonstration code here is shared with the examples from earlier in this book. However, there is one key difference in this example: when the data arrives in the page, we will store it in the session storage area for later retrieval. Then, whenever a user navigates to a new page, the stored data will be retrieved and displayed before making a new WebSocket connection. In this way, the temporary data is transferred from page to page without using any cookies or web server communication.</p>
  <p>To keep our data feed small, we&#x2019;ll send our racer location messages across the web in a simple format that is easy to read and parse. This format is a <code>String</code> that uses the semicolon character (<code>;</code>) as a delimiter separating the chunks of data: name, latitude, and longitude. For example, a racer named Racer X who is at latitude 37.20 and longitude &#x2013;121.53 would be identified with the following string:</p>
  <p>;Racer X;37.20;-121.53</p>

  <aside>
    <h3>Note</h3>
    <p>A common technique is to use the JSON format to send object representations between client and server. We&#x2019;ll show you how to do that in the section &#x201C;Practical Extras&#x201D; later in this chapter.</p>
  </aside>

  <p>Now, let&#x2019;s dig into the code itself. Each of our pages will contain identical JavaScript code to connect to the WebSocket server, process and display leader board messages, and save and restore the leader board using <code>sessionStorage</code>. As such, this code would be a prime candidate to include in a JavaScript library in a real application.</p>
  <p>First, we&#x2019;ll establish a few utility methods that you&#x2019;ve seen before. To calculate the distance of any particular racer from the finish line, we need routines to calculate distance between two geolocation positions as shown in Listing 11-5.</p>

<figure class="listing">
<figcaption>Listing 11-5. Distance Calculation Routine</figcaption>
<pre><code data-cm-mode="javascript">// functions for determining the distance between two
// latitude and longitude positions
function toRadians(num) {
  return num * Math.PI / 180;
}
function distance(latitude1, longitude1, latitude2, longitude2) {
  // R is the radius of the earth in kilometers
  var R = 6371;
  var deltaLatitude = toRadians((latitude2-latitude1));
  var deltaLongitude = toRadians((longitude2-longitude1));
  latitude1 = toRadians(latitude1), latitude2 = toRadians(latitude2);
  var a = Math.sin(deltaLatitude/2) *
          Math.sin(deltaLatitude/2) +
          Math.cos(latitude1) *
          Math.cos(latitude2) *
          Math.sin(deltaLongitude/2) *
          Math.sin(deltaLongitude/2);
  var c = 2 * Math.atan2(Math.sqrt(a),
                         Math.sqrt(1-a));
  var d = R * c;
  return d;
}
// latitude and longitude for the finish line in the Lake Tahoe race
var finishLat = 39.17222;
var finishLong = -120.13778;</code></pre>
</figure>

  <p>In this familiar set of functions&#x2014;used earlier in Chapter 5&#x2014;we calculate the distance between two points with a <code>distance</code> function. The details are not of particular importance, nor are they the most accurate representation of distance along a racetrack, but they&#x2019;ll do for our example.</p>
  <p>In the final lines, we establish a latitude and longitude for the finish line location of the race. As you&#x2019;ll see, we will compare these coordinates with incoming racer positions to determine the racers&#x2019; distance from the finish line, and thus, their ranks in the race.</p>
  <p>Now, let&#x2019;s look at a tiny snippet of the HTML markup used to display the page.</p>
  <p><code>&#x003C;h2&#x003E; Live T216 Leaderboard&#x003C;/h2&#x003E;</code></p>
  <p><code>&#x003C;p id="leaderboardStatus"&#x003E; Leaderboard: Connecting&#x2026;&#x003C;/p&#x003E;</code></p>
  <p><code>&#x003C;div id="leaderboard"&#x003E;&#x003C;/div&#x003E;</code></p>
  <p>Although most of the page HTML is irrelevant to our demonstration, in these few lines, we declare some named elements with the IDs <code>leaderboardStatus</code> and <code>leaderboard</code>. The <code>leaderboardStatus</code> is where we will display the connection information for our WebSocket. And the leaderboard itself is where we will insert <code>div</code> elements to indicate the position information we are receiving from our WebSocket messages, using the utility function shown in Listing 11-6.</p>

<figure class="listing">
<figcaption>Listing 11-6. Position Information Utility Function</figcaption>
<pre><code data-cm-mode="javascript">// display the name and distance in the page
function displayRacerLocation(name, distance) {
  // locate the HTML element for this ID
  // if one doesn't exist, create it
  var incomingRow = document.getElementById(name);
  if (!incomingRow) {
    incomingRow = document.createElement('div');
    incomingRow.setAttribute('id', name);
    incomingRow.userText = name;
    document.getElementById("leaderboard").appendChild(incomingRow);
  }
  incomingRow.innerHTML = incomingRow.userText + " is " + Math.round(distance*10000)/10000 + " km from the finish line";
}</code></pre>
</figure>



  <p>This utility is a simple display routine, which takes the racer&#x2019;s name and distance from the finish line. Figure 11-9 shows what the leader board section looks like on the <code>index.html</code> page.</p>

  <figure class="image">
    <img src="images/ch11/fig11-9.gif" />
    <figcaption>Figure 11-9. The race leader board</figcaption>
  </figure>

  <p>The name is used for two purposes; not only is it placed into the status message for that racer but it is also used to reference the unique <code>div</code> element where that racer&#x2019;s status is stored. If a <code>div</code> for our racer already exists, we will find it when we look it up using the standard <code>document.getElementById()</code> routine. If a <code>div</code> does not already exist in the page for that racer, we will create one and insert it into the <code>leaderboard</code> area. Either way, we update the <code>div</code> element corresponding to that racer with the latest distance from the finish line, which will immediately update it in the display of the page. If you have already read Chapter 7, this will be familiar to you from the example application we created there.</p>
  <p>Our next function is the message processor that will be called whenever data is returned from the broadcasting race WebSocket server, as shown in Listing 11-7.</p>

<figure class="listing">
<figcaption>Listing 11-7. WebSocket Message Processing Function</figcaption>
<pre><code data-cm-mode="javascript">// callback when new position data is retrieved from the websocket
function dataReturned(locationData) {
  // break the data into ID, latitude, and longitude
  var allData = locationData.split(";");
  var incomingId  = allData[1];
  var incomingLat = allData[2];
  var incomingLong = allData[3];
  // update the row text with the new values
  var currentDistance = distance(incomingLat, incomingLong, finishLat, finishLong);
  // store the incoming user name and distance in storage
  window.sessionStorage[incomingId] = currentDistance;
  // display the new user data in the page
  displayRacerLocation(incomingId, currentDistance);
}</code></pre>
</figure>

  <p>This function takes a string in the format described previously, a semicolon-separated message containing the name, latitude, and longitude of a racer. Our first step is to split it into its component parts using the JavaScript <code>split()</code> routine to produce the <code>incomingId</code>, <code>incomingLat</code>, and <code>incomingLong</code>, respectively.</p>
  <p>Next, it passes the racer&#x2019;s latitude and longitude, as well as the latitude and longitude of the finish line, to the <code>distance</code> utility method we defined earlier, storing the resulting distance in the <code>currentDistance</code> variable.</p>
  <p>Now that we actually have some data worth storing, we can look at the call which exercises Web Storage.</p>
  <p><code>// store the incoming user name and distance in storage</code></p>
  <p><code>window.sessionStorage[incomingId] = currentDistance;</code></p>
  <p>In this line, we use the <code>sessionStorage</code> object on the window to store the current distance of the racer from the finish line as a value under the name and ID of the racer. In other words, we will set a value on the session storage with the key being the racer&#x2019;s name and the value being that racer&#x2019;s distance from the finish. As you will see momentarily, this data will be retrieved from storage as the user navigates from page to page on the web site. At the end of the function, we call the <code>displayLocation()</code> routine we previously defined to make sure that this most recent location update is displayed visually in the current page.</p>
  <p>Now, on to our final function in our storage example&#x2014;the load routine shown in Listing 11-8 that fires whenever visitors access the web page.</p>

<figure class="listing">
<figcaption>Listing 11-8. Initial Page Load Routine</figcaption>
<pre><code data-cm-mode="javascript">// when the page loads, make a socket connection to the race broadcast server
function loadDemo() {
  // make sure the browser supports sessionStorage
  if (typeof(window.sessionStorage) === "undefined") {
    document.getElementById("leaderboardStatus").innerHTML = "Your browser does&#x21B5; not support HTML5 Web Storage";
    return;
  }
  var storage = window.sessionStorage;
  // for each key in the storage database, display a new racer
  // location in the page
  for (var i=0; i &#x003C; storage.length; i++) {
    var currRacer = storage.key(i);
    displayRacerLocation(currRacer, storage[currRacer]);
  }
  // test to make sure that Web Sockets are supported
  if (window.WebSocket) {
    // the location where our broadcast WebSocket server is located
    url = "ws://websockets.org:7999/broadcast";
    socket = new WebSocket(url);
    socket.onopen = function() {
      document.getElementById("leaderboardStatus").innerHTML = "Leaderboard: Connected!";
    }
    socket.onmessage = function(e) {
      dataReturned(e.data);
    }
  }
}</code></pre>
</figure>


  <p>This is a longer function than the others, and there is a lot going on. Let&#x2019;s take it step by step. First, as shown in Listing 11-9, we do a basic error check to make sure that the browser viewing the page supports <code>sessionStorage</code> by checking for its presence on the window object. If <code>sessionStorage</code> is not accessible, we simply update the <code>leaderboardStatus</code> area to indicate as much, and then return out of the loading routine. We won&#x2019;t be attempting to work around lack of browser storage in this example.</p>

<figure class="listing">
<figcaption>Listing 11-9. Checking for Browser Support</figcaption>
<pre><code data-cm-mode="javascript">// make sure the browser supports sessionStorage
if (typeof(window.sessionStorage) === "undefined") {
  document.getElementById("leaderboardStatus").innerHTML = "Your browser does not support HTML5 Web Storage";
  return;
}</code></pre>
</figure>



  <aside>
    <h3>Note</h3>
    <p>It is possible to rework this demonstration to simply forgo any persistence of data between page navigations and start each page load with a clean leader board if storage is not supported. However, our goal here is to show how storage optimizes the experience for both the user and the network.</p>
  </aside>

  <p>The next thing we do on page load is to use the storage to retrieve any racer distance results that have already been served to this or other pages of our website. Recall that we are running an identical block of script code on every one of our site pages, so that the leader board follows the users as they browse around various locations. As such, the leader board may already have stored values into storage from other pages that will be retrieved and displayed here directly on load as shown in Listing 11-10. The previously saved values will follow the user during navigation, as long as the user does not close the window, tab, or browser, thus clearing out the session storage.</p>

<figure class="listing">
<figcaption>Listing 11-10. Displaying Stored Racer Data</figcaption>
<pre><code data-cm-mode="javascript">var storage = window.sessionStorage;
// for each key in the storage database, display a new racer
// location in the page
for (var i=0; i &#x003C; storage.length; i++) {
  var currRacer = storage.key(i);
  displayRacerLocation(currRacer, storage[currRacer]);
}</code></pre>
</figure>

  <p>This is an important section of code. Here, we query the session for its length&#x2014;in other words, the number of keys the storage contains. Then, we grab each key using <code>storage.key()</code> and store it into the <code>currRacer</code> variable, later using that variable to reference the key&#x2019;s corresponding value with <code>storage[currRacer]</code>. Together, the key and its value represent a racer and that racer&#x2019;s distance, which were stored on a visit to a previous page.</p>
  <p>Once we have a previously stored racer name and distance, we display them using the <code>displayRacerLocation()</code> function. This all happens very quickly on page load, causing the page to instantaneously fill its leader board with previously transmitted values.</p>

  <aside>
    <h3>Note</h3>
    <p>Our sample application relies on being the only application that stores values into the session storage area. If your application needs to share the storage object with other data, you will need to use a more nuanced key strategy than simply storing the keys at root level. We&#x2019;ll look at another storage strategy in the &#x201C;Practical Extras&#x201D; section.</p>
  </aside>

  <p>Our last piece of load behavior is to hook up the page to the racer broadcast server using a simple WebSocket, as shown in Listing 11-11.</p>

<figure class="listing">
<figcaption>Listing 11-11. Connecting to the WebSocket Broadcast Service</figcaption>
<pre><code data-cm-mode="javascript">// test to make sure that WebSocket is supported
if (window.WebSocket) {
  // the location where our broadcast WebSocket server is located
  // for the sake of example, we&#x2019;ll just show websockets.org
  url = "ws://websockets.org:7999/broadcast";
  socket = new WebSocket(url);
  socket.onopen = function() {
    document.getElementById("leaderboardStatus").innerHTML = "Leaderboard: &#x21B5; Connected!";
  }
  socket.onmessage = function(e) {
    dataReturned(e.data);
  }
}</code></pre>
</figure>


  <p>As we did before in our WebSocket chapter, we first check to make sure that the browser supports WebSocket by checking for the existence of the <code>window.WebSocket</code> object. Once we have verified that it exists, we connect to the URL where our WebSocket server is running. This server broadcasts racer location messages of the semicolon-separated format listed previously, and whenever we receive one of those messages via the <code>socket.onmessage</code> callback, we call our previously discussed <code>dataReturned()</code> function to process and display it. We also use the <code>socket.onopen</code> callback to update our <code>leaderboardStatus</code> area with a simple diagnostic message to indicate that the socket opened successfully.</p>
  <p>That&#x2019;s it for our <code>load</code> routine. The final block of code we declare in our script block is the registration function, which requests that the <code>loadDemo()</code> function is called whenever page load is complete:</p>
  <p><code>// add listeners on page load and unload</code></p>
  <p><code>window.addEventListener("load", loadDemo, true);</code></p>
  <p>As you have seen many times before, this event listener requests that our <code>loadDemo()</code> function will be called when the window has completed loading.</p>
  <p>But how do we get racer data transmitted from the trails to the broadcast WebSocket server and into our pages? Well, we could actually use the tracker example previously declared in the WebSocket chapter by simply pointing its connect URL to the broadcast server listed previously. However, we have also created a very simple racer broadcast source page, shown in Listing 11-12, which serves a similar purpose. This page would theoretically be run on the mobile devices of the race participants. Although it does not include any Web Storage code itself, it is a convenient way to transmit the properly formatted data when run in a browser with both WebSocket and Geolocation support. The file <code>racerBroadcast.html</code> is available from the web site sample area provided for this book.</p>

  <figure class="listing">
  <figcaption>Listing 11-12. Contents of the File racerBroadcast.html</figcaption>
  <pre><code data-cm-mode="javascript">&#x003C;!DOCTYPE html&#x003E;
  &#x003C;html&#x003E;
  &#x003C;head&#x003E;
  &#x003C;title&#x003E; Racer Broadcast&#x003C;/title&#x003E;
  &#x003C;link rel="stylesheet" href="styles.css"&#x003E;
  &#x003C;/head&#x003E;
  &#x003C;body onload="loadDemo()"&#x003E;
  &#x003C;h1&#x003E; Racer Broadcast&#x003C;/h1&#x003E;
  Racer name: &#x003C;input type="text" id="racerName" value="Racer X"/&#x003E;
  &#x003C;button onclick="startSendingLocation()"&#x003E; Start&#x003C;/button&#x003E;
  &#x003C;div&#x003E; &#x003C;strong&#x003E; Geolocation&#x003C;/strong&#x003E;: &# id="geoStatus"&#x003E; HTML5 Geolocation not &#x21B5;</Para>
   started.&#x003C;/p&#x003E;&#x003C;/div&#x003E;
  &#x003C;div&#x003E; &#x003C;strong&#x003E; WebSocket&#x003C;/strong&#x003E;: &# id="socketStatus"&#x003E; HTML5 Web Sockets are &#x21B5;</Para>
   &#x003C;strong&#x003E; not&#x003C;/strong&#x003E; supported  browser.&#x003C;/p&#x003E;&#x003C;/div&#x003E;</Para>
  &#x003C;script type="text/javascript"&#x003E;
    // reference to the Web Socket
    var socket;
    var lastLocation;
    function updateSocketStatus(message) {
      document.getElementById("socketStatus").innerHTML = message;
    }
    function updateGeolocationStatus(message) {
      document.getElementById("geoStatus").innerHTML = message;
    }
    function handleLocationError(error) {
      switch(error.code)
      {
      case 0:
        updateGeolocationStatus("There was an error while retrieving your location: " + error.message);
        break;
      case 1:
        updateGeolocationStatus("The user prevented this page from retrieving a location.");
        break;
        
        updateGeolocationStatus("The browser was unable to determine your location: " + error.message);
        break;
      case 3:
        updateGeolocationStatus("The browser timed out before retrieving the location.");
        break;
      }
    }
    function loadDemo() {
      // test to make sure that Web Sockets are supported
      if (window.WebSocket) {
        // the location where our broadcast WebSocket server is located
        url = "ws://websockets.org:7999/broadcast";
        socket = new WebSocket(url);
        socket.onopen = function() {
            updateSocketStatus("Connected to WebSocket race broadcast server");
        }
      }
    }
    function updateLocation(position) {
      var latitude = position.coords.latitude;
      var longitude = position.coords.longitude;
      var timestamp = position.timestamp;
      updateGeolocationStatus("Location updated at " + timestamp);
      // Schedule a message to send my location via WebSocket
      var toSend = ";" + document.getElementById("racerName").value + ";" + latitude + ";" + longitude;
      setTimeout("sendMyLocation('" + toSend + "')",
    }
    function sendMyLocation(newLocation) {
      if (socket) {
        socket.send(newLocation);
        updateSocketStatus("Sent: " + newLocation);
      }
    }
    function startSendingLocation() {
      var geolocation;
      if(navigator.geolocation) {
        geolocation = navigator.geolocation;
        updateGeolocationStatus("HTML5 Geolocation is supported in your browser.");
      }
      else {
        geolocation = google.gears.factory.create('beta.geolocation');
        updateGeolocationStatus("Geolocation is supported via Google Gears");
      }
      // register for position updates using the Geolocation API
      geolocation.watchPosition(updateLocation,
                                handleLocationError,
                                {maximumAge:20000});
    }
  &#x003C;/script&#x003E;
  &#x003C;/body&#x003E;
  &#x003C;/html&#x003E;</code></pre>
  </figure>



  <p>We won&#x2019;t spend too much space covering this file in detail, as it is nearly identical to the tracker example in Chapter 7. The primary difference is that this file contains a text field for entering the racer&#x2019;s name:</p>
  <p>Racer name: &#x003C;input type="text" id="racerName" value="Racer X"/&#x003E;</p>
  <p>The racer&#x2019;s name is now sent to the broadcast server as part of the data string:</p>
  <p><code>var toSend =    ";" + document.getElementById("racerName").value</code></p>
  <p><code>           + ";" + latitude + ";" + longitude;</code></p>
  <p>To try it out for yourself, open two windows in a browser that supports Web Storage, Geolocation, and WebSocket, such as Google Chrome. In the first, load the running club&#x2019;s <code>index.html</code> page. You will see it connect to the race broadcast site using WebSocket and then await any racer data notifications. In the second window, open the <code>racerBroadcast.html</code> file. After this page, too, has connected to the WebSocket broadcast site, enter a name for your racer, and click the Start button. You&#x2019;ll see that the racer broadcast has transmitted the location of your favorite racer, and it should show up in the leader board in your other browser window. Figure 11-10 shows what this looks like.</p>

  <figure class="image">
    <img src="images/ch11/fig11-10.gif" />
    <figcaption>Figure 11-10. Race page and racerBroadcast.html side by side</figcaption>
  </figure>


  <p>Now, navigate to other racing club pages using the Signup and About the Race links on the left side of the page. Because all of these pages have been configured to load our script, they will immediately load and populate the leader board with the previous racer data, which was delivered while browsing other pages. Send more racer status notifications (from the broadcast page), and you&#x2019;ll see them propagate through the club site pages as you navigate, as well.</p>
  <p>Now that we&#x2019;ve finished our code, let&#x2019;s review what we&#x2019;ve built. We&#x2019;ve created a simple function block, suitable for inclusion in a shared JavaScript library, which connects to a WebSocket broadcast server and listens for racer updates. When an update is received, the script displays the position in the page <em>and</em> stores it using <code>sessionStorage</code>. When the page is loaded, it checks for any previously stored racer position values, thus maintaining the state as the user navigates the site. What are some of the benefits we gain from this approach?</p>
  
  <ul>
    <li><em>Reduced network traffic:</em> Race information is stored locally in the browser. Once it arrives, it sticks around for every page load, rather than using cookies or server requests to fetch it again.</li>
    <li><em>Immediate display of values:</em> The browser pages themselves can be cached rather than loaded from the network, because the dynamic parts of the page&#x2014;the current leaderboard status&#x2014;are local data. This data is rapidly displayed without any network load time.</li>
    <li><em>Transient storage</em>: The race data isn&#x2019;t very useful after the race has completed. Consequently, we store it in session storage area, meaning it is discarded when the window or tab is shut down, and it no longer consumes any space.</li>
  </ul>

  <aside>
    <h3>A Word About Bulletproofing</h3>
    <p><strong>Brian says:</strong> &#x201C;We&#x2019;ve accomplished a lot in this example using only a few lines of script code. But don&#x2019;t be lulled into thinking everything is this easy in a real, publicly accessible website. We took some shortcuts that simply are not acceptable for a production application.</p>
    <p>For example, our message format does not support similarly named racers and would best be replaced by a unique identifier representing each racer. Our distance calculation is &#x201C;as the crow flies&#x201D; and not truly indicative of progress in an off-road race. Standard disclaimers apply&#x2014;more localization, more error checking, and more attention to detail will make your site work for all participants.&#x201D;</p>
  </aside>

  <p>This same technique we demonstrated in this example can be applied to any number of data types: chat, e-mail, and sports scores are other examples that can be cached and displayed from page to page using local or session storage just as we&#x2019;ve shown here. If your application sends user-specific data back and forth from browser to server at regular intervals, consider using Web Storage to streamline your flow.</p>

  </section>
  <section id="sec13_11">
<a id="hdr_sec13_11" class="section-anchor"></a>

  <h2>The Future of Browser Database Storage</h2>
  <p>The key-value Storage API is great for persisting data, but what about indexed storage that can be queried? HTML5 applications will eventually have access to indexed databases as well. The exact details of the database APIs are still solidifying, and there are two primary proposals.</p>
  <section id="sec14_11">
<a id="hdr_sec14_11" class="section-anchor"></a>

  <h3>The Web SQL Database</h3>
  <p>One of the proposals, Web SQL Database, has been implemented in Safari, Chrome, and Opera. Table 11-2 shows the browser support for Web SQL Database.</p>
  
  <figure>
    <figcaption>Table 11-2. Browser Support for HTML5 Web SQL Database</figcaption>
    <table>
      <thead>
        <tr>
          <th>Browser</th>
          <th>Details</th>
        </tr>
      </thead>
      <tr>
        <td data-label="Browser">Chrome</td>
        <td data-label="Details">Supported in version 3.0 and greater</td>
      </tr>
      <tr>
        <td data-label="Browser">Firefox</td>
        <td data-label="Details">The image is repeated only in the X dimension</td>
      </tr>
      <tr>
        <td data-label="Browser">Internet Explorer</td>
        <td data-label="Details">Not supported</td>
      </tr>
      <tr>
        <td data-label="Browser">Opera</td>
        <td data-label="Details">Supported in version 10.5 and greater</td>
      </tr>
      <tr>
        <td data-label="Browser">Safari</td>
        <td data-label="Details">Supported in version 3.2 and greater</td>
      </tr>    
    </table>
  </figure>  


  <p>Web SQL Database allows applications access to SQLite through an asynchronous JavaScript interface. Although it will not be part of the common Web platform nor the eventual recommended database API for HTML5 applications, the SQL API can be useful when targeting a specific platform such as mobile Safari. In any case, this API shows off the power of databases in the browser. Just like the other storage APIs, the browser can limit the amount of storage available to each origin and clear out the data when user data is cleared.</p>

  <aside>
    <h3>The Fate of Web SQL Database</h3>
    <p><strong>Frank says:</strong> &#x201C;Even though Web SQL DB is already in Safari, Chrome, and Opera, it will not be implemented in Firefox and it is listed as &#x2018;stalled&#x2019; on the WHATWG wiki. The specification defines an API for executing SQL statements given as strings and defers to SQLite for the SQL dialect. Since it is undesirable for a standard to require a specific implementation of SQL, Web SQL Database has been surpassed by a newer specification, Indexed Database (formerly WebSimpleDB), which is simpler and not tied to a specific SQL database version. Browser implementations of Indexed Database are currently in progress, and we&#x2019;ll cover them in the next section.&#x201D;</p>
  </aside>

  <p>Because Web SQL Database is already implemented in the wild, we are including a basic example but omiting the complete details of the API. This example demonstrates the basic use of the Web SQL Database API. It opens a database called <code>mydb</code>, creates a <code>racers</code> table if a table by that name does not already exist, and populates the table with a list of predefined names. Figure 11-11 shows this database with racers table in Safari&#x2019;s Web Inspector.</p>

  <figure class="image">
    <img src="images/ch11/fig11-11.png" />
    <figcaption>Figure 11-11. Database with racers table in Safari&#x2019;s Web Inspector</figcaption>
  </figure>

  <p>To begin, we open a database by name. The <code>window.openDatabase()</code> function returns a <code>Database</code> object through which database interaction takes place. The <code>openDatabase()</code> function takes a name as well as an optional version and description. With an open database, application code can now start transactions. SQL statements are executed in the context of a transaction using the <code>transaction.executeSql()</code> function. This simple example uses <code>executeSql()</code> to create a table, insert racer names into the table, and later query the database to create an HTML table. Figure 11-12 shows the output HTML file with the list of names retrieved from the table.</p>

  <figure class="image">
    <img src="images/ch11/fig11-12.png" />
    <figcaption>Figure 11-12. sql.html displaying the results of SELECT * FROM racers</figcaption>
  </figure>

  <p>Database operations can take some time to complete. Instead of blocking script execution until a result set is available, queries run in the background. When the results are available, a function given as the third argument to <code>executeSQL()</code> is called back with the transaction and the result set as arguments.</p>
  <p>Listing 11-13 shows the complete code for the file <code>sql.html</code>; the sample code shown is also located in the <code>code/storage</code> folder.</p>

  <figure class="listing">
  <figcaption>Listing 11-13. Using the Web SQL Database API</figcaption>
  <pre><code data-cm-mode="text/html">&#x003C;!DOCTYPE html&#x003E;
  &#x003C;title&#x003E; Web SQL Database&#x003C;/title&#x003E;
  &#x003C;script&#x003E;
    // open a database by name
    var db = openDatabase('db', '1.0', 'my first database', 2 * 1024 * 1024);
    function log(id, name) {
      var row = document.createElement("tr");
      var idCell = document.createElement("td");
      var nameCell = document.createElement("td");
      idCell.textContent = id;
      nameCell.textContent = name;
      row.appendChild(idCell);
      row.appendChild(nameCell);
      document.getElementById("racers").appendChild(row);
    }
    function doQuery() {
      db.transaction(function (tx) {
        tx.executeSql('SELECT * from racers', [], function(tx, result) {
          // log SQL result set
          for (var i=0; i&#x003C;result.rows.length; i++) {
            var item = result.rows.item(i);
            log(item.id, item.name);
          }
        });
      });
    }
    function initDatabase() {
      var names = ["Peter Lubbers", "Brian Albers", "Frank Salim"];
      db.transaction(function (tx) {
        tx.executeSql('CREATE TABLE IF NOT EXISTS racers (id integer primary key &#x21B5;
autoincrement, name)');
        for (var i=0; i&#x003C;names.length; i++) {
          tx.executeSql('INSERT INTO racers (name) VALUES (?)', [names[i]]);
        }
        doQuery();
      });
    }
    initDatabase();
  &#x003C;/script&#x003E;
  &#x003C;h1&#x003E; Web SQL Database&#x003C;/h1&#x003E;
  &#x003C;table id="racers" border="1" cellspacing="0" style="width:100%"&#x003E;
    &#x003C;th&#x003E; Id&#x003C;/th&#x003E;
    &#x003C;th&#x003E; Name&#x003C;/th&#x003E;
  &#x003C;/table&#x003E;</code></pre>
  </figure>




  </section>
  <section id="sec15_11">
<a id="hdr_sec15_11" class="section-anchor"></a>

  <h3>The Indexed Database API</h3>
  <p>A second proposal for browser database storage gained prominence in 2010. The Indexed Database API is supported by Microsoft and Mozilla and is seen as a counter to the Web SQL Database. Where the Web SQL Database looks to bring the established SQL language into browsers, the Indexed Database aims to bring low-level indexed storage capabilities, with the hope that more developer-friendly libraries will be built on top of the indexed core.</p>
  <p>While the Web SQL API supports using query languages to issue SQL statements against tables of data, the Indexed DB API issues synchronous or asynchronous function calls directly against a tree-like object storage engine. Unlike Web SQL, the Indexed DB does not work with tables and columns.</p>
  <p>The support for the Indexed Database API is growing (see Table 11-3).</p>


  <figure>
    <figcaption>Table 11-3. Browser Support for the Indexed Database API</figcaption>
    <table>
      <thead>
        <tr>
          <th>Browser</th>
          <th>Details</th>
        </tr>
      </thead>
      <tr>
        <td data-label="Browser">Chrome</td>
        <td data-label="Details">Supported in current versions</td>
      </tr>
      <tr>
        <td data-label="Browser">Firefox</td>
        <td data-label="Details">Supported in current versions</td>
      </tr>
      <tr>
        <td data-label="Browser">Internet Explorer</td>
        <td data-label="Details">Supported in version 10+</td>
      </tr>
      <tr>
        <td data-label="Browser">Opera</td>
        <td data-label="Details">Not currently supported</td>
      </tr>
      <tr>
        <td data-label="Browser">Safari</td>
        <td data-label="Details">Not currently supported</td>
      </tr>    
    </table>
  </figure>  


  <p>Microsoft and Mozilla have announced that they will not support the Web SQL Database and have thrown their weight behind the Indexed Database instead. Google&#x2019;s Chrome has joined in with support, and as such, it is likely that the Indexed Database is the future of standardized structured storage in the browser. Among their reasons are the fact that SQL is not a true standard and also that the only implementation of Web SQL was the SQLite project. With only one implementation and a loose standard, they could not support WebSQL in the HTML5 specification.</p>
  <p>The Indexed Database API eschews query strings in favor of a low-level API that allows values to be stored directly in JavaScript objects. Values stored in the database can be retrieved by key or using indexes, and the API can be accessed in either synchronous or asynchronous manner. Like the WebSQL proposal, indexed databases are scoped by origin so that you can only access the storage created in your own web pages.</p>
  <p>Creation or modification of Indexed Database storage is done under the context of transactions, which can be classified as either READ_ONLY, READ_WRITE, or VERSION_CHANGE. While the first two may be self-explanatory, the VERSION_CHANGE transaction type is used whenever an operation will modify the structure of the database.</p>
  <p>Retrieving records from an Indexed Database is done via a cursor object. A cursor object iterates over a range of records in either increasing or decreasing order. At any time a cursor either has a value or does not, due to the fact that it is either in the process of loading or has reached the end of its iteration.</p>
  <p>A detailed description of the Indexed Database API is beyond the scope of this book. If you are intending to implement a query engine on top of the built-in API, you should consult the official specification at <a href="http://www.w3.org/TR/IndexedDB/" target="_blank">http://www.w3.org/TR/IndexedDB/</a>. Otherwise, you would be wise to wait for one of the proposed engines layered on top of the standard to be made available to use a more developer-friendly database API. At this point, no third-party libraries have gained prominence or significant backing.</p>

  <aside>
    <h3>Why Use a Hammer&#x2026;</h3>
    <p><strong>Brian says:</strong> &#x201C;&#x2026;when you can instead use these ingots, that forge, and the mold of your choosing? On the Mozilla blog, Arun Ranganathan argued that he would welcome APIs like the Web SQL API being built on top of the Indexed Database standard. This attitude has perplexed many developers, as there is a widespread belief that, in order to make the Indexed Database usable, it will require third-party JavaScript libraries built on top of the standard. The Indexed Database itself is simply too complex for most web developers to use it in its current form.</p>
    <p>This begs the question: if developers end up needing third-party libraries to take advantage of the built-in storage API, wouldn&#x2019;t it be prudent to simply build that storage in native code rather than as a JavaScript library that must be downloaded and interpreted at runtime? Time will tell if the Indexed Database suits the needs of the majority.&#x201D;</p>
  </aside>


  </section>
  </section>
  <section id="sec16_11">
<a id="hdr_sec16_11" class="section-anchor"></a>

  <h2>Practical Extras</h2>
  <p>Sometimes, there are techniques that don&#x2019;t fit into our regular examples but nonetheless apply to many types of HTML5 applications. We present to you some short, but common, practical extras here.</p>
  <section id="sec17_11">
<a id="hdr_sec17_11" class="section-anchor"></a>

  <h3>JSON Object Storage</h3>
  <p>Although the specification for Web Storage allows for objects of any type to be stored as key-value pairs, in current implementations, some browsers limit values to be text string data types. There is a practical workaround, however, due to the fact that modern versions of browsers contain built-in support for JavaScript Object Notation (JSON).</p>
  <p>JSON is a standard for data-interchange that can represent objects as strings and vice-versa. JSON has been used for over a decade to transmit objects from browser clients to servers over HTTP. Now, we can use it to serialize complex objects in and out of Web Storage in order to persist complex data types. Consider the script block in Listing 11-14.</p>


<figure class="listing">
<figcaption>Listing 11-14. JSON Object Storage</figcaption>
<pre><code data-cm-mode="javascript">&#x003C;script&#x003E;
  var data;
  function loadData() {
    data = JSON.parse(sessionStorage["myStorageKey"])
  }
  function saveData() {
    sessionStorage["myStorageKey"] = JSON.stringify(data);
  }
  window.addEventListener("load", loadData, true);
  window.addEventListener("unload", saveData, true);
&#x003C;/script&#x003E;</code></pre>
</figure>





  <p>As you can see, the script contains event listeners to register handlers for load and unload events in the browser window. In this case, the handlers call the <code>loadData()</code> and <code>saveData()</code> functions, respectively.</p>
  <p>In the <code>loadData()</code> function, the session storage area is queried for the value of a storage key, and that key is passed to the <code>JSON.parse()</code> function. The <code>JSON.parse()</code> routine will take a previously saved string representation of an object and reconstitute it into a copy of the original. This routine is called every time the page loads.</p>
  <p>Similarly, the <code>saveData()</code> function takes a data value and calls <code>JSON.stringify()</code> on it to turn it into a string representation of the object. That string is, in turn, stored back into storage. By registering the <code>saveData()</code> function on the <code>unload</code> browser event, we ensure that it is called every time the user navigates away or shuts down the browser or window.</p>
  <p>The practical result of these two functions is that any object we wish to track in storage, no matter if it is a complex object type, can be stored and reloaded as users navigate in and out of the application. This allows developers to extend the techniques we have already shown to nontext data.</p>
  </section>
  <section id="sec18_11">
<a id="hdr_sec18_11" class="section-anchor"></a>

  <h3>A Window into Sharing</h3>
  <p>As alluded to in an earlier section, the ability for Web Storage events to fire in any window browsing the same origin has some powerful implications. It means that storage can be used to send messages from window to window, even if they are not all using the storage object itself. This, in turn implies that we can now share data across windows that have the same origin.</p>
  <p>Let&#x2019;s see how this works using some code samples. To listen to cross-window messages, a simple script needs only to register a handler for storage events. Let&#x2019;s assume that a page running at <code>http://www.example.com/storageLog.html</code> contains the code shown in Listing 11-15 (the sample file <code>storageLog.html</code> for this example is also located in the <code>code/storage</code> folder).</p>

<figure class="listing">
<figcaption>Listing 11-15. Cross-Window Communication Using Storage</figcaption>
<pre><code data-cm-mode="javascript">// display records of new storage events
function displayStorageEvent(e) {
  var incomingRow = document.createElement('div');
  document.getElementById("container").appendChild(incomingRow);
  var logged = "key:" + e.key + ", newValue:" + e.newValue + ", oldValue:" +
                e.oldValue + ", url:" + e.url + ", storageArea:" + e.storageArea; +
                incomingRow.innerHTML = logged;
}
// add listeners on storage events
window.addEventListener("storage", displayStorageEvent, true);</code></pre>
</figure>




  <p>After registering an event listener for the <code>storage</code> event type, this window will receive notification of storage changes in any pages. For example, if a browser window viewing <code>http://www.example.com/browser-test.html</code> that is currently browsing the same origin sets or changes a new storage value, the <code>storageLog.html</code> page will receive a notification. Therefore, to send a message to a receiving window, the sending window need only modify a storage object, and its old and new values will be sent as part of the notification. For example, if a storage value is updated using <code>localStorage.setItem()</code>, then the <code>displayStorageEvent()</code> handler in the <code>storageLog.html</code> page hosted at the same origin will receive an event. By carefully coordinating event names and values, the two pages can now communicate, a feat which has been difficult to accomplish before. Figure 11-13 shows the <code>storageLog.html</code> page in action, simply logging storage events it receives.</p>

  <figure class="image">
    <img src="images/ch11/fig11-13.gif" />
    <figcaption>Figure 11-13. The storageLog.html page logging storage eventsSummary</figcaption>
  </figure>

  </section>
  </section>
  <section id="sec19_11">
<a id="hdr_sec19_11" class="section-anchor"></a>

  <h2>Summary</h2>
  <p>In this chapter, we showed how Web Storage can be used as an alternative to browser cookies for keeping local copies of data across windows, tabs, and (with <code>localStorage</code>) even across browser restarts. You&#x2019;ve seen that data can be appropriately segregated between windows by using <code>sessionStorage</code>, and shared&#x2014;even across windows&#x2014;by using storage events. In our full-fledged example, we showed a practical way to use storage to track data from page to page as users navigate a website, which could just as easily be applied to other data types. We even demonstrated how nontext data types can be stored when a page loads or unloads to save and restore the state of a page across visits.</p>
  <p>In the next chapter, we&#x2019;ll show you how HTML5 lets you create offline applications.</p>

</section>

<footer class="next-chapter">
  <p><a href="ch12.html">Go to the Next Chapter</a></p>
</footer>

</div>
</article>

<!--====================== END CONTENT ======================-->
      
<a id="main-navigation" class="nav-anchor"></a>
<div class="nav-container">
<nav id="menu" role="navigation">
  <ul>
    <li class="current">
      <a href="#chapter_title">Chapter 11</a>
      <ul>
        <li><a href="#hdr_sec2_11">Overview of Web Storage</a></li>
        <li><a href="#hdr_sec3_11">Browser Support for Web Storage</a></li>
        <li>
          <a href="#hdr_sec4_11">Using the Web Storage API</a>
          <ul>
            <li><a href="#hdr_sec5_11">Checking for Browser Support</a></li>
            <li><a href="#hdr_sec6_11">Setting and Retrieving Values</a></li>
            <li><a href="#hdr_sec7_11">Plugging Data Leaks</a></li>
            <li><a href="#hdr_sec8_11">Local Versus Session Storage</a></li>
            <li><a href="#hdr_sec9_11">Other Web Storage API Attributes and Functions</a></li>
            <li><a href="#hdr_sec10_11">Communicating Web Storage Updates</a></li>
            <li><a href="#hdr_sec11_11">Exploring Web Storage</a></li>
          </ul>
        </li>
        <li><a href="#hdr_sec12_11">Building an Application with Web Storage</a></li>
        <li>
          <a href="#hdr_sec13_11">The Future of Browser Database Storage</a>
          <ul>
            <li><a href="#hdr_sec14_11">The Web SQL Database</a></li>
            <li><a href="#hdr_sec15_11">The Indexed Database API</a></li>
          </ul>
        </li>
        <li>
          <a href="#hdr_sec16_11">Practical Extras</a>
          <ul>
            <li><a href="#hdr_sec17_11">JSON Object Storage</a></li>
            <li><a href="#hdr_sec18_11">A Window into Sharing</a></li>
          </ul>
        </li>
        <li><a href="#hdr_sec19_11">Summary</a></li>
      </ul>
    </li>
  </ul>
</nav>
</div>

  </body>

</html>



