<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE Chapter PUBLIC "-//Springer-Verlag//DTD A++ V2.4//EN" "http://devel.springer.de/A++/V2.4/DTD/A++V2.4.dtd">
<Chapter Language="En" OutputMedium="All" ID="Chap9_9">
<ChapterInfo Language="En" ChapterType="OriginalPaper" NumberingStyle="ChapterOnly" TocLevels="0" ContainsESM="No" OutputMedium="All">
<ChapterID>9</ChapterID>
<ChapterNumber>Chapter 9</ChapterNumber>
<ChapterDOI>10.1007/978-1-4302-3865-2_9</ChapterDOI>
<ChapterSequenceNumber>9</ChapterSequenceNumber>
<ChapterTitle Language="En">Working with HTML5 Drag-and-Drop<IndexTerm><Primary>HTML5 drag-and-drop</Primary></IndexTerm></ChapterTitle>
<ChapterFirstPage>1</ChapterFirstPage>
<ChapterLastPage>28</ChapterLastPage>
<ChapterCopyright>
<CopyrightHolderName>Peter Lubbers, Brian Albers, and Frank Salim</CopyrightHolderName>
<CopyrightYear>2011</CopyrightYear>
</ChapterCopyright>
<ChapterHistory>
<OnlineDate>
<Year><?InsertOnReleaseOF OFYear?></Year>
<Month><?InsertOnReleaseOF OFMonth?></Month>
<Day><?InsertOnReleaseOF OFDay?></Day>
</OnlineDate>
</ChapterHistory>
</ChapterInfo>
<ChapterHeader>
<AuthorGroup>
<Author AffiliationIDS="Aff1_9" CorrespondingAffiliationID="Aff1_9">
<AuthorName>
<GivenName>Peter</GivenName>
<FamilyName>Lubbers</FamilyName>
</AuthorName>
</Author>
<Author AffiliationIDS="Aff1_9">
<AuthorName>
<GivenName>Brian</GivenName>
<FamilyName>Albers</FamilyName>
</AuthorName>
</Author>
<Author AffiliationIDS="Aff1_9">
<AuthorName>
<GivenName>Frank</GivenName>
<FamilyName>Salim</FamilyName>
</AuthorName>
</Author>
<Affiliation ID="Aff1_9">
<OrgName>Technical Communication at Kaazing</OrgName>
<OrgAddress>
<City>San Francisco</City>
<State>CA</State>
<Country>USA</Country>
</OrgAddress>
</Affiliation>
</AuthorGroup>
<Abstract Language="En" OutputMedium="Online" ID="Abs1_9">
<Heading>Abstract</Heading>
<Para>Traditional drag-and-drop has been popular with users since the days of the original Apple Macintosh. But today&#x2019;s computers and mobile devices have much more sophisticated drag-and-drop behavior. Drag-and-drop is used in file management, transferring data, diagramming, and many other operations where moving an object is more naturally envisioned with a gesture than a key command. Ask developers on the street what drag-and-drop encompasses, and you are likely to get a myriad of different answers depending on their favorite programs and current work assignments. Ask non-technical users about drag-and-drop, and they may stare at you blankly; the feature is now so ingrained into computing that it does not often get called out by name anymore.</Para>
</Abstract>
</ChapterHeader>
<Body>
<Para>Traditional drag-and-drop has been popular with users since the days of the original Apple Macintosh. But today&#x2019;s computers and mobile devices have much more sophisticated drag-and-drop behavior. Drag-and-drop is used in file management, transferring data, diagramming, and many other operations where moving an object is more naturally envisioned with a gesture than a key command. Ask developers on the street what drag-and-drop encompasses, and you are likely to get a myriad of different answers depending on their favorite programs and current work assignments. Ask non-technical users about drag-and-drop, and they may stare at you blankly; the feature is now so ingrained into computing that it does not often get called out by name anymore.</Para>
<Para>And yet, HTML has not had drag-and-drop as a core feature in its first 15 years of existence. Although some developers have used the built-in ability to handle low-level mouse events as a way to hack up primitive drag-and-drop, those efforts paled in comparison to the type of drag-and-drop features that have been available in desktop applications for decades. With the arrival of a well-specified set of drag-and-drop functionality, HTML applications have advanced one step closer to matching the capabilities of their desktop counterparts.</Para>
<Section1 ID="Sec2_9">
<Heading>Web <IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>Web</Secondary></IndexTerm>Drag-and-Drop: The Story So Far</Heading>
<Para>You may have seen examples of drag-and-drop on the Web already and are wondering if these are uses of HTML5 drag-and-drop. The answer? Probably not.</Para>
<Para>The reason is that HTML and DOM have exposed low-level mouse events since the early days of DOM events, and that has been sufficient for creative developers to craft a rudimentary drag-and-drop capability. When coupled with CSS positioning, it is possible to approximate a drag-and-drop system through the creation of complex JavaScript libraries and a firm knowledge of DOM events.</Para>
<Para>For example, by handling the following DOM events, it is possible to move items around in a web page if you code a set of logical steps (and some caveats):<UnorderedList Mark="Bullet">
<ItemContent><Para><Literal>mousedown</Literal>: The user is starting some mouse operation. (Is it a drag or just a click?)</Para></ItemContent>
<ItemContent><Para><Literal>mousemove</Literal>: If the mouse is not up yet, a move operation is starting. (Is it a drag or a select?)</Para></ItemContent>
<ItemContent><Para><Literal>mouseover</Literal>: The mouse has moved over an element. (Is it one of the ones I want to drop on?)</Para></ItemContent>
<ItemContent><Para><Literal>mouseout</Literal>: The mouse has left an element that will no longer be a possible place to drop. (Do I need to draw feedback?)</Para></ItemContent>
<ItemContent><Para><Literal>mouseup</Literal>: The mouse has released, possibly triggering a drop operation. (Should the drop complete on this location based on where it started from?)</Para></ItemContent>
</UnorderedList>
</Para>
<Para>Although modeling a crude drag-and-drop system using low-level events is possible, it suffers from some notable drawbacks. First, the logic necessary to handle the mouse events is more complex than you might imagine, as each of the listed events has many edge cases that must be accounted for. Although some were in the previous list, the reality is that there are enough of them to warrant their own chapter. During these events, CSS must be carefully updated to provide feedback to the user about the possibility of dragging or dropping at any particular location.</Para>
<Para>However, an even more <IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>web</Secondary></IndexTerm>serious drawback is that this type of ad hoc drag-and-drop implementation relies on total control of the system. If you try mixing your app content with other content in the same page, things quickly spiral out of control when different developers start using events for their own means. Similarly, if you try to drag-and-drop content from someone else&#x2019;s code, you may have trouble unless the two codebases are carefully coordinated beforehand. Also, ad hoc drag-and-drop does not interact with the user&#x2019;s desktop or work across windows.</Para>
<Para>The new HTML5 drag-and-drop API has been designed to address these limitations, borrowing from the way drag-and-drop has been provided in other user interface frameworks.</Para>
<FormalPara RenderingStyle="Style1"><Heading>n Note</Heading>
<Para>Even when properly implemented, beware of the limitations of drag-and-drop in any application. Mobile devices that use drag gestures to navigate might not function correctly if drag behavior is overridden. Also, drag-and-drop can interfere with drag selection. Take care to use it sparingly and appropriately.</Para>
</FormalPara>
</Section1>
<Section1 ID="Sec3_9">
<Heading>Overview of HTML5 Drag-and-Drop</Heading>
<Para>If you have used the drag-and-drop APIs in programming technologies such as Java or Microsoft MFC, then you&#x2019;re in luck. The new HTML5 drag-and-drop API is closely modeled on the concepts of these environments. Getting started is easy, but mastering the new functionality means that you will need to become acquainted with a new set of DOM events, though this time at a higher level of abstraction.</Para>
<Section2 ID="Sec4_9">
<Heading>The Big Picture</Heading>
<Para>The easiest way to learn the new API is to map it to the concepts with which you are already familiar. If you are reading a book on pro HTML5 programming, we&#x2019;ll make a bold assumption that you are experienced with using drag-and-drop in your day-to-day computing. Nonetheless, we can start by putting some standard terms on the major concepts.</Para>
<Para>As shown in Figure <InternalRef RefID="Fig1_9">9-1</InternalRef>, when you (as a user) start a drag-and-drop operation, you start by clicking and dragging the pointer. The item or region where you began the drag is known as the<IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary><Emphasis Type="Bold">drag source</Emphasis></Secondary></IndexTerm> <Emphasis Type="Bold">drag source</Emphasis>. When you release the pointer and complete the operation, the region or item you are targeting at the end is known as the<IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary><Emphasis Type="Bold">drop target</Emphasis></Secondary></IndexTerm> <Emphasis Type="Bold">drop target</Emphasis>. As the mouse moves across the page, you may traverse a series of drop targets before you actually release the mouse.<Figure ID="Fig1_9" Float="Yes" Category="Standard">
<Caption Language="En">
<CaptionNumber>Figure 9-1</CaptionNumber>
<CaptionContent>
<SimplePara>Drag sources and drop targets</SimplePara>
</CaptionContent>
</Caption>
<MediaObject ID="MO1_9">
<ImageObject FileRef="978-1-4302-3865-2_9_Fig1_HTML.gif" Format="GIF" Color="BlackWhite" Type="Linedraw" Rendition="HTML"/>
</MediaObject>
</Figure>
</Para>
<Para>So far, so good. But simply holding down the mouse and moving it to another part of an application is not what constitutes a drag-and-drop. Rather, it is the feedback during the operation that makes for a <IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>successful interaction</Secondary></IndexTerm>successful interaction. Consider your own uses of drag-and-drop in past experiences; the ones that are the most intuitive are those where the system is giving constant updates to let you know what will happen if you release at this point in time:<UnorderedList Mark="Bullet">
<ItemContent><Para>Does the cursor indicate that the current position is a valid drop target, or does it imply a rejection with a &#x201C;forbidden&#x201D; cursor indicator?</Para></ItemContent>
<ItemContent><Para>Does the cursor imply to the user that the operation will be a move, link, or a copy, such as with a &#x201C;plus&#x201D; sign indicator on the cursor?</Para></ItemContent>
<ItemContent><Para>Does the area or target you are hovering over change its appearance in any way to indicate that it is currently selected as a drop if you release right now?</Para></ItemContent>
</UnorderedList>
</Para>
<Para>In order to give similar feedback<IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>feedback</Secondary></IndexTerm> to users over the course of an HTML drag-and-drop operation, the browsers will emit a whole slew of events over the course of a single drag. This proves quite handy, as during these events we will have full power to change the DOM and style of the page elements to give just the type of feedback that users will be expecting.</Para>
<Para>Beyond the drag source and drop target, there is one more key concept to learn in the new API: the<IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>data transfer</Secondary></IndexTerm> <Emphasis Type="Bold">data transfer</Emphasis>. The specification describes the data transfer as the set of objects used to expose the drag data store that underlies a drag-and-drop operation. However, it may be easier just to think of the data transfer as being the central control of drag-and-drop. The operation type (e.g., move, copy, or link), the image to use as feedback during the drag, and the retrieval of the data itself are all managed here.</Para>
<Para>Regarding the data itself, the <Literal>dataTransfer</Literal> mechanism for completing the drop directly addresses one of the limitations of the old ad hoc drag-and-drop techniques described previously. Instead of forcing all drag sources and drop targets to be aware of each other, the data transfer mechanism works similar to a network protocol negotiation. In this case, the negotiation is performed via<IndexTerm><Primary>Multipurpose Internet Mail Exchange (MIME)</Primary></IndexTerm> Multipurpose Internet Mail Exchange <IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>MIME types</Secondary></IndexTerm>(MIME) types.</Para>
<FormalPara RenderingStyle="Style1"><Heading>n Note</Heading>
<Para>MIME types are the same types used to attach files to e-mail. They are an Internet standard that is used pervasively in all types of Web traffic, and they are very common in HTML5. In short, MIME types are standardized text strings used to classify the type of unknown content, such as &#x201C;text/plain&#x201D; for plain text and &#x201C;image/png&#x201D; for PNG images.</Para>
</FormalPara>
<Para>The purpose of using MIME types is to allow the source and target to negotiate on which format best suits the needs of the drop target. As shown in Figure <InternalRef RefID="Fig2_9">9-2</InternalRef>, during a drag start, the <Literal>dataTransfer</Literal> object is loaded up with data representing all reasonable types, or &#x201C;flavors,&#x201D; by which the data can be transferred. Then, when the drop completes, the drop handler code can scan the available types of data and decide which MIME type format best suits its needs.
<Figure ID="Fig2_9" Float="Yes" Category="Standard">
<Caption Language="En">
<CaptionNumber>Figure 9-2</CaptionNumber>
<CaptionContent>
<SimplePara>Drag and drop<IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>negotiation, data flavors</Secondary></IndexTerm> negotiation of data &#x201C;flavors&#x201D;</SimplePara>
</CaptionContent>
</Caption>
<MediaObject ID="MO2_9">
<ImageObject FileRef="978-1-4302-3865-2_9_Fig2_HTML.gif" Format="GIF" Color="BlackWhite" Type="Linedraw" Rendition="HTML"/>
</MediaObject>
</Figure>
</Para>
<Para>For example, imagine a list item in a web page representing a person. There are many different ways to represent the data for a person; some are standard, some are not. When a drag starts on a particular person&#x2019;s list item, the drag start handler can declare that the person&#x2019;s data is available in a few formats, as shown in Table <InternalRef RefID="Tab1_9">9-1</InternalRef>.
<Table ID="Tab1_9" Float="Yes">
<Caption Language="En">
<CaptionNumber>Table 9-1</CaptionNumber>
<CaptionContent>
<SimplePara>Examples of <IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>MIME types</Secondary></IndexTerm> MIME <IndexTerm><Primary>Multipurpose Internet Mail Exchange (MIME)</Primary></IndexTerm> Types in Data Transfer of a Person</SimplePara>
</CaptionContent>
</Caption>
<tgroup cols="2" align="left">
<colspec colnum="1" colname="c1" align="left"/>
<colspec colnum="2" colname="c2" align="left"/>
<thead>
<row>
<entry colname="c1">
<SimplePara>MIME Type</SimplePara>
</entry>
<entry colname="c2">
<SimplePara>Result</SimplePara>
</entry>
</row>
</thead>
<tbody>
<row>
<entry colname="c1">
<SimplePara><Literal>text/plain</Literal></SimplePara>
</entry>
<entry colname="c2">
<SimplePara>A standard MIME type for unformatted text. We can use it as the most common representation, such as the person&#x2019;s name.</SimplePara>
</entry>
</row>
<row>
<entry colname="c1">
<SimplePara><Literal>image/png</Literal></SimplePara>
</entry>
<entry colname="c2">
<SimplePara>A standard MIME type for PNG images. Here, it could represent the person&#x2019;s picture in PNG format.</SimplePara>
</entry>
</row>
<row>
<entry colname="c1">
<SimplePara><Literal>image/jpeg</Literal></SimplePara>
</entry>
<entry colname="c2">
<SimplePara>The standard MIME type for JPEG images. It could be used to transfer the person&#x2019;s picture in that format.</SimplePara>
</entry>
</row>
<row>
<entry colname="c1">
<SimplePara><Literal>text/x-age</Literal></SimplePara>
</entry>
<entry colname="c2">
<SimplePara>A non-standard MIME type (as indicated by the x- prefix). We could use this format to transfer our own types of information, such as the person&#x2019;s age.</SimplePara>
</entry>
</row>
</tbody>
</tgroup>
</Table>
</Para>
<Para>When the drop completes, the drop handler can query for a list of available data types. From the provided list, the handler can choose which type is most appropriate. A text list drop target may choose to grab the text/plain &#x201C;flavor&#x201D; of data to <IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>data retrieval</Secondary></IndexTerm>retrieve the person&#x2019;s name, while a more advanced control might choose to retrieve and display the person&#x2019;s PNG image as a result of the drop. And, if the source and target have coordinated on non-standard types, the target could also retrieve the person&#x2019;s <IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>negotiation, data flavors</Secondary></IndexTerm>age at the time of the drop (see Figure <InternalRef RefID="Fig2_9">9-2</InternalRef>).</Para>
<Para>It is this negotiation process that allows for drag sources and drop targets to be decoupled. As long as the drag sources provide data in a choice of MIME types, the drop target can choose which format suits its operation the best, even if the two came from different developers. In later sections of this chapter, we&#x2019;ll explore how even more unusual MIME types, such as files, can be used.</Para>
</Section2>
<Section2 ID="Sec5_9">
<Heading>Events to Remember</Heading>
<Para>Now that we&#x2019;ve explored the key concepts of the drag-and-drop API, let&#x2019;s focus on the <IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>events</Secondary></IndexTerm>events that can be used throughout the process. As you&#x2019;ll see, the events operate at a higher level than the mouse events previously utilized to mock up a drag-and-drop system. However, drag-and-drop events extend the DOM mouse event. Therefore, you still have access to the low-level mouse information, such as coordinates, if you need it.</Para>
</Section2>
<Section2 ID="Sec6_9">
<Heading>Propagation and Prevention<IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>propagation and prevention</Secondary></IndexTerm></Heading>
<Para>But before we focus on drag and-drop-itself, let&#x2019;s refresh on two DOM event functions that have been around since the browsers standardized on DOM Level 3 events: the <IndexTerm><Primary>stopPropagation</Primary></IndexTerm><Literal>stopPropagation</Literal> and <IndexTerm><Primary>preventDefault</Primary></IndexTerm><Literal>preventDefault</Literal> functions.</Para>
<Para>Consider the case where one element in a page is nested inside another element. We will refer to them as the child and parent elements, respectively. The child takes up some, but not all, of the visible space of the parent. Although we are only referring to two elements in our example, in practice a web page often has many levels of nesting.</Para>
<Para>When a user clicks a mouse on the child, which element should actually receive the event: the child, the parent, or both? And if both, in which order? The answer to this question was settled by the World Wide Web Consortium (W3C) in the DOM events specification. Events flow from a parent, through intermediaries, and down to the most specific child first in a process known as <IndexTerm><Primary>Event capture process</Primary></IndexTerm>&#x201C;event capture.&#x201D; Once the child has had access to the event, the event flows back up the element hierarchy via a process known as <IndexTerm><Primary>Event building process</Primary></IndexTerm>&#x201C;event bubbling.&#x201D; Together, these two flows allow developers to catch and process the event in the way that is most suitable to their page architecture. Only elements with handlers actually registered will process the event, which keeps the system lightweight. The overall approach is a compromise among different behaviors from multiple browser vendors, and it is consistent with other native development frameworks, some of which capture and some of which bubble.</Para>
<Para>However, at any time a handler can call the <IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>propagation and prevention</Secondary></IndexTerm><Literal>stopPropagation</Literal> function on the event, which will stop it from further traversing down the event capture chain or up through the bubbling phase.</Para>
<FormalPara RenderingStyle="Style1"><Heading>n Note</Heading>
<Para>Microsoft has provided a great interactive demo of event models at <Literal>http://ie.microsoft.com/testdrive/HTML5/ComparingEventModels</Literal>.</Para>
</FormalPara>
<Para>Browsers also have default implementations for how some events will be handled. For example, when a user clicks on a page link, the default behavior is to navigate the browser to the destination specified by the link. Developers can prevent this by intercepting the event in a handler and calling <Literal>preventDefault</Literal> on it. This allows code to override the default behaviors of some built-in events. It is also how a developer can cancel a drag-and-drop operation in an event handler.</Para>
<Para>Both <Literal>stopPropagation</Literal><IndexTerm><Primary>stopPropagation</Primary></IndexTerm> and <Literal>preventDefault</Literal><IndexTerm><Primary>preventDefault</Primary></IndexTerm> will be handy in our examples of the drag-and-drop API.</Para>
</Section2>
<Section2 ID="Sec7_9">
<Heading>Drag-and-Drop Event Flow<IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>event flow</Secondary></IndexTerm></Heading>
<Para>When a user initiates a drag-and-drop operation in an HTML5-ready browser, a series of events trigger at the start and continue throughout the course of the whole operation. We will examine them in turn here.</Para>
<Section3 ID="Sec27_9">
<Heading>dragstart</Heading>
<Para>The <IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>event flow</Secondary><Tertiary>dragstart</Tertiary></IndexTerm><Literal>dragstart</Literal> event is fired on an element in the page when the user begins to drag on it. In other words, once the mouse is down and the user moves the mouse, the <Literal>dragstart</Literal> is initiated. The <Literal>dragstart</Literal> event is of key importance, as it is the only event where the <Literal>dataTransfer</Literal> can have data set on it using the <Literal>setData</Literal> call. This means that in a <Literal>dragStart</Literal> handler, the possible data types need to be set up so that they can be queried at the end of the drop, as described previously.</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Interception!</Heading>
<Para><Emphasis Type="Bold">Brian says</Emphasis>: &#x201C;If you are wondering why the data types can only be set during the <Literal>dragStart</Literal> event, there&#x2019;s actually a very good reason for that.</Para>
<Para>Because drag-and-drop has been designed to work across windows and across content from various sources, it would be a security risk if <Literal>drag</Literal> event listeners were able to insert or replace data when the drag passed over them. Imagine a malicious section of code event listeners inserted that queried and replaced drag data of any drag travelling by. This would misrepresent the intentions of the drag source, and as such any data replacements after the start are forbidden.&#x201D;</Para>
</FormalPara>
</Section3>
<Section3 ID="Sec28_9">
<Heading>drag</Heading>
<Para>The <Literal>drag</Literal> event can be thought of as the continuous event of a drag operation. As the user moves the mouse cursor around the page, the <Literal>drag</Literal> event is called repeatedly on the <IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>event flow</Secondary><Tertiary>drag</Tertiary></IndexTerm>drag <Emphasis Type="Italic">source</Emphasis>. The <Literal>drag</Literal> event will fire a few times each second during the operation. Although the visuals of the drag feedback can be modified during a <Literal>drag</Literal> event, the data on the <Literal>dataTransfer</Literal> is off-limits.</Para>
</Section3>
<Section3 ID="Sec29_9">
<Heading>dragenter</Heading>
<Para>When the drag crosses into a new element on the page, a <IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>event flow</Secondary><Tertiary>dragenter</Tertiary></IndexTerm><Literal>dragenter</Literal> event fires on that element. This event is a good time to set drop feedback on the element based on whether or not it can receive the drop.</Para>
</Section3>
<Section3 ID="Sec30_9">
<Heading>dragleave</Heading>
<Para>Conversely, the browser will fire a <IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>event flow</Secondary><Tertiary>dragleave</Tertiary></IndexTerm><Literal>dragleave</Literal> event whenever the user moves the drag out of the element where dragenter was previously called. Drop feedback can be restored at this time, as the mouse is no longer<IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>event flow</Secondary><Tertiary>dragleave</Tertiary></IndexTerm> over this target.</Para>
</Section3>
<Section3 ID="Sec31_9">
<Heading>dragover</Heading>
<Para>The <Literal>dragover</Literal><IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>event flow</Secondary><Tertiary>dragover</Tertiary></IndexTerm> event is called at frequent intervals as the mouse moves over an element during a drag operation. Unlike its counterpart <Literal>drag</Literal> event, which is called on the drag source, this event is called on the current target of the mouse.</Para>
</Section3>
<Section3 ID="Sec32_9">
<Heading>drop</Heading>
<Para>The <Literal>drop</Literal> event<IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>event flow</Secondary><Tertiary>drop</Tertiary></IndexTerm> is called on the current mouse target when the user releases the mouse. Based on the result of the <Literal>dataTransfer</Literal> object, this is where the code to handle the drop should be executed.</Para>
</Section3>
<Section3 ID="Sec33_9">
<Heading>dragend</Heading>
<Para>The final event in the chain, <IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>event flow</Secondary><Tertiary>dragend fire</Tertiary></IndexTerm><Literal>dragend</Literal> fires on the drag source, indicating that the drag completed. It is particularly suitable for cleaning up the state used during the drag, as it is called regardless of whether or not the drop completes.</Para>
<Para>Altogether, there are plenty of ways for you to intercept the drag-and-drop operations and take action. The drag-and-drop event chain is summarized in Figure <InternalRef RefID="Fig3_9">9-3</InternalRef>.
<Figure ID="Fig3_9" Float="Yes" Category="Standard">
<Caption Language="En">
<CaptionNumber>Figure 9-3</CaptionNumber>
<CaptionContent>
<SimplePara>Drag-and-drop event flow<IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>event flow</Secondary></IndexTerm>
</SimplePara>
</CaptionContent>
</Caption>
<MediaObject ID="MO3_9">
<ImageObject FileRef="978-1-4302-3865-2_9_Fig3_HTML.gif" Format="GIF" Color="BlackWhite" Type="Linedraw" Rendition="HTML"/>
</MediaObject>
</Figure>
</Para>
</Section3>
</Section2>
<Section2 ID="Sec8_9">
<Heading>Drag Participation<IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>event flow</Secondary><Tertiary>drag participation</Tertiary></IndexTerm></Heading>
<Para>Now that you&#x2019;ve seen the different events that can be triggered during a drag-and-drop operation, you might be wondering what it takes to mark elements in your web application as draggable. That&#x2019;s easy!</Para>
<Para>Aside from a few elements&#x2014;such as text controls&#x2014;elements in a page are not draggable by default. In order to mark a specific element as draggable, however, all you need to do is add one attribute: draggable.</Para>
<Para Type="Programcode">&#x003C;div id=&#x201D;myDragSource&#x201D; <Emphasis Type="Bold">draggable=&#x201D;true&#x201D;</Emphasis>&#x003E;</Para>
<Para>Simply by adding that attribute, you cause the browser to fire the aforementioned events. Then, you only need to add the event handlers to manage them.</Para>
</Section2>
<Section2 ID="Sec9_9">
<Heading>Transfer and Control</Heading>
<Para>Before we move into our example, let&#x2019;s assess the<IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>event flow</Secondary><Tertiary>transfer and control</Tertiary></IndexTerm> <Literal>dataTransfer</Literal> object in more detail. The <Literal>dataTransfer</Literal> is available from every drag-and-drop event, as shown in Listing 9-1.</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 9-1.</Heading>
<Para>Retrieving the dataTransfer Object</Para>
</FormalPara>
<Para Type="Programcode">Function handleDrag(evt) {</Para>
<Para Type="Programcode">    var transfer = evt.dataTransfer;</Para>
<Para Type="Programcode">    // &#x2026;</Para>
<Para Type="Programcode">}</Para>
<Para>As discussed in Listing 9-1, the <Literal>dataTransfer</Literal> is used to get and set the actual drop data during the negotiation between source and target. This is done using the following functions and properties:<UnorderedList Mark="Bullet">
<ItemContent><Para><Literal>setData(format, data)</Literal>: Calling this function during <Literal>dragStart</Literal> allows you to register one transfer item under a MIME type format.</Para></ItemContent>
<ItemContent><Para><Literal>getData(format)</Literal>: This function allows the registered data item for a given type to be retrieved.</Para></ItemContent>
<ItemContent><Para><Literal>types</Literal>: This property returns an array of all currently registered formats.</Para></ItemContent>
<ItemContent><Para><Literal>items</Literal>: This property returns a list of all items and their associated formats together.</Para></ItemContent>
<ItemContent><Para><Literal>files</Literal>: This property returns any files associated with the drop. This is discussed in more detail in a later section.</Para></ItemContent>
<ItemContent><Para><Literal>clearData()</Literal>: Calling this function with no argument clears out all registered data. Calling it with a format argument removes only that specific registration.</Para></ItemContent>
</UnorderedList>
</Para>
<Para>Two more functions can be used to alter the feedback during a drag operation:<UnorderedList Mark="Bullet">
<ItemContent><Para><Literal>setDragImage(element, x, y)</Literal><IndexTerm><Primary>setDragImage</Primary></IndexTerm>: Tells the browser to use an existing image element as the drag image, which will display alongside the cursor to hint to the user about the drag operation effects. If x and y coordinates are provided, then those coordinates will be considered as the drop point for the mouse.</Para></ItemContent>
<ItemContent><Para><Literal>addElement(element)</Literal><IndexTerm><Primary>addElement</Primary></IndexTerm>: By calling this function with a provided page element, you tell the browser to draw that element as a drag feedback image.</Para></ItemContent>
</UnorderedList>
</Para>
<Para>A final set of properties allows the developer to set and/or query the types of drag operations that are allowed:<UnorderedList Mark="Bullet">
<ItemContent><Para><Literal>effectAllowed</Literal><IndexTerm><Primary>effectAllowed</Primary></IndexTerm>: Setting this property to one of none, copy, copyLink, copyMove, link, linkMove, move, or all tells the browser that only the type(s) of operations listed here are to be allowed for the user. For example, if copy is set, only copy operations will be allowed, and move or link operations will be prevented.</Para></ItemContent>
<ItemContent><Para><Literal>dropEffect</Literal><IndexTerm><Primary>dropEffect</Primary></IndexTerm>: This property can be used to determine which type of operation is currently underway or set to force a particular operation type. The types of operations are copy, link, and move. Or, the value none can be set to prevent any drop from happening at that point in time.</Para></ItemContent>
</UnorderedList>
</Para>
<Para>Together, these operations give a fine level of <IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>event flow</Secondary><Tertiary>transfer and control</Tertiary></IndexTerm>control over drag-and-drop. Now, let&#x2019;s see them in action.</Para>
</Section2>
</Section1>
<Section1 ID="Sec10_9">
<Heading>Building an Application with Drag-and-Drop</Heading>
<Para>Using the concepts we&#x2019;ve already learned, we&#x2019;ll build a simple drag-and-drop page in the theme of our Happy Trails Running Club. This page lets the club race organizers drag members of the club into one of two lists: racers and volunteers. In order to sort them into competitive groups, racers will be sorted by their age. Volunteers, on the other hand, are only sorted by their names, as their ages don&#x2019;t matter when they are not competing.</Para>
<Para>The sorting<IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>racers sorted</Secondary></IndexTerm> of the lists is done automatically. The application itself will show feedback indicating where proper drop areas are for members into the two lists as shown in Figure <InternalRef RefID="Fig4_9">9-4</InternalRef>.
<Figure ID="Fig4_9" Float="Yes" Category="Standard">
<Caption Language="En">
<CaptionNumber>Figure 9-4</CaptionNumber>
<CaptionContent>
<SimplePara>Example page showing <IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>racers sorted</Secondary></IndexTerm>racers sorted into lists</SimplePara>
</CaptionContent>
</Caption>
<MediaObject ID="MO4_9">
<ImageObject FileRef="978-1-4302-3865-2_9_Fig4_HTML.gif" Format="GIF" Color="BlackWhite" Type="Linedraw" Rendition="HTML"/>
</MediaObject>
</Figure>
</Para>
<Para>All of the code for this example is included with the book&#x2019;s samples. We&#x2019;ll step through the page and explain how it works in practice.</Para>
<Para>First, let&#x2019;s look at the markup for the page. At the top, we&#x2019;ve declared the data on our club members (see Listing 9-2).</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 9-2.</Heading>
<Para>Markup Displaying <IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>draggable member names and ages</Secondary></IndexTerm> Draggable Member Names and Ages</Para>
</FormalPara>
<Para Type="Programcode">&#x003C;p&#x003E;Drag members to either the Racers or Volunteers list.&#x003C;/p&#x003E;</Para>
<Para Type="Programcode">&#x003C;ul id="members"&#x003E;</Para>
<Para Type="Programcode">&#x003C;li draggable="true" data-age="38"&#x003E;Brian Albers&#x003C;/li&#x003E;</Para>
<Para Type="Programcode">&#x003C;li draggable="true" data-age="25"&#x003E;Frank Salim&#x003C;/li&#x003E;</Para>
<Para Type="Programcode">&#x003C;li draggable="true" data-age="47"&#x003E;Jennifer Clark&#x003C;/li&#x003E;</Para>
<Para Type="Programcode">&#x003C;li draggable="true" data-age="18"&#x003E;John Kemble&#x003C;/li&#x003E;</Para>
<Para Type="Programcode">&#x003C;li draggable="true" data-age="20"&#x003E;Lorraine Gaunce&#x003C;/li&#x003E;</Para>
<Para Type="Programcode">&#x003C;li draggable="true" data-age="30"&#x003E;Mark Wang&#x003C;/li&#x003E;</Para>
<Para Type="Programcode">&#x003C;li draggable="true" data-age="41"&#x003E;Morgan Stephen&#x003C;/li&#x003E;</Para>
<Para Type="Programcode">&#x003C;li draggable="true" data-age="39"&#x003E;Peter Lubbers&#x003C;/li&#x003E;</Para>
<Para Type="Programcode">&#x003C;li draggable="true" data-age="33"&#x003E;Vanessa Combs&#x003C;/li&#x003E;</Para>
<Para Type="Programcode">&#x003C;li draggable="true" data-age="54"&#x003E;Vivian Lopez&#x003C;/li&#x003E;</Para>
<Para Type="Programcode">&#x003C;/ul&#x003E;</Para>
<Para>As you can see, each of the<IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>draggable member names and ages</Secondary></IndexTerm> member list elements is marked as <Literal>draggable</Literal>. This tells the browser to let drags start on each of them. The next thing you&#x2019;ll notice is that the age of a given member is encoded as a data attribute. The data- notation is a standard way to store non-standard attributes on an HTML element.</Para>
<Para>Our next section contains the target lists (see Listing 9-3).</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 9-3.</Heading>
<Para>Markup for <IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>drop list target</Secondary></IndexTerm> Drop List Targets</Para>
</FormalPara>
<Para Type="Programcode">&#x003C;div class="dropList"&#x003E;</Para>
<Para Type="Programcode">&#x003C;fieldset id="racersField"&#x003E;</Para>
<Para Type="Programcode">&#x003C;legend&#x003E;Racers (by Age):&#x003C;/legend&#x003E;</Para>
<Para Type="Programcode">&#x003C;ul id="racers"&#x003E;&#x003C;/ul&#x003E;</Para>
<Para Type="Programcode">&#x003C;/fieldset&#x003E;</Para>
<Para Type="Programcode">&#x003C;/div&#x003E;</Para>
<Para Type="Programcode">&#x003C;div class="dropList"&#x003E;</Para>
<Para Type="Programcode">&#x003C;fieldset id="volunteersField"&#x003E;</Para>
<Para Type="Programcode">&#x003C;legend&#x003E;Volunteers (by Name):&#x003C;/legend&#x003E;</Para>
<Para Type="Programcode">&#x003C;ul id="volunteers"&#x003E;&#x003C;/ul&#x003E;</Para>
<Para Type="Programcode">&#x003C;/fieldset&#x003E;</Para>
<Para Type="Programcode">&#x003C;/div&#x003E;</Para>
<Para>The unordered lists identified as racers and volunteers are the ultimate destinations where our members will be inserted. The fieldsets surrounding them serve as functional equivalents of a moat around a castle. When the user drags into the fieldset, we&#x2019;ll know that they have exited the contained list and we&#x2019;ll update our visual feedback accordingly.</Para>
<Para>Speaking of feedback, there are a few CSS styles in our page that are important to note (see Listing 9-4).</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 9-4.</Heading>
<Para>Styles for Drag-and-Drop <IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>demo, styles for</Secondary></IndexTerm> Demo</Para>
</FormalPara>
<Para Type="Programcode">#members li {</Para>
<Para Type="Programcode">    cursor: move;</Para>
<Para Type="Programcode">}</Para>
<Para Type="Programcode">.highlighted {</Para>
<Para Type="Programcode">    background-color: yellow;</Para>
<Para Type="Programcode">}</Para>
<Para Type="Programcode">.validtarget {</Para>
<Para Type="Programcode">    background-color: lightblue;</Para>
<Para Type="Programcode">}</Para>
<Para>First, we make sure that every member in our source list shows a move cursor. This gives a hint to the user that the items are draggable.</Para>
<Para>Next, we define two style classes: highlighted and validtarget. These are used to draw background colors on our lists as the drag-and-drop is in progress. The validtarget background will be displayed on our destination lists during the entire drag to hint that they are valid drop targets. When the user actually moves a member over a target list it will change to the highlighted style, indicating that the user is actually over a drop target.</Para>
<Para>To keep track of the state on our page, we&#x2019;ll declare a few variables (see Listing 9-5).</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 9-5.</Heading>
<Para>List Item <IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>variable declaration</Secondary></IndexTerm> Declarations</Para>
</FormalPara>
<Para Type="Programcode">    // these arrays hold the names of the members who are</Para>
<Para Type="Programcode">    // chosen to be racers and volunteers, respectively</Para>
<Para Type="Programcode">    var racers = [];</Para>
<Para Type="Programcode">    var volunteers = [];</Para>
<Para Type="Programcode">    // these variables store references to the visible</Para>
<Para Type="Programcode">    // elements for displaying who is a racer or volunteer</Para>
<Para Type="Programcode">    var racersList;</Para>
<Para Type="Programcode">    var volunteersList;</Para>
<Para>The first two variables will serve as internal arrays, which keep track of which members are in the racers and volunteers lists.</Para>
<Para>The second two variables are only going to be used as handy references to the unordered lists containing the visual display of members in the respective lists.</Para>
<Para>Now, let&#x2019;s set all of our page items up to handle drag-and-drop (see Listing 9-6).</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 9-6.</Heading>
<Para>Event Handler Registration <IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>event handler registration</Secondary></IndexTerm>
</Para>
</FormalPara>
<Para Type="Programcode">    function loadDemo() {</Para>
<Para Type="Programcode">       racersList = document.getElementById("racers");</Para>
<Para Type="Programcode">       volunteersList = document.getElementById("volunteers");</Para>
<Para Type="Programcode">       // our target lists get handlers for drag enter, leave, and drop</Para>
<Para Type="Programcode">       var lists = [racersList, volunteersList];</Para>
<Para Type="Programcode">       [].forEach.call(lists, function(list) {</Para>
<Para Type="Programcode">           list.addEventListener("dragenter", handleDragEnter, false);</Para>
<Para Type="Programcode">           list.addEventListener("dragleave", handleDragLeave, false);</Para>
<Para Type="Programcode">           list.addEventListener("drop", handleDrop, false);</Para>
<Para Type="Programcode">       });</Para>
<Para Type="Programcode">       // each target list gets a particular dragover handler</Para>
<Para Type="Programcode">       racersList.addEventListener("dragover", handleDragOverRacers, false);</Para>
<Para Type="Programcode">       volunteersList.addEventListener("dragover", handleDragOverVolunteers, false);</Para>
<Para Type="Programcode">       // the fieldsets around our lists serve as buffers for resetting</Para>
<Para Type="Programcode">       // the style during drag over</Para>
<Para Type="Programcode">       var fieldsets = document.querySelectorAll("#racersField, #volunteersField");</Para>
<Para Type="Programcode">       [].forEach.call(fieldsets, function(fieldset) {</Para>
<Para Type="Programcode">           fieldset.addEventListener("dragover", handleDragOverOuter, false);</Para>
<Para Type="Programcode">       });</Para>
<Para Type="Programcode">       // each draggable member gets a handler for drag start and end</Para>
<Para Type="Programcode">       var members = document.querySelectorAll("#members li");</Para>
<Para Type="Programcode">       [].forEach.call(members, function(member) {<IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>event handler registration</Secondary></IndexTerm>
</Para>
<Para Type="Programcode">           member.addEventListener("dragstart", handleDragStart, false);</Para>
<Para Type="Programcode">           member.addEventListener("dragend", handleDragEnd, false);</Para>
<Para Type="Programcode">       });</Para>
<Para Type="Programcode">    }</Para>
<Para Type="Programcode">    window.addEventListener("load", loadDemo, false);</Para>
<Para>When the window initially loads, we call a loadDemo function to set up all of our drag-and-drop event handlers. Most of them don&#x2019;t need event capture, and we will set the capture argument accordingly.</Para>
<Para>Both the racersList and the volunteersList will receive handlers for dragenter, dragleave, and drop events, as these are fired on drop targets. Each list will receive a separate dragover event listener, as that will allow us to easily update the drag feedback based on the target the user is currently dragging over.</Para>
<Para>As mentioned previously, we are also adding dragover handlers on the fieldsets surrounding the target lists. Why do we do this? To make it easier to detect when a drag has exited our target lists. Although it is easy for us to detect that a user has dragged an item over our list, it is not so easy to determine when the user has dragged an item <Emphasis Type="Italic">out</Emphasis> of our list. This is because the dragleave events fire both when an item is dragged out of our list <Emphasis Type="Italic">and</Emphasis> when the item is dragged over a child already in the destination list. Essentially, when you drag from a parent element over one of its contained children, the drag exits the parent and enters the child. Although this provides a lot of information, it actually makes it tricky to know when a drag is leaving the outer boundaries of a parent element. Therefore, we will use a notification<IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>notification</Secondary></IndexTerm> that we are dragging over an element <Emphasis Type="Italic">surrounding</Emphasis> our list to inform us that we have exited the list. More information on this will be provided later.</Para>
<FormalPara RenderingStyle="Style1">
<Heading>This Way to the eGRESS</Heading>
<Para><Emphasis Type="Bold">Brian says</Emphasis>: &#x201C;One of the more counter-intuitive aspects of the drag-and-drop specification is the order of events. Although you might expect that a dragged item would exit one target before it entered another, you&#x2019;d be wrong!</Para>
<Para>The order of events fired during a drag from element A into element B is that a dragenter event is fired on element B before the dragleave is fired on element A. This maintains consistency with the HTML mouse event specification, but it is one of the odder aspects of the design. There are more of these quirks ahead, to be sure.&#x201D;</Para>
</FormalPara>
<Para>Our final set of handlers registers dragstart and dragend listeners on every draggable club member in our initial list. We will use them to initialize and clean up any drag. You might notice that we don&#x2019;t add handlers for the drag event, which fires periodically on the drag source. As we will not be updating the appearance of the dragged item, it will be unnecessary for our example.</Para>
<Para>Now, we&#x2019;ll go through the actual event handlers in turn, based on the order in which they generally fire (see Listing 9-7).</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 9-7.</Heading>
<Para>dragstart Event Handler</Para>
</FormalPara>
<Para Type="Programcode">    // called at the beginning of any drag</Para>
<Para Type="Programcode">    function handleDragStart(evt) {</Para>
<Para Type="Programcode">        // our drag only allows copy operations</Para>
<Para Type="Programcode">        evt.effectAllowed = "copy";</Para>
<Para Type="Programcode">        // the target of a drag start is one of our members</Para>
<Para Type="Programcode">        // the data for a member is either their name or age</Para>
<Para Type="Programcode">        evt.dataTransfer.setData("text/plain", evt.target.textContent);</Para>
<Para Type="Programcode">        evt.dataTransfer.setData("text/html", evt.target.dataset.age);</Para>
<Para Type="Programcode">        // highlight the potential drop targets</Para>
<Para Type="Programcode">        racersList.className = "validtarget";</Para>
<Para Type="Programcode">        volunteersList.className = "validtarget";</Para>
<Para Type="Programcode">        return true;</Para>
<Para Type="Programcode">    }</Para>
<Para>The handler for <IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>dragstart handler</Secondary></IndexTerm>dragstart is called on the draggable item where the users begin the operation. It is a somewhat special handler, as it sets up the capabilities of the entire process. First, we set the effectAllowed, which tells the browser that only copies are allowed when dragging from this element&#x2014;no moves or links.</Para>
<Para>Next, we preload all of the possible flavors of data that might be requested at the end of a successful drop. Naturally, we want to support a text version of our element, so we set the MIME type text/plain to return the text inside our draggable node, (i.e., the club member&#x2019;s name).</Para>
<Para>For our second data flavor, we would like the drop operation to transfer another type of data about the drag source; in our case, it is the age of the club member. Unfortunately, due to bugs, not all browsers support user-defined MIME types such as application/x-age yet, which would be the best fit for such an arbitrary flavor. Instead, we will reuse another commonly supported MIME format&#x2014;text/html&#x2014;to stand in for an age flavor for now. Hopefully the WebKit browsers will address this limitation soon.</Para>
<Para>Don&#x2019;t forget that the dragstart handler is the only handler where data transfer values can be set. Attempting to do so in other handlers will fail in order to prevent rogue code from changing the data mid-drag.</Para>
<Para>Our final action in the start handler is purely for demo purposes. We will change the background color of our potential drop target lists to give the user a hint about what is possible.</Para>
<Para>Our next handlers will process events as the dragged item enters and leaves elements on the page (see Listing 9-8).</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 9-8.</Heading>
<Para>dragenter and dragleave Event Handlers</Para>
</FormalPara>
<Para Type="Programcode">    // stop propagation and prevent default drag behavior</Para>
<Para Type="Programcode">    // to show that our target lists are valid drop targets</Para>
<Para Type="Programcode">    function handleDragEnter(evt) {</Para>
<Para Type="Programcode">        evt.stopPropagation();</Para>
<Para Type="Programcode">        evt.preventDefault();</Para>
<Para Type="Programcode">        return false;</Para>
<Para Type="Programcode">    }</Para>
<Para Type="Programcode">    function handleDragLeave(evt) {</Para>
<Para Type="Programcode">        return false;</Para>
<Para Type="Programcode">    }</Para>
<Para>The <IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>dragleave and dragenter</Secondary></IndexTerm>dragleave event is not used by our demo, and we handle it purely for illustrative purposes.</Para>
<Para>The dragenter event, however, can be handled and canceled by calling preventDefault on it when it is fired over a valid drop target. This informs the browser that the current target is a valid drop target, as the <Emphasis Type="Italic">default</Emphasis> behavior is to assume that any target is not a valid drop target.</Para>
<Para>Next, we will look at the dragover handlers (see Listing 9-9). Recall that these fire at regular intervals whenever the drag hovers over the elements in question.</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 9-9.</Heading>
<Para>dragover Handler <IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>dragover Handler</Secondary></IndexTerm> for Outer Container</Para>
</FormalPara>
<Para Type="Programcode">    // for better drop feedback, we use an event for dragging</Para>
<Para Type="Programcode">    // over the surrounding control as a flag to turn off</Para>
<Para Type="Programcode">    // drop highlighting</Para>
<Para Type="Programcode">    function handleDragOverOuter(evt) {</Para>
<Para Type="Programcode">        // due to Mozilla firing drag over events to</Para>
<Para Type="Programcode">        // parents from nested children, we check the id</Para>
<Para Type="Programcode">        // before handling</Para>
<Para Type="Programcode">        if (evt.target.id == "racersField")</Para>
<Para Type="Programcode">          racersList.className = "validtarget";</Para>
<Para Type="Programcode">        else if (evt.target.id == "volunteersField")</Para>
<Para Type="Programcode">          volunteersList.className = "validtarget";</Para>
<Para Type="Programcode">        evt.stopPropagation();</Para>
<Para Type="Programcode">        return false;</Para>
<Para Type="Programcode">    }</Para>
<Para>Our first of three dragover handlers will be used only to adjust the drag feedback. Recall that it is difficult to detect when a drag has left a target, such as our intended racers and volunteers lists. Therefore, we use a drag movement over the fieldsets surrounding the lists to indicate that the drag has exited the vicinity of the lists. This allows us to turn off the drop highlighting on the lists accordingly.</Para>
<Para>Note that our simple code, as listed, will change the CSS className repeatedly if the user hovers in the fieldset area. For optimization purposes, it is good practice to only change the className once, as it may cause the browser to do more work than necessary.</Para>
<Para>Finally, we stop propagation of the event to any other handlers in the page. We don&#x2019;t want any other handlers to override our logic. In the next two dragover handlers, we take a different approach (see Listing 9-10).</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 9-10.</Heading>
<Para>dragover Handler <IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>dragover Handler</Secondary></IndexTerm> for Target Lists</Para>
</FormalPara>
<Para Type="Programcode">    // if the user drags over our list, show</Para>
<Para Type="Programcode">    // that it allows copy and highlight for better feedback</Para>
<Para Type="Programcode">    function handleDragOverRacers(evt) {</Para>
<Para Type="Programcode">        evt.dataTransfer.dropEffect = "copy";</Para>
<Para Type="Programcode">        evt.stopPropagation();</Para>
<Para Type="Programcode">        evt.preventDefault();</Para>
<Para Type="Programcode">        racersList.className = "highlighted";</Para>
<Para Type="Programcode">        return false;</Para>
<Para Type="Programcode">    }</Para>
<Para Type="Programcode">    function handleDragOverVolunteers(evt) {</Para>
<Para Type="Programcode">        evt.dataTransfer.dropEffect = "copy";</Para>
<Para Type="Programcode">        evt.stopPropagation();</Para>
<Para Type="Programcode">        evt.preventDefault();</Para>
<Para Type="Programcode">        volunteersList.className = "highlighted";</Para>
<Para Type="Programcode">        return false;</Para>
<Para Type="Programcode">    }</Para>
<Para>These two handlers, while somewhat verbose, are listed in full to clarify our demo. The first handles dragover events in the racers list, and the second handles dragover events identically in the volunteers list.</Para>
<Para>The first action we take is to set the dropEffect to indicate that only copies are allowed on this node, not moves or links. This is a good practice, even though our original dragstart handler already limited the drag-and-drop operation to be copy-only.</Para>
<Para>Next we prevent other handlers from accessing the event and cancel it. Canceling a dragover event has an important function: it tells the browser that the default operation&#x2014;<Emphasis Type="Italic">not</Emphasis> allowing a drop here&#x2014;is not valid. Essentially, we are telling the browser that it should not not allow a drop; and so, the drop is allowed. Although this may seem counter-intuitive, recall that preventDefault is used to tell the browser not to do its normal built-in operation for an event. For example, calling preventDefault on a click on a link tells the browser to not navigate to the link&#x2019;s reference. The specification designers could have created a new event or API for this dragover, but they opted to keep to the API patterns that were already used throughout HTML.</Para>
<Para>We will also give the user visual feedback by changing the background color to yellow via the highlighted CSS class whenever the user drags over our lists.</Para>
<Para>The main work of the drag-and-drop is done in the <IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>drop handler</Secondary></IndexTerm>drop handler, which we examine next in Listing 9-11.</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 9-11.</Heading>
<Para>Drop Handler for Target Lists</Para>
</FormalPara>
<Para Type="Programcode">    // when the user drops on a target list, transfer the data</Para>
<Para Type="Programcode">    function handleDrop(evt) {</Para>
<Para Type="Programcode">        evt.preventDefault();</Para>
<Para Type="Programcode">        evt.stopPropagation();</Para>
<Para Type="Programcode">        var dropTarget = evt.target;</Para>
<Para Type="Programcode">        // use the text flavor to get the name of the dragged item</Para>
<Para Type="Programcode">        var text = evt.dataTransfer.getData("text/plain");</Para>
<Para Type="Programcode">        var group = volunteers;</Para>
<Para Type="Programcode">        var list = volunteersList;</Para>
<Para Type="Programcode">        // if the drop target list was the racer list, grab an extra</Para>
<Para Type="Programcode">        // flavor of data representing the member age and prepend it</Para>
<Para Type="Programcode">        if ((dropTarget.id != "volunteers") &#x0026;&#x0026;</Para>
<Para Type="Programcode">            (dropTarget.parentNode.id != "volunteers")) {</Para>
<Para Type="Programcode">            text = evt.dataTransfer.getData("text/html") + ": " + text;</Para>
<Para Type="Programcode">            group = racers;</Para>
<Para Type="Programcode">            list = racersList;</Para>
<Para Type="Programcode">        }</Para>
<Para Type="Programcode">        // for simplicity, fully clear the old list and reset it</Para>
<Para Type="Programcode">        if (group.indexOf(text) == -1) {</Para>
<Para Type="Programcode">            group.push(text);</Para>
<Para Type="Programcode">            group.sort();</Para>
<Para Type="Programcode">            // remove all old children</Para>
<Para Type="Programcode">            while (list.hasChildNodes()) {</Para>
<Para Type="Programcode">                list.removeChild(list.lastChild);</Para>
<Para Type="Programcode">            }</Para>
<Para Type="Programcode">            // push in all new children</Para>
<Para Type="Programcode">            [].forEach.call(group, function(person) {</Para>
<Para Type="Programcode">                var newChild = document.createElement("li");</Para>
<Para Type="Programcode">                newChild.textContent = person;</Para>
<Para Type="Programcode">                list.appendChild(newChild);</Para>
<Para Type="Programcode">            });</Para>
<Para Type="Programcode">        }</Para>
<Para Type="Programcode">        return false;<IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>drop handler</Secondary></IndexTerm>
</Para>
<Para Type="Programcode">    }</Para>
<Para>Once again, we start by preventing the default drop behavior and preventing the control from propagating to other handlers. The default drop event depends on the location and type of element dropped. For example, dropping an image dragged in from another source displays it in the browser window, and dropping a link into a window navigates to it by default. We want total control of drop behavior in our demo, so we cancel any default behaviors.</Para>
<Para>Recall that our demo shows how multiple data flavors set up in the dragstart can be retrieved from a dropped element. Here, we see how that retrieval completes. By default, we get the plain text data representing the club member&#x2019;s name by using the text/plain MIME format. If the user drops into the volunteers list, this is sufficient.</Para>
<Para>However, if the user is dropping the club member into the racers list, we take one additional step to fetch the age of the club member, which we previously set using the text/html flavor during dragstart. We prepend it to the club member&#x2019;s name to display both age and name in the racers list.</Para>
<Para>Our final block of code is a simple, albeit unoptimized, routine to clear out all previous members of the target list, add our new member (if he didn&#x2019;t exist already), sort, and refill the list. The end result is a sorted list containing the old members and the newly dropped member, if he was not present before.</Para>
<Para>Regardless of whether or not the user completed the drag-and-drop, we need a dragend handler to clean up (see Listing 9-12).</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 9-12.</Heading>
<Para>dragend Handler <IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>clean up process</Secondary></IndexTerm> for Clean Up</Para>
</FormalPara>
<Para Type="Programcode">    // make sure to clean up any drag operation</Para>
<Para Type="Programcode">    function handleDragEnd(evt) {</Para>
<Para Type="Programcode">        // restore the potential drop target styles</Para>
<Para Type="Programcode">        racersList.className = null;</Para>
<Para Type="Programcode">        volunteersList.className = null;</Para>
<Para Type="Programcode">        return false;</Para>
<Para Type="Programcode">    }<IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>clean up process</Secondary></IndexTerm></Para>
<Para>A dragend handler is called at the end of the drag, whether or not a drop actually occurred. If the user canceled the drag or completed it, the dragend handler is still called. This gives us a good place to clean up any state we changed at the beginning of the process. Not surprisingly, we reset the CSS classes of our lists to their default, unstyled state.</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Sharing Is Caring</Heading>
<Para><Emphasis Type="Bold">Brian says</Emphasis>: &#x201C;If you are wondering whether or not the drag-and-drop functionality is worth all of the event handler code, don&#x2019;t forget one of the key benefits of the API: sharing drags across windows and even across browsers.</Para>
<Para>Because the design of HTML5 drag-and-drop was built to mirror that of desktop capabilities, it is not surprising that it also supports sharing across applications. You can try this out by loading our example in multiple browser windows and dragging members from one source list to the racers and volunteers lists of another window. Although our simple highlighting feedback was not designed for this case, the actual drop capability works across windows and even across browsers if they support the API.&#x201D;</Para>
</FormalPara>
<Para>Our drag-and-drop example is a simple one, but it illustrates the full capability of the API.</Para>
<Section2 ID="Sec11_9">
<Heading>Getting Into the <IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>dropzone</Secondary></IndexTerm>dropzone</Heading>
<Para>If you&#x2019;re thinking that handling all of the drag-and-drop events is complicated, you&#x2019;re not alone. The authors of the specification have designed an alternative, shorthand mechanism to support drop events: the dropzone attribute.</Para>
<Para>The dropzone provides developers with a compact way to register that an element is willing to accept drops without coding up lengthy event handlers. The attribute consists of a few space-separated patterns that, when provided, allow the browser to automatically wire up the drop behavior for you (see Table <InternalRef RefID="Tab2_9">9-2</InternalRef>).
<Table ID="Tab2_9" Float="Yes">
<Caption Language="En">
<CaptionNumber>Table 9-2</CaptionNumber>
<CaptionContent>
<SimplePara>Tokens of the dropzone Attribute</SimplePara>
</CaptionContent>
</Caption>
<tgroup cols="2" align="left">
<colspec colnum="1" colname="c1" align="left"/>
<colspec colnum="2" colname="c2" align="left"/>
<thead>
<row>
<entry colname="c1">
<SimplePara>Token</SimplePara>
</entry>
<entry colname="c2">
<SimplePara>Result</SimplePara>
</entry>
</row>
</thead>
<tbody>
<row>
<entry colname="c1">
<SimplePara>copy, move, link</SimplePara>
</entry>
<entry colname="c2">
<SimplePara>Only one of the three operation types is allowed. If none is specified, copy is assumed.</SimplePara>
</entry>
</row>
<row>
<entry colname="c1">
<SimplePara>s:&#x003C;mime&#x003E;</SimplePara>
</entry>
<entry colname="c2">
<SimplePara>Using the characters s: followed by a MIME type indicates that data of that MIME type is allowed to be dropped on the element.</SimplePara>
</entry>
</row>
<row>
<entry colname="c1">
<SimplePara>f:&#x003C;mime&#x003E;</SimplePara>
</entry>
<entry colname="c2">
<SimplePara>Using the characters f: followed by a MIME type indicates that files of that MIME type are allowed to be dropped on the element.</SimplePara>
</entry>
</row>
</tbody>
</tgroup>
</Table>
</Para>
<Para>Borrowing from our example application, the racers list element could be specified as having the following attribute:</Para>
<Para Type="Programcode">&#x003C;ul id="racers" dropzone=&#x201D;copy s:text/plain s:text/html&#x201D; <IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>dropzone</Secondary></IndexTerm>ondrop=&#x201D;handleDrop(event)&#x201D;&#x003E;</Para>
<Para>This provides a quick way of telling the browser that copy operations for elements that support either the plain text or HTML data format are allowed to drop on our list.</Para>
<Para>The dropzone is not supported by most major browser vendors at the time of writing, but support for it is likely forthcoming.</Para>
</Section2>
</Section1>
<Section1 ID="Sec12_9">
<Heading>Handling Drag-and-Drop for Files<IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>file handling</Secondary></IndexTerm></Heading>
<Para>If you&#x2019;ve ever wanted an easier way to add files to your web application, or you&#x2019;ve wondered how some of the newest sites allow you to drag files directly into a page and upload them, the answer is the HTML5 File API. Although the size and status of the entire <IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>file handling</Secondary><Tertiary>W3C file API</Tertiary></IndexTerm>W3C File API is out of scope for this discussion, many browsers already support a subset of the standard, which allows files to be dragged into an application.</Para>
<FormalPara RenderingStyle="Style1"><Heading>n Note</Heading>
<Para>The W3C File API is documented online at <Literal>www.w3.org/TR/FileAPI</Literal>.</Para>
</FormalPara>
<Para>The File API contains functionality for asynchronously reading files in a web page, uploading them to servers while tracking process, and turning files into page elements. However, affiliated specifications such as drag-and-drop use a subset of the File API, and that is the area where we will focus our attention in this chapter.</Para>
<Para>Recall that we&#x2019;ve already alluded to file drag-and-drop twice in this chapter. First, the <IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>file handling</Secondary><Tertiary>dataTransfer object</Tertiary></IndexTerm>dataTransfer object contains a property named files, which will contain a list of files attached to the drag, if appropriate. For example, if a user drags a file or set of files in from the desktop into your application&#x2019;s web page, the browser will fire drag-and-drop events where the dataTransfer.files object has a value. Additionally, browsers that support the previously mentioned dropzone attribute allow files of specific MIME types to be valid drops on an element by using the f: MIME type prefix.</Para>
<FormalPara RenderingStyle="Style1"><Heading>n Note</Heading>
<Para>Currently, the Safari browser <Emphasis Type="Italic">only</Emphasis> supports drag-and-drop operations for files. Drags initiated inside a page will fire most drag-and-drop events, but drop events only occur if the type of drag is a file.</Para>
</FormalPara>
<Para>As usual, you cannot access the files during most drag-and-drop events, because they are protected for security reasons. Although some browsers might let you get access to the list of files during drag events, no browser will let you get access to the file data. In addition, the dragstart, drag, and dragend events that are fired at the drag source element are not triggered in a file drag-and-drop, as the source is the file system itself.</Para>
<Para>The file items<IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>file handling</Secondary><Tertiary>items</Tertiary></IndexTerm> in our file list support the following properties:<UnorderedList Mark="Bullet">
<ItemContent><Para><Emphasis Type="Bold">name</Emphasis>: The full filename with extension</Para></ItemContent>
<ItemContent><Para><Emphasis Type="Bold">type</Emphasis>: The MIME type of the file</Para></ItemContent>
<ItemContent><Para><Emphasis Type="Bold">size</Emphasis>: The size of the file in bytes</Para></ItemContent>
<ItemContent><Para><Emphasis Type="Bold">lastModifiedDate</Emphasis>: The timestamp for when the file contents were last modified</Para></ItemContent>
</UnorderedList>
</Para>
<Para>Let&#x2019;s walk through a simple example of file drag-and-drop where we will show the characteristics of any file dropped onto our page, shown in Figure <InternalRef RefID="Fig5_9">9-5</InternalRef>. This code is contained in the <IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>file handling</Secondary><Tertiary>fileDrag.html</Tertiary></IndexTerm>fileDrag.html example included with the book.
<Figure ID="Fig5_9" Float="Yes" Category="Standard">
<Caption Language="En">
<CaptionNumber>Figure 9-5</CaptionNumber>
<CaptionContent>
<SimplePara>Demo page displaying the characteristics <IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>file handling</Secondary><Tertiary>fileDrag.html</Tertiary></IndexTerm> of dropped files</SimplePara>
</CaptionContent>
</Caption>
<MediaObject ID="MO5_9">
<ImageObject FileRef="978-1-4302-3865-2_9_Fig5_HTML.gif" Format="GIF" Color="BlackWhite" Type="Linedraw" Rendition="HTML"/>
</MediaObject>
</Figure>
</Para>
<Para>The HTML for our demo is actually quite simple (see Listing 9-13).</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 9-13.</Heading>
<Para>Markup for File Drop Demo</Para>
</FormalPara>
<Para Type="Programcode">&#x003C;div id="droptarget"&#x003E;</Para>
<Para Type="Programcode">&#x003C;body&#x003E;</Para>
<Para Type="Programcode">&#x003C;div id="status"&#x003E;&#x003C;/div&#x003E;</Para>
<Para Type="Programcode">&#x003C;/div&#x003E;</Para>
<Para Type="Programcode">&#x003C;/body&#x003E;</Para>
<Para>We have only two elements in the page. A drop target where files will be dropped and a status display area.</Para>
<Para>As with our last example, we will register drag-and-drop event handlers during page load (see Listing 9-14).</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 9-14.</Heading>
<Para>Loading and Initialization <IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>file handling</Secondary><Tertiary>file drop demo</Tertiary></IndexTerm> Code for File Drop Demo</Para>
</FormalPara>
<Para Type="Programcode">    var droptarget;</Para>
<Para Type="Programcode">    // set the status text in our display</Para>
<Para Type="Programcode">    function setStatus(text) {</Para>
<Para Type="Programcode">        document.getElementById("status").innerHTML = text;</Para>
<Para Type="Programcode">    }</Para>
<Para Type="Programcode">    // &#x2026;</Para>
<Para Type="Programcode">    function loadDemo() {</Para>
<Para Type="Programcode">        droptarget = document.getElementById("droptarget");</Para>
<Para Type="Programcode">        droptarget.className = "validtarget";</Para>
<Para Type="Programcode">        droptarget.addEventListener("dragenter", handleDragEnter, false);</Para>
<Para Type="Programcode">        droptarget.addEventListener("dragover", handleDragOver, false);</Para>
<Para Type="Programcode">        droptarget.addEventListener("dragleave", handleDragLeave, false);</Para>
<Para Type="Programcode">        droptarget.addEventListener("drop", handleDrop, false);</Para>
<Para Type="Programcode">        setStatus("Drag files into this area.");</Para>
<Para Type="Programcode">    }</Para>
<Para Type="Programcode">    window.addEventListener("load", loadDemo, false);<IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>file handling</Secondary><Tertiary>file drop demo</Tertiary></IndexTerm></Para>
<Para>This time, the drop target receives all of the event handlers. Only a subset of handlers is needed, and we can ignore events that take place at the drag source.</Para>
<Para>When the user drags files into our drop target, we will display what we know about the drop candidates (see Listing 9-15).</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 9-15.</Heading>
<Para>File Drop Drag Enter Handler <IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>file handling</Secondary><Tertiary>file drop drag</Tertiary></IndexTerm>
</Para>
</FormalPara>
<Para Type="Programcode">    // handle drag events in the drop target</Para>
<Para Type="Programcode">    function handleDragEnter(evt) {</Para>
<Para Type="Programcode">        // if the browser supports accessing the file</Para>
<Para Type="Programcode">        // list during drag, we display the file count</Para>
<Para Type="Programcode">        var files = evt.dataTransfer.files;</Para>
<Para Type="Programcode">        if (files)</Para>
<Para Type="Programcode">            setStatus("There are " + evt.dataTransfer.files.length +</Para>
<Para Type="Programcode">                " files in this drag.");</Para>
<Para Type="Programcode">        else</Para>
<Para Type="Programcode">            setStatus("There are unknown items in this drag.");</Para>
<Para Type="Programcode">        droptarget.className = "highlighted";</Para>
<Para Type="Programcode">        evt.stopPropagation();</Para>
<Para Type="Programcode">        evt.preventDefault();</Para>
<Para Type="Programcode">        return false;</Para>
<Para Type="Programcode">    }</Para>
<Para>Although some browsers allow access to the dataTransfer files mid-drag, we will handle the case where that information is off-limits. When the count is known, we will display it in the status.</Para>
<Para>Handling dragover and dragleave events is straightforward (see Listing 9-16).</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 9-16.</Heading>
<Para>File Drop dragover and dragleave Handlers</Para>
</FormalPara>
<Para Type="Programcode">    // preventing the default dragover behavior</Para>
<Para Type="Programcode">    // is necessary for successful drops</Para>
<Para Type="Programcode">    function handleDragOver(evt) {</Para>
<Para Type="Programcode">        evt.stopPropagation();</Para>
<Para Type="Programcode">        evt.preventDefault();</Para>
<Para Type="Programcode">        return false;</Para>
<Para Type="Programcode">    }</Para>
<Para Type="Programcode">    // reset the text and status when drags leave</Para>
<Para Type="Programcode">    function handleDragLeave(evt) {</Para>
<Para Type="Programcode">        setStatus("Drag files into this area.");</Para>
<Para Type="Programcode">        droptarget.className = "validtarget";</Para>
<Para Type="Programcode">        return false;</Para>
<Para Type="Programcode">    }</Para>
<Para>As always, we must cancel<IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>file handling</Secondary><Tertiary>dragover and dragleave handler</Tertiary></IndexTerm> dragover events to allow drops to be handled by our own code rather than the browser&#x2019;s default behavior, which is usually to display them inline.</Para>
<Para>For a dragleave, we only set the status text and style to indicate that drops are no longer valid when the mouse leaves.</Para>
<Para>The bulk of our work is done in the drop handler (see Listing 9-17).</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 9-17.</Heading>
<Para>File Drop Handler</Para>
</FormalPara>
<Para Type="Programcode">    // handle the drop of files</Para>
<Para Type="Programcode">    function handleDrop(evt) {</Para>
<Para Type="Programcode">        // cancel the event to prevent viewing the file</Para>
<Para Type="Programcode">        evt.preventDefault();</Para>
<Para Type="Programcode">        evt.stopPropagation();</Para>
<Para Type="Programcode">        var filelist = evt.dataTransfer.files;</Para>
<Para Type="Programcode">        var message = "There were " + filelist.length + " files dropped.";</Para>
<Para Type="Programcode">        // show a detail list for each file in the drag</Para>
<Para Type="Programcode">        message += "&#x003C;ol&#x003E;";</Para>
<Para Type="Programcode">        [].forEach.call(filelist, function(file) {</Para>
<Para Type="Programcode">            message += "&#x003C;li&#x003E;";</Para>
<Para Type="Programcode">            message += "&#x003C;strong&#x003E;" + file.name + "&#x003C;/strong&#x003E; ";</Para>
<Para Type="Programcode">            message += "(&#x003C;em&#x003E;" + file.type + "&#x003C;/em&#x003E;) : ";</Para>
<Para Type="Programcode">            message += "size: " + file.size + " bytes - ";</Para>
<Para Type="Programcode">            message += "modified: " + file.lastModifiedDate;</Para>
<Para Type="Programcode">            message += "&#x003C;/li&#x003E;";</Para>
<Para Type="Programcode">        });</Para>
<Para Type="Programcode">        message += "&#x003C;/ol&#x003E;";</Para>
<Para Type="Programcode">        setStatus(message);</Para>
<Para Type="Programcode">        droptarget.className = "validtarget";</Para>
<Para Type="Programcode">        return false;</Para>
<Para Type="Programcode">    }</Para>
<Para>As discussed previously, it is necessary to cancel the event using preventDefault so that the browser&#x2019;s default drop code is never triggered.</Para>
<Para>Then, because we have more access to data in the drop handler than during the drag, we can inspect the files attached to the dataTransfer and discover the characteristics of the dropped files. In our example, we will merely display the properties of the files, but with full use of the HTML5 File API, you can read in the contents for local display or upload them to the server powering your application.</Para>
</Section1>
<Section1 ID="Sec13_9">
<Heading>Practical Extras</Heading>
<Para>Sometimes there are techniques that don&#x2019;t fit into our regular examples but which nonetheless apply to many types of HTML5 applications. We present to you a short, but common, practical extra here.</Para>
<Section2 ID="Sec14_9">
<Heading>Customizing the Drag Display<IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>dispaly customization</Secondary></IndexTerm></Heading>
<Para>Usually, the browser will default the visual cursor indicator for a drag operation. An image or link will move with the cursor (sometimes sized down for practical viewing), or a ghosted image of the dragged element will hover at the drag position.</Para>
<Para>However, if you need to change the default drag image display, the API provides you with a simple API for doing just that. It is only possible to change the drag image during the dragstart handler&#x2014;once again due to security concerns&#x2014;but you can do so easily by simply passing the element that represents the appearance of the cursor to the dataTransfer.</Para>
<Para Type="Programcode">        var dragImage = document.getElementById("happyTrails");</Para>
<Para Type="Programcode">        evt.dataTransfer.setDragImage(dragImage, 5, 10);</Para>
<Para>Note the offset coordinates passed to the setDragImage call. These x and y coordinates tell the browser which pixel inside the image to use as the point underneath the mouse cursor. For example, by passing in the values 5 and 10 for x and y, respectively, the image will be positioned such that the cursor is 5 pixels from the left and 10 pixels from the top, as shown in Figure <InternalRef RefID="Fig6_9">9-6</InternalRef>.
<Figure ID="Fig6_9" Float="Yes" Category="Standard">
<Caption Language="En">
<CaptionNumber>Figure 9-6</CaptionNumber>
<CaptionContent>
<SimplePara>Demo page with a drag image set to the Happy Trails logo</SimplePara>
</CaptionContent>
</Caption>
<MediaObject ID="MO6_9">
<ImageObject FileRef="978-1-4302-3865-2_9_Fig6_HTML.gif" Format="GIF" Color="BlackWhite" Type="Linedraw" Rendition="HTML"/>
</MediaObject>
</Figure>
</Para>
<Para>The drag image does not need to be an image, <IndexTerm><Primary>HTML5 drag-and-drop</Primary><Secondary>dispaly customization</Secondary></IndexTerm>however. Any element can be set as the drag image; if it is not an image, the browser will create a visual snapshot of it to serve as the cursor display.</Para>
</Section2>
</Section1>
<Section1 ID="Sec15_9">
<Heading>Summary</Heading>
<Para>The drag-and-drop API can be a tricky one to master. It involves the correct handling of many events, some of which may be hard to manage if your drop target layout is complex. However, if you are looking for drag operations that cross windows or browsers, or even interact with the desktop, you will need to learn the subtleties of the API. By design, it combines the power of native application drag-and-drop while still working inside the security restrictions of an environment where data must be protected from third-party code.</Para>
<Para>For more information on using dropped files as application data, make sure to check out the W3C File API. In the next chapter, we will examine the Web Workers API, which will allow you to spawn background scripts outside of your main page to speed up execution and improve the user experience.</Para>
</Section1>
</Body>
<BodyRef FileRef="978-1-4302-3865-2_9_Chapter_OnlinePDF.pdf" TargetType="OnlinePDF" PDFType="Typeset" OutputMedium="Online"/>
</Chapter>