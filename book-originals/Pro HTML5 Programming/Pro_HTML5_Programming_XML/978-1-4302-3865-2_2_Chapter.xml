<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE Chapter PUBLIC "-//Springer-Verlag//DTD A++ V2.4//EN" "http://devel.springer.de/A++/V2.4/DTD/A++V2.4.dtd">
<Chapter Language="En" OutputMedium="All" ID="Chap2_2">
<ChapterInfo Language="En" ChapterType="OriginalPaper" NumberingStyle="ChapterOnly" TocLevels="0" ContainsESM="No" OutputMedium="All">
<ChapterID>2</ChapterID>
<ChapterNumber>Chapter 2</ChapterNumber>
<ChapterDOI>10.1007/978-1-4302-3865-2_2</ChapterDOI>
<ChapterSequenceNumber>2</ChapterSequenceNumber>
<ChapterTitle Language="En">Using the Canvas API<IndexTerm><Primary>Canvas API</Primary></IndexTerm></ChapterTitle>
<ChapterFirstPage>1</ChapterFirstPage>
<ChapterLastPage>48</ChapterLastPage>
<ChapterCopyright>
<CopyrightHolderName>Peter Lubbers, Brian Albers, and Frank Salim</CopyrightHolderName>
<CopyrightYear>2011</CopyrightYear>
</ChapterCopyright>
<ChapterHistory>
<OnlineDate>
<Year><?InsertOnReleaseOF OFYear?></Year>
<Month><?InsertOnReleaseOF OFMonth?></Month>
<Day><?InsertOnReleaseOF OFDay?></Day>
</OnlineDate>
</ChapterHistory>
</ChapterInfo>
<ChapterHeader>
<AuthorGroup>
<Author AffiliationIDS="Aff1_2" CorrespondingAffiliationID="Aff1_2">
<AuthorName>
<GivenName>Peter</GivenName>
<FamilyName>Lubbers</FamilyName>
</AuthorName>
</Author>
<Author AffiliationIDS="Aff1_2">
<AuthorName>
<GivenName>Brian</GivenName>
<FamilyName>Albers</FamilyName>
</AuthorName>
</Author>
<Author AffiliationIDS="Aff1_2">
<AuthorName>
<GivenName>Frank</GivenName>
<FamilyName>Salim</FamilyName>
</AuthorName>
</Author>
<Affiliation ID="Aff1_2">
<OrgName>Technical Communication at Kaazing</OrgName>
<OrgAddress>
<City>San Francisco</City>
<State>CA</State>
<Country>USA</Country>
</OrgAddress>
</Affiliation>
</AuthorGroup>
<Abstract Language="En" OutputMedium="Online" ID="Abs1_2">
<Heading>Abstract</Heading>
<Para>In this chapter, we&#x2019;ll explore what you can do with the Canvas API&#x2014;a cool API that enables you to dynamically generate and render graphics, charts, images, and animation. We&#x2019;ll walk you through using the basics of the rendering API to create a drawing that can scale and adjust to the browser environment. We&#x2019;ll show you how to create dynamic pictures based on user input in a heatmap display. Of course, we&#x2019;ll also alert you to the pitfalls of using Canvas and share tricks to overcome them.</Para>
</Abstract>
</ChapterHeader>
<Body>
<Para>In this chapter, we&#x2019;ll explore what you can do with the Canvas API&#x2014;a cool API that enables you to dynamically generate and render graphics, charts, images, and animation. We&#x2019;ll walk you through using the basics of the rendering API to create a drawing that can scale and adjust to the browser environment. We&#x2019;ll show you how to create dynamic pictures based on user input in a heatmap display. Of course, we&#x2019;ll also alert you to the pitfalls of using Canvas and share tricks to overcome them.</Para>
<Para>This chapter presumes only a minimal amount of graphics expertise, so don&#x2019;t be afraid to jump in and try out one of the most powerful features of HTML5.</Para>
<Section1 ID="Sec2_2">
<Heading>Overview of HTML5 Canvas</Heading>
<Para>An entire book could be written about the use of the Canvas API<IndexTerm><Primary>Canvas API</Primary><Secondary>overview</Secondary></IndexTerm> (and it wouldn&#x2019;t be a small book). Because we have only a chapter, we&#x2019;re going to cover (what we think is) the most commonly used functionality in this very extensive API.</Para>
<Section2 ID="Sec3_2">
<Heading>History</Heading>
<Para>The canvas <IndexTerm><Primary>Canvas API</Primary><Secondary>concept of</Secondary></IndexTerm>concept was<IndexTerm><Primary>Canvas API</Primary><Secondary>history of</Secondary></IndexTerm> originally introduced by Apple to be used in Mac OS X WebKit to create<IndexTerm><Primary>dashboard widgets</Primary></IndexTerm> <Emphasis Type="Italic">dashboard widgets</Emphasis>. Before the arrival of canvas, you could only use drawing APIs in a browser through plug-ins such as Adobe plug-ins for Flash and Scalable Vector Graphics (SVG)<IndexTerm><Primary>Scalable Vector Graphics (SVG)</Primary></IndexTerm>, Vector Markup Language (VML)<IndexTerm><Primary>Vector Markup Language (VML)</Primary></IndexTerm> only in Internet Explorer, or other clever JavaScript hacks.</Para>
<Para>Try, for example, to draw a simple diagonal line without a <Literal>canvas</Literal> element&#x2014;it sounds easy, but it is a fairly complex task if you do not have a simple two-dimensional drawing API at your disposal. Canvas provides just that, and because it is an extremely useful thing to have in the browser, it was added to the HTML5 specification.</Para>
<Para>Early on, Apple hinted at possibly reserving the intellectual property rights in the WHATWG draft of the canvas specification, which caused concern at the time among some followers of web standardization. In the end, however, Apple disclosed the patents under the W3C's royalty-free patent licensing terms.</Para>
<FormalPara RenderingStyle="Style1">
<Heading>SVG versus Canvas</Heading>
<Para><Emphasis Type="Bold">Peter says</Emphasis>: &#x201C;Canvas is<IndexTerm><Primary>Scalable Vector Graphics (SVG)</Primary></IndexTerm><IndexTerm><Primary>Canvas API</Primary><Secondary>vs. SVG</Secondary></IndexTerm> essentially a <Emphasis Type="Italic">bitmap</Emphasis> canvas, and as such images that are drawn on a canvas are final and cannot be resized in the way that Scalable Vector Graphic (SVG) images can. Furthermore, objects drawn on a canvas are not part of the page&#x2019;s DOM or part of any namespace&#x2014;something that is considered a weakness if you need hit detection or object-based updates. SVG images, on the other hand can be scaled seamlessly at different resolutions and allow for hit detection (knowing precisely where an image is clicked)<IndexTerm><Primary>Canvas API</Primary><Secondary>overview</Secondary></IndexTerm>.</Para>
<Para>Why then, would the WHATWG HTML5 specification not use SVG exclusively? Despite its obvious shortcomings, the HTML5 Canvas API has two things going for it: it performs well because it does not have to store objects for every primitive it draws, and it is relatively easy to implement the Canvas API based on many of the popular two-dimensional drawing APIs found in other programming languages. Ultimately, it is better to have one bird in the hand than two in the bush.&#x201D;</Para>
</FormalPara>
</Section2>
<Section2 ID="Sec4_2">
<Heading>What Is a Canvas?</Heading>
<Para>When you use a <Literal>canvas</Literal> <IndexTerm><Primary>Canvas API</Primary><Secondary>about</Secondary></IndexTerm>element in your web page, it creates a rectangular area on the page. By default, this rectangular area is 300 pixels wide and 150 pixels high, but you can specify the exact size and set other attributes for your <Literal>canvas</Literal> element. Listing 2-1 shows the most basic <Literal>canvas</Literal> element that can be added to an HTML page.</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 2-1.</Heading>
<Para>A Basic Canvas Element</Para>
</FormalPara>
<Para Type="Programcode">&#x003C;canvas&#x003E; &#x003C;/canvas&#x003E;</Para>
<Para>Once you have added a <Literal>canvas</Literal> element to your page, you can use JavaScript to manipulate it any way you want. You can add graphics, lines, and text to it; you can draw on it; and you can even add advanced animations to it.</Para>
<Para>The Canvas API<IndexTerm><Primary>Canvas API</Primary><Secondary>drawing operations supported by</Secondary></IndexTerm> supports the same two-dimensional drawing operations that most modern operating systems and frameworks support. If you have ever programmed two-dimensional graphics in recent years, you will probably feel right at home with the Canvas API because it is designed to be similar to existing systems. If you haven&#x2019;t, you&#x2019;re about to discover how much more powerful a rendering system can be than the previous images and CSS tricks developers have used for years to create web graphics.</Para>
<Para>To programmatically use a canvas, you have to first get its <Emphasis Type="Italic">context</Emphasis>. You can then perform actions on the context and finally apply those actions to the context. <IndexTerm><Primary>Canvas API</Primary><Secondary>overview</Secondary></IndexTerm>You can think of making canvas modifications as similar to database transactions: you start a transaction, perform certain actions, and then commit the transaction.</Para>
</Section2>
<Section2 ID="Sec5_2">
<Heading>Canvas Coordinates</Heading>
<Para>As shown in Figure <InternalRef RefID="Fig1_2">2-1</InternalRef>, coordinates<IndexTerm><Primary>Canvas API</Primary><Secondary>coordinates</Secondary></IndexTerm> in a canvas start at <Literal>x=0,y=0</Literal> in the upper-left corner&#x2014;which we will refer to as the <Emphasis Type="Italic">origin</Emphasis>&#x2014;and increase (in pixels) horizontally over the x-axis and vertically over the y-axis.
<Figure ID="Fig1_2" Float="Yes" Category="Standard">
<Caption Language="En">
<CaptionNumber>Figure 2-1</CaptionNumber>
<CaptionContent>
<SimplePara>x and y<IndexTerm><Primary>Canvas API</Primary><Secondary>coordinates</Secondary></IndexTerm> coordinates on a canvas
</SimplePara>
</CaptionContent>
</Caption>
<MediaObject ID="MO1_2">
<ImageObject FileRef="978-1-4302-3865-2_2_Fig1_HTML.gif" Format="GIF" Color="Color" Type="Linedraw" Rendition="HTML"/>
</MediaObject>
</Figure>
</Para>
</Section2>
<Section2 ID="Sec6_2">
<Heading>When Not to Use Canvas</Heading>
<Para>Although the <Literal>canvas</Literal><IndexTerm><Primary>Canvas API</Primary><Secondary>when not to use</Secondary></IndexTerm> element is great and very useful, you should <Emphasis Type="Italic">not</Emphasis> use the <Literal>canvas</Literal> element when another element will suffice. For example, it would not be a good idea to dynamically draw all the different headings for an HTML document on a canvas instead of simply using heading styles (H1, H2, and so on) that are meant for that purpose.</Para>
</Section2>
<Section2 ID="Sec7_2">
<Heading>Fallback Content</Heading>
<Para>In case your web page is accessed by a<IndexTerm><Primary>Canvas API</Primary><Secondary>fallback content for</Secondary></IndexTerm><IndexTerm><Primary>Canvas API</Primary><Secondary>overview</Secondary></IndexTerm> browser that does not support the <Literal>canvas</Literal> element or a subset of the Canvas API features, it is a good idea to provide an alternate source. For example, you can provide an alternate image or just some text that explains what the user could be enjoying if they actually used a modern browser. Listing 2-2 shows how alternate text can be specified inside a <Literal>canvas</Literal> element. Browsers that do not support the <Literal>canvas</Literal> element will simply render this fallback content.</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 2-2.</Heading>
<Para>Use of Fallback Text Inside a Canvas Element</Para>
</FormalPara>
<Para Type="Programcode">&#x003C;canvas&#x003E;</Para>
<Para Type="Programcode">  Update your browser to enjoy canvas!</Para>
<Para Type="Programcode">&#x003C;/canvas&#x003E;</Para>
<Para>Instead of the previous text shown, you can also point to an image that can be displayed in case the browser does not support the <Literal>canvas</Literal> element.</Para>
<FormalPara RenderingStyle="Style1">
<Heading>What About Canvas Accessibility?</Heading>
<Para><Emphasis Type="Bold">Peter says</Emphasis>: &#x201C;Providing<IndexTerm><Primary>Canvas API</Primary><Secondary>accessibility issues</Secondary></IndexTerm> alternate images or alternate text raises the subject of <Emphasis Type="Italic">accessibility</Emphasis>&#x2014;an area in which the Canvas specification is, unfortunately, still lacking significantly. For example, there is no native method for inserting text alternatives for images that are being inserted into a canvas, and there is no native method to provide alternate text to match text generated with the canvas text API. At the time of this writing, there are no accessibility hooks that can be used with the dynamically generated content in a canvas, but a task force is working on designing them. Let&#x2019;s hope this improves with time.&#x201D;</Para>
</FormalPara>
<Para>One of the current proposals from the HTML5 designers for handling alternate, accessible canvas content is to use this fallback content section. However, in order for this to be useful for screen readers and other accessibility tools, the fallback content needs to be keyboard navigable even when a canvas is supported and displayed. While some browsers are supporting this capability now, you should not rely on it to support users with special needs. Using a separate section of the page to display canvas alternatives is recommended for now. As an added bonus, many users might enjoy using alternative controls or displays as a better way to quickly understand and navigate the page or application.<IndexTerm><Primary>Canvas API</Primary><Secondary>fallback content for</Secondary></IndexTerm>
</Para>
<Para>Future iterations of the Canvas API might also include focusable sub-areas of the canvas display and controls to interact with them. If your image display requires significant interaction, however, consider using Scalable Vector Graphics (SVG) as an alternative to the Canvas API. SVG also allows drawing, but it integrates with the browser DOM as well.</Para>
</Section2>
<Section2 ID="Sec8_2">
<Heading>CSS and Canvas</Heading>
<Para>As with most HTML elements, CSS<IndexTerm><Primary>Canvas API</Primary><Secondary>CSS</Secondary></IndexTerm> can be applied to the <Literal>canvas</Literal> element itself to add borders, padding, margins, etc. Additionally, some CSS values are inherited by the contents of the <Literal>canvas</Literal>; fonts are a good example, as fonts drawn into a <Literal>canvas</Literal> default to the settings of the <Literal>canvas</Literal> element itself.</Para>
<Para>Furthermore, properties set on the <Literal>context</Literal> used in <Literal>canvas</Literal> operations follow the syntax you may already be familiar with from CSS. Colors and fonts, for example, use the same notation on the <Literal>context</Literal> that they use throughout any HTML or CSS document.<IndexTerm><Primary>Canvas API</Primary><Secondary>CSS</Secondary></IndexTerm>
</Para>
</Section2>
<Section2 ID="Sec9_2">
<Heading>Browser Support for HTML5 Canvas</Heading>
<Para>With the arrival of Internet Explorer 9, all browser vendors now provide support for HTML5 Canvas, and it is already in the hands of a majority of users. This is a major milestone in web development, allowing 2D drawing to thrive on the modern Web.</Para>
<Para>In spite of the dwindling market share of previous versions of Internet Explorer, it is still a good idea to first test whether HTML5 Canvas is supported before you use the APIs. The section &#x201C;Checking for Browser Support&#x201D; later in this chapter will show you how you can programmatically check for<IndexTerm><Primary>Canvas API</Primary><Secondary>browser support for</Secondary></IndexTerm><IndexTerm><Primary>Canvas API</Primary><Secondary>overview</Secondary></IndexTerm> browser support.</Para>
</Section2>
</Section1>
<Section1 ID="Sec10_2">
<Heading>Using the HTML5 Canvas APIs</Heading>
<Para>In this section, we&#x2019;ll explore the use of the Canvas APIs in more detail. For the sake of illustration&#x2014;no pun intended&#x2014;we will use the various Canvas APIs to build a logo-like display of a forest scene with trees and a beautiful trail-running path suitable for a long-distance race event. Although our example will not win any awards for graphical design, it should serve to illustrate the various capabilities of HTML5 Canvas in a reasonable order.</Para>
<Section2 ID="Sec11_2">
<Heading>Checking for Browser Support</Heading>
<Para>Before you use the<IndexTerm><Primary>Canvas API</Primary><Secondary>browser support for</Secondary></IndexTerm> <Literal>canvas</Literal> element, you will want to make sure there is support in the browser. This way, you can provide some alternate text in case there is no support in their antique browser. Listing 2-3 shows one way you can use to test for browser support.</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 2-3.</Heading>
<Para>Checking for Browser Support</Para>
</FormalPara>
<Para Type="Programcode">try {</Para>
<Para Type="Programcode">  document.createElement(&#x201C;canvas&#x201D;).getContext(&#x201C;2d&#x201D;);</Para>
<Para Type="Programcode">  document.getElementById(&#x201C;support&#x201D;).innerHTML =</Para>
<Para Type="Programcode">    "HTML5 Canvas is supported in your browser.";</Para>
<Para Type="Programcode">} catch (e) {</Para>
<Para Type="Programcode">  document.getElementById(&#x201C;support&#x201D;).innerHTML = &#x201C;HTML5 Canvas is not supported&#x21B5;</Para>
<Para Type="Programcode">                                                  in your browser.&#x201D;;</Para>
<Para Type="Programcode">}</Para>
<Para>In this example, you try to create a canvas object and access its context. If there is an error, you will catch it and know that Canvas is not supported. A previously defined <Literal>support</Literal> element on the page is updated with a suitable message to reflect whether there is browser support or not.</Para>
<Para>This test will indicate whether the <Literal>canvas</Literal> element itself is supported by the browser. It will not indicate which capabilities of the Canvas are supported. At the time of this writing, the API is stable and well-supported, so this should generally not be an issue to worry about.</Para>
<Para>Additionally, it is a good idea<IndexTerm><Primary>Canvas API</Primary><Secondary>browser support for</Secondary></IndexTerm> to supply fallback content to your <Literal>canvas</Literal> element, as shown in Listing 2-3.</Para>
</Section2>
<Section2 ID="Sec12_2">
<Heading>Adding a Canvas to a Page</Heading>
<Para>Adding a <Literal>canvas</Literal> <IndexTerm><Primary>Canvas API</Primary><Secondary>adding a canvas to a page</Secondary></IndexTerm>element in an HTML page is pretty straight-forward. Listing 2-4 shows the <Literal>canvas</Literal> element that can be added to an HTML page.</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 2-4.</Heading>
<Para>The Canvas Element</Para>
</FormalPara>
<Para Type="Programcode">&#x003C;canvas height=&#x201C;200&#x201D; width="200"&#x003E; &#x003C;/canvas&#x003E;</Para>
<Para>The resulting canvas will show up as an &#x201C;invisible&#x201D; 200 &#x00D7; 200 pixel rectangle on your page. If you want to add a border around it, you could use the HTML code shown in Listing 2-5 to style the canvas with normal CSS borders.</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 2-5.</Heading>
<Para>Canvas Element with a Solid Border</Para>
</FormalPara>
<Para Type="Programcode">&#x003C;canvas id="diagonal" style="border: 1px solid;" width="200" height="200"&#x003E;</Para>
<Para Type="Programcode">&#x003C;/canvas&#x003E;</Para>
<Para>Note the addition of the ID <Literal>diagonal</Literal> to make it easy to locate this <Literal>canvas</Literal> element programmatically. An ID attribute<IndexTerm><Primary>ID attribute</Primary></IndexTerm><IndexTerm><Primary>Canvas API</Primary><Secondary>ID attribute</Secondary></IndexTerm> is crucial to any canvas because all the useful operations on this element must be done through scripting. Without an ID, you will have difficulty locating the element to interoperate with it.</Para>
<Para>Figure <InternalRef RefID="Fig2_2">2-2</InternalRef> shows what the canvas in Listing 2-5 would look like in a browser.
<Figure ID="Fig2_2" Float="Yes" Category="Standard">
<Caption Language="En">
<CaptionNumber>Figure 2-2</CaptionNumber>
<CaptionContent>
<SimplePara>A simple HTML5 canvas element on an HTML page</SimplePara>
</CaptionContent>
</Caption>
<MediaObject ID="MO2_2">
<ImageObject FileRef="978-1-4302-3865-2_2_Fig2_HTML.gif" Format="GIF" Color="BlackWhite" Type="Linedraw" Rendition="HTML"/>
</MediaObject>
</Figure>
</Para>
<Para>Not very exciting, but as any artist would tell you, it is full of potential. Now, let&#x2019;s do something with this pristine canvas. As mentioned before, it is not easy to draw a diagonal line on a web page without HTML5 Canvas. Let&#x2019;s see how easy it is now that we <Emphasis Type="Italic">can</Emphasis> use Canvas. Listing 2-6 shows how, with just a few lines of code, you can draw a diagonal line on the canvas<IndexTerm><Primary>diagonal line on a canvas</Primary></IndexTerm><IndexTerm><Primary>Canvas API</Primary><Secondary>creating diagonal line on</Secondary></IndexTerm> <IndexTerm><Primary>Canvas API</Primary><Secondary>adding a canvas to a page</Secondary></IndexTerm>we added to the page earlier.</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 2-6.</Heading>
<Para>Creating a Diagonal Line on a Canvas</Para>
</FormalPara>
<Para Type="Programcode">&#x003C;script&#x003E;</Para>
<Para Type="Programcode">  function drawDiagonal() {</Para>
<Para Type="Programcode">    // Get the canvas element and its drawing context</Para>
<Para Type="Programcode">    var canvas = document.getElementById('diagonal');</Para>
<Para Type="Programcode">    var context = canvas.getContext('2d');</Para>
<Para Type="Programcode">    // Create a path in absolute coordinates</Para>
<Para Type="Programcode">    context.beginPath();</Para>
<Para Type="Programcode">    context.moveTo(70, 140);</Para>
<Para Type="Programcode">    context.lineTo(140, 70);</Para>
<Para Type="Programcode">    // Stroke the line onto the canvas</Para>
<Para Type="Programcode">    context.stroke();</Para>
<Para Type="Programcode">  }</Para>
<Para Type="Programcode">   window.addEventListener("load", drawDiagonal, true);</Para>
<Para Type="Programcode">&#x003C;/script&#x003E;</Para>
<Para>Let&#x2019;s examine the JavaScript code used to create the diagonal line. It is a simple example, but it captures the essential flow of working with the Canvas API:</Para>
<Para>You first gain access to the canvas object by referencing a particular canvas&#x2019;s ID value. In this example, the ID is <Literal>diagonal</Literal>. Next, you create a context variable and you call the canvas object&#x2019;s <Literal>getContext</Literal> method, passing in the type of canvas you are looking for. You pass in the string &#x201C;<Literal>2d</Literal>&#x201D; to get a two-dimensional context<IndexTerm><Primary>two-dimensional context</Primary></IndexTerm>&#x2014;the only available context type at this time.</Para>
<FormalPara RenderingStyle="Style1"><Heading>n Note</Heading>
<Para>Much work has already been completed on a three-dimensional version of the Canvas context. Version 1.0 of the WebGL specification, a joint effort from browser vendors and the Khronos Group, was released in early 2011. WebGL is based on the same concepts and designs as the popular OpenGL library, bringing a similar API to JavaScript and HTML5. To create a three-dimensional drawing context in a supporting browser, you simply use the string " <Literal>webgl</Literal> " as the argument to <Literal>getContext</Literal>. The resulting context has an entirely new set of drawing APIs: capabilities that are thorough and complex enough for their own book. Although some browsers are shipping implementations of WebGL today, not all vendors are on board. However, the potential of three-dimensional rendering on the Web is compelling enough that we expect rapid uptake of support in the next few years. For more information, consult the WebGL site at the Khronos Group (<Literal>http://www.khronos.org/webgl</Literal>).</Para>
</FormalPara>
<Para>You then use the context to perform drawing operations. In this case, you can create the diagonal line by calling three methods&#x2014; <Literal>beginPath</Literal><IndexTerm><Primary>beginPath function</Primary></IndexTerm>, <Literal>moveTo</Literal><IndexTerm><Primary>moveTo function</Primary></IndexTerm>, and <Literal>lineTo</Literal><IndexTerm><Primary>lineTo function</Primary></IndexTerm>&#x2014;passing in the line&#x2019;s start and end coordinates.</Para>
<Para>The drawing methods <Literal>moveTo</Literal> and <Literal>lineTo</Literal> do not actually create the line; you finalize a canvas operation and draw the line by calling the<IndexTerm><Primary>diagonal line on a canvas</Primary></IndexTerm><IndexTerm><Primary>Canvas API</Primary><Secondary>creating diagonal line on</Secondary></IndexTerm> <IndexTerm><Primary>Canvas API</Primary><Secondary>adding a canvas to a page</Secondary></IndexTerm> <Literal>context.stroke();</Literal> method. Figure <InternalRef RefID="Fig3_2">2-3</InternalRef> shows the diagonal line created with the example code.
<Figure ID="Fig3_2" Float="Yes" Category="Standard">
<Caption Language="En">
<CaptionNumber>Figure 2-3</CaptionNumber>
<CaptionContent>
<SimplePara>Diagonal line on a canvas</SimplePara>
</CaptionContent>
</Caption>
<MediaObject ID="MO3_2">
<ImageObject FileRef="978-1-4302-3865-2_2_Fig3_HTML.gif" Format="GIF" Color="BlackWhite" Type="Linedraw" Rendition="HTML"/>
</MediaObject>
</Figure>
</Para>
<Para>Triumph! Although this simple line may not appear to be the start of a revolution, keep in mind that drawing a diagonal line between two arbitrary points using classic HTML techniques was a very difficult maneuver involving stretched images, strange CSS and DOM objects, or other forms of black magic. Let us never speak of them again.</Para>
<Para>As you can see from this example&#x2019;s code, all operations on the canvas are performed via the context object. This will hold true for the rest of your interaction with the canvas because all the important functions with visual output are accessible only from the context, not the canvas object itself. This flexibility allows the canvas to support different types of drawing models in the future, based on the type of context that is retrieved from the canvas. Although we will frequently refer in this chapter to actions we will take on the canvas, keep in mind that this actually means that we will be working with the context object that the canvas supplies.</Para>
<Para>As demonstrated in the previous example, many operations on the context do not immediately update the drawing surface. Functions such as <Literal>beginPath</Literal>, <Literal>moveTo</Literal>, and <Literal>lineTo</Literal> do not modify the canvas appearance immediately. The same is true of many functions that set the styling and preferences of the canvas. Only when a path is <Emphasis Type="Italic">stroked</Emphasis> or <Emphasis Type="Italic">filled</Emphasis> does it appear on the <IndexTerm><Primary>diagonal line on a canvas</Primary></IndexTerm><IndexTerm><Primary>Canvas API</Primary><Secondary>adding a canvas to a page</Secondary></IndexTerm>display. Otherwise, the canvas will only be immediately updated when images are displayed, text is shown, or rectangles are drawn, filled, or cleared.</Para>
</Section2>
<Section2 ID="Sec13_2">
<Heading>Applying Transformations to Drawings</Heading>
<Para>Now let&#x2019;s look at another way<IndexTerm><Primary>Canvas API</Primary><Secondary>applying transformations to drawings</Secondary></IndexTerm>to draw on the canvas using <Emphasis Type="Italic">transformation</Emphasis>. In the following example, the result is identical to the previous example, but the code used to draw the diagonal line is different. For this simple example, you could argue that the use of transformation adds unnecessary complexity. However, you can think of using transformation as a best practice for more complex canvas operations. You&#x2019;ll see that we&#x2019;ll use it a lot throughout the remaining examples, and it is critical to understanding the Canvas API&#x2019;s complex capabilities.</Para>
<Para>Perhaps the easiest way to think of the transformation system&#x2014;at least, the easiest way that does not involve a great amount of mathematical formulae and hand-waving&#x2014;is as a modification layer that sits between the commands you issue and the output on the canvas display. This modification layer is always present, even if you choose not to interact with it.</Para>
<Para>Modifications, or <Emphasis Type="Italic">transformations</Emphasis> in <IndexTerm><Primary>modifications</Primary></IndexTerm>the parlance of drawing systems, can be applied sequentially, combined, and modified at will. Every drawing operation is passed through the modification layer to be modified before it appears on the canvas. Although this adds an extra layer of complexity, it also adds tremendous power to the drawing system. It grants access to the powerful modifications that modern image-editing tools support in real time, yet in an API that is only as complex as it absolutely needs to be.</Para>
<Para>Don&#x2019;t be fooled into thinking that you are optimizing performance if you don&#x2019;t use transformation calls in your code. The canvas implementation uses and applies transformations implicitly in its rendering engine, whether or not you call them directly. It is wiser to understand the system up front because it will be crucial to know if you step outside the most basic drawing operations.</Para>
<Para>A key recommendation for <IndexTerm><Primary>Canvas API</Primary><Secondary>applying transformations to drawings</Secondary></IndexTerm>reusable code<IndexTerm><Primary>reusable code</Primary></IndexTerm> is that you usually want to <Emphasis Type="Italic">draw at the origin</Emphasis> (coordinate 0,0) and apply transformations&#x2014;scale, translate, rotate, and so forth&#x2014;to modify your drawing code into its final appearance, as shown in Figure <InternalRef RefID="Fig4_2">2-4</InternalRef>.
<Figure ID="Fig4_2" Float="Yes" Category="Standard">
<Caption Language="En">
<CaptionNumber>Figure 2-4</CaptionNumber>
<CaptionContent>
<SimplePara>Overview of transformation and drawing at the origin</SimplePara>
</CaptionContent>
</Caption>
<MediaObject ID="MO4_2">
<ImageObject FileRef="978-1-4302-3865-2_2_Fig4_HTML.gif" Format="GIF" Color="Color" Type="Linedraw" Rendition="HTML"/>
</MediaObject>
</Figure>
</Para>
<Para>Listing 2-7 shows this best practice in<IndexTerm><Primary>Canvas API</Primary><Secondary>applying transformations to drawings</Secondary></IndexTerm><IndexTerm><Primary>diagonal lines using translation</Primary></IndexTerm> action using the simplest transform: <Literal>translate</Literal>.</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 2-7.</Heading>
<Para>Using Translation to Create a Diagonal Line on a Canvas</Para>
</FormalPara>
<Para Type="Programcode">&#x003C;script&#x003E;</Para>
<Para Type="Programcode">  function drawDiagonal() {</Para>
<Para Type="Programcode">    var canvas = document.getElementById('diagonal');</Para>
<Para Type="Programcode">    var context = canvas.getContext('2d');</Para>
<Para Type="Programcode">    // Save a copy of the current drawing state</Para>
<Para Type="Programcode">    context.save();</Para>
<Para Type="Programcode">    // Move the drawing context to the right, and down</Para>
<Para Type="Programcode">    context.translate(70, 140);</Para>
<Para Type="Programcode">    // Draw the same line as before, but using the origin as a start</Para>
<Para Type="Programcode">    context.beginPath();</Para>
<Para Type="Programcode">    context.moveTo(0, 0);</Para>
<Para Type="Programcode">    context.lineTo(70, -70);</Para>
<Para Type="Programcode">    context.stroke();</Para>
<Para Type="Programcode">    // Restore the old drawing state</Para>
<Para Type="Programcode">    context.restore();</Para>
<Para Type="Programcode">  }</Para>
<Para Type="Programcode">  window.addEventListener("load", drawDiagonal, true);</Para>
<Para Type="Programcode">&#x003C;/script&#x003E;</Para>
<Para>Let&#x2019;s examine the JavaScript code used to create this second, translated diagonal line.<OrderedList>
<ListItem>
<ItemNumber>1.</ItemNumber>
<ItemContent><Para>First, you access the canvas object by referencing its ID value (in this case, diagonal).</Para></ItemContent>
</ListItem>
<ListItem>
<ItemNumber>2.</ItemNumber>
<ItemContent><Para>You then retrieve a context variable by calling the canvas object&#x2019;s getContext function<IndexTerm><Primary>getContext function</Primary></IndexTerm>.</Para></ItemContent>
</ListItem>
<ListItem>
<ItemNumber>3.</ItemNumber>
<ItemContent><Para>Next, you want to save the still unmodified context so you can get back to its original state at the end of the drawing and transformation operation. If you do not save the state, the modifications you&#x2019;re making during the operation (translate, scale, and so on) will continue to be applied to the context in future operations, and that might not be desirable. Saving the context state before transforming it will allow us to restore it later.<IndexTerm><Primary>diagonal lines using translation</Primary></IndexTerm>
</Para></ItemContent>
</ListItem>
<ListItem>
<ItemNumber>4.</ItemNumber>
<ItemContent><Para>The next step is to apply the translate method<IndexTerm><Primary>translate method</Primary></IndexTerm> to the context. With this operation, the translation coordinates you supply will be added to the eventual drawing coordinates (the diagonal line) at the time any drawing is rendered, thus moving the line to its final location, but only after the drawing operation is complete.</Para></ItemContent>
</ListItem>
<ListItem>
<ItemNumber>5.</ItemNumber>
<ItemContent><Para>After the translation has been applied, you can perform the normal drawing operations to create the diagonal line. In this case, you can create the diagonal line by calling three methods&#x2014;beginPath, moveTo, and lineTo&#x2014;this time drawing at the origin (0,0) instead of coordinates 70,140.</Para></ItemContent>
</ListItem>
<ListItem>
<ItemNumber>6.</ItemNumber>
<ItemContent><Para>After the line has been sketched, you can render it to the canvas (for example, draw the line) by calling the context.stroke method.</Para></ItemContent>
</ListItem>
<ListItem>
<ItemNumber>7.</ItemNumber>
<ItemContent><Para>Finally, you restore the context<IndexTerm><Primary>Canvas API</Primary><Secondary>applying transformations to drawings</Secondary></IndexTerm> to its clean original state, so that future canvas operations are performed without the translation that was applied in this operation. Figure <InternalRef RefID="Fig5_2">2-5</InternalRef> shows the diagonal line created with the example code.</Para></ItemContent>
</ListItem>
</OrderedList>
</Para>
<Para><Figure ID="Fig5_2" Float="Yes" Category="Standard">
<Caption Language="En">
<CaptionNumber>Figure 2-5</CaptionNumber>
<CaptionContent>
<SimplePara>Translated Diagonal Line on a Canvas</SimplePara>
</CaptionContent>
</Caption>
<MediaObject ID="MO5_2">
<ImageObject FileRef="978-1-4302-3865-2_2_Fig5_HTML.gif" Format="GIF" Color="BlackWhite" Type="Linedraw" Rendition="HTML"/>
</MediaObject>
</Figure>
</Para>
<Para>Even though your new line looks remarkably like the old one, you created it using the power of transformations, something that will become more <IndexTerm><Primary>Canvas API</Primary><Secondary>applying transformations to drawings</Secondary></IndexTerm><IndexTerm><Primary>diagonal lines using translation</Primary></IndexTerm>apparent as we progress through the rest of this chapter.</Para>
</Section2>
<Section2 ID="Sec14_2">
<Heading>Working with Paths</Heading>
<Para>Although we could offer <IndexTerm><Primary>paths, working with</Primary></IndexTerm><IndexTerm><Primary>Canvas API</Primary><Secondary>paths, working with</Secondary></IndexTerm>many more exciting examples for drawing lines, we are ready now to progress to something a bit more complex: <Emphasis Type="Italic">paths</Emphasis>. Paths in the HTML5 Canvas API represent any shape you care to render. Our original line example was a path, as you might have gathered from the conspicuous <Literal>beginPath</Literal> call used to start it off. But paths can be as complicated as you desire, with multiple line and curve segments and even subpaths. If you are looking to draw almost any shape on a canvas, the path API will be your focus point.</Para>
<Para>When embarking on any routine to draw a shape or path, the first call you make is <Literal>beginPath</Literal><IndexTerm><Primary>beginPath function</Primary></IndexTerm>. This simple function takes no arguments, but it signals to the canvas that you wish to start a new shape description. This function is mostly useful to the canvas so that it can calculate the interior and exterior of the shape you are creating for later fills and strokes.</Para>
<Para>A path always tracks the concept of a current location, which defaults to the origin. The canvas internally tracks the current location, but you will modify it with your drawing routines.</Para>
<Para>Once the shape is begun, you can use a variety of functions on the context to plot the layout of your shape. You&#x2019;ve already seen the simplest context pathing functions in action:<UnorderedList Mark="Bullet">
<ItemContent><Para><Literal>moveTo(x, y)</Literal><IndexTerm><Primary>moveTo(x, y) function</Primary></IndexTerm>: moves the current location to a new destination of (x, y) without drawing.</Para></ItemContent>
<ItemContent><Para><Literal>lineTo(x, y)</Literal><IndexTerm><Primary>lineTo(x, y) function</Primary></IndexTerm>: moves the current location to a new destination of (x, y) drawing a straight line from the current position to the new one.</Para></ItemContent>
</UnorderedList>
</Para>
<Para>Essentially, the difference between these two calls is that the first is akin to lifting a drawing pen and moving to a new location, whereas the second tells the canvas to leave the pen on the paper and move it in a straight line to the new destination. However, it is worth pointing out again that <Emphasis Type="Italic">no actual drawing occurs until you stroke or fill the path</Emphasis>. At present, we are merely defining the positions in our path so that it can be drawn later.</Para>
<Para>The next special pathing function is a call to <Literal>closePath</Literal><IndexTerm><Primary>closePath function</Primary></IndexTerm>. This command is very similar in behavior to the <Literal>lineTo</Literal> function<IndexTerm><Primary>lineTo function</Primary></IndexTerm>, with the difference being that the destination is automatically assumed to be the origination of the path. However, the <Literal>closePath</Literal> also informs the canvas that the current shape has closed or formed a completely contained area. This will be useful for future fills and strokes.</Para>
<Para>At this point, you are free to continue with more segments in your path to create additional subpaths. Or you can <Literal>beginPath</Literal> at any time to start over and clear the path list entirely.</Para>
<Para>As with most complex systems, it is often better to see them in action. Let&#x2019;s depart from our line examples and use the Canvas API to start to create a new scene that illustrates a forest with a trail-running path. This scene will serve as a logo of sorts for our race <IndexTerm><Primary>Canvas API</Primary><Secondary>paths, working with</Secondary></IndexTerm><IndexTerm><Primary>paths, working with</Primary></IndexTerm>event. And as with any picture, we will start with a basic element, which in this case is the canopy of a simple pine tree. Listing 2-8 shows how to draw the pine tree&#x2019;s canopy.</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 2-8.</Heading>
<Para>Function That Creates a Path for a Tree Canopy</Para>
</FormalPara>
<Para Type="Programcode">function createCanopyPath(context) {</Para>
<Para Type="Programcode">  // Draw the tree canopy</Para>
<Para Type="Programcode">  context.beginPath();</Para>
<Para Type="Programcode">  context.moveTo(-25, -50);</Para>
<Para Type="Programcode">  context.lineTo(-10, -80);</Para>
<Para Type="Programcode">  context.lineTo(-20, -80);</Para>
<Para Type="Programcode">  context.lineTo(-5, -110);</Para>
<Para Type="Programcode">  context.lineTo(-15, -110);</Para>
<Para Type="Programcode">  // Top of the tree</Para>
<Para Type="Programcode">  context.lineTo(0, -140);</Para>
<Para Type="Programcode">  context.lineTo(15, -110);</Para>
<Para Type="Programcode">  context.lineTo(5, -110);</Para>
<Para Type="Programcode">  context.lineTo(20, -80);</Para>
<Para Type="Programcode">  context.lineTo(10, -80);</Para>
<Para Type="Programcode">  context.lineTo(25, -50);</Para>
<Para Type="Programcode">  // Close the path back to its start point</Para>
<Para Type="Programcode">  context.closePath();</Para>
<Para Type="Programcode">}</Para>
<Para>As you can see from the code, we used the same move and line commands from before, but more of them. These lines form the branches of a simple tree shape, and we close the path back at the end. Our tree will leave a notable gap at the bottom, and we will use this in future sections to draw the trunk. Listing 2-9 shows how to use that canopy drawing function to actually render our simple tree shape onto a canvas.</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 2-9.</Heading>
<Para>Function That Draws a Tree on the Canvas</Para>
</FormalPara>
<Para Type="Programcode">function drawTrails() {</Para>
<Para Type="Programcode">  var canvas = document.getElementById('trails');</Para>
<Para Type="Programcode">  var context = canvas.getContext('2d');</Para>
<Para Type="Programcode">  context.save();</Para>
<Para Type="Programcode">  context.translate(130, 250);</Para>
<Para Type="Programcode">  // Create the shape for our canopy path</Para>
<Para Type="Programcode">  createCanopyPath(context);</Para>
<Para Type="Programcode">  // Stroke the current path</Para>
<Para Type="Programcode">  context.stroke();</Para>
<Para Type="Programcode">  context.restore();</Para>
<Para Type="Programcode">}</Para>
<Para>All the calls in this routine should be <IndexTerm><Primary>Canvas API</Primary><Secondary>paths, working with</Secondary></IndexTerm><IndexTerm><Primary>paths, working with</Primary></IndexTerm>familiar to you already. We fetch the canvas context, save it for future reference, translate our position to a new location, draw the canopy, stroke it onto the canvas, and then restore our state. Figure <InternalRef RefID="Fig6_2">2-6</InternalRef> shows the results of our handiwork, a simply line representation of a tree canopy. We&#x2019;ll expand on this as we go forward, but it&#x2019;s a good first step.
<Figure ID="Fig6_2" Float="Yes" Category="Standard">
<Caption Language="En">
<CaptionNumber>Figure 2-6</CaptionNumber>
<CaptionContent>
<SimplePara>A simple path of a tree canopy</SimplePara>
</CaptionContent>
</Caption>
<MediaObject ID="MO6_2">
<ImageObject FileRef="978-1-4302-3865-2_2_Fig6_HTML.gif" Format="GIF" Color="BlackWhite" Type="Linedraw" Rendition="HTML"/>
</MediaObject>
</Figure>
</Para>
</Section2>
<Section2 ID="Sec15_2">
<Heading>Working with Stroke Styles</Heading>
<Para>The Canvas API<IndexTerm><Primary>Canvas API</Primary><Secondary>using stroke styles</Secondary></IndexTerm><IndexTerm><Primary>stroke styles</Primary></IndexTerm> wouldn&#x2019;t be powerful or popular if developers were stuck using simple stick drawings and black lines. Let&#x2019;s use the stroke styling capabilities to make our canopy a little more tree-like. Listing 2-10 shows some basic commands that can modify the properties of the context in order to make the stroked shape look more appealing.</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 2-10.</Heading>
<Para>Using a Stroke Style</Para>
</FormalPara>
<Para Type="Programcode">// Increase the line width</Para>
<Para Type="Programcode">context.lineWidth = 4;</Para>
<Para Type="Programcode">// Round the corners at path joints</Para>
<Para Type="Programcode">context.lineJoin = 'round';</Para>
<Para Type="Programcode">// Change the color to brown</Para>
<Para Type="Programcode">context.strokeStyle = '#663300';</Para>
<Para Type="Programcode">// Finally, stroke the canopy</Para>
<Para Type="Programcode">context.stroke();</Para>
<Para>By adding the above properties before stroking, we change the appearance of any future stroked shapes&#x2014;at least until we restore the context back to a previous state.</Para>
<Para>First, we increase the width of the stroked lines to four pixels.</Para>
<Para>Next, we set the <Literal>lineJoin</Literal> property to <Literal>round</Literal>, which causes the joints of our shape&#x2019;s segments to take on a more rounded corner shape. We could also set the <Literal>lineJoin</Literal> to <Literal>bevel</Literal> or <Literal>miter</Literal> (and the corresponding <Literal>context.miterLimit</Literal> value to tweak it) to choose other corner options.</Para>
<Para>Finally, we change the color of the stroke by using the <Literal>strokeStyle</Literal> property. In our example, we are setting the color to a CSS value, but as you will see in later sections, it is also possible to set the <Literal>strokeStyle</Literal> to be an image pattern or a gradient for fancier displays.</Para>
<Para>Although we are not using it here, we could also set the <Literal>lineCap</Literal> property<IndexTerm><Primary>lineCap property</Primary></IndexTerm> to be either <Literal>butt</Literal>, <Literal>square</Literal>, or <Literal>round</Literal> to specify how lines should display at the endpoints. Alas, our example has no dangling line ends. Figure <InternalRef RefID="Fig7_2">2-7</InternalRef> shows our spruced-up tree canopy, now<IndexTerm><Primary>Canvas API</Primary><Secondary>using stroke styles</Secondary></IndexTerm><IndexTerm><Primary>stroke styles</Primary></IndexTerm>stroked with a wider, smoother, brown line instead of the flat black line from before.
<Figure ID="Fig7_2" Float="Yes" Category="Standard">
<Caption Language="En">
<CaptionNumber>Figure 2-7</CaptionNumber>
<CaptionContent>
<SimplePara>Stylish stroked tree canopy</SimplePara>
</CaptionContent>
</Caption>
<MediaObject ID="MO7_2">
<ImageObject FileRef="978-1-4302-3865-2_2_Fig7_HTML.gif" Format="GIF" Color="Color" Type="Linedraw" Rendition="HTML"/>
</MediaObject>
</Figure>
</Para>
</Section2>
<Section2 ID="Sec16_2">
<Heading>Working with Fill Styles</Heading>
<Para>As you might expect, <IndexTerm><Primary>fill styles</Primary></IndexTerm><IndexTerm><Primary>Canvas API</Primary><Secondary>using fill styles</Secondary></IndexTerm>stroking is not the only way to affect the appearance of canvas shapes. The next common way to modify a shape is to specify how its paths and subpaths are filled. Listing 2-11 shows how simple it is to fill our canopy with a pleasant, green color.</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 2-11.</Heading>
<Para>Using a Fill Style</Para>
</FormalPara>
<Para Type="Programcode">// Set the fill color to green and fill the canopy</Para>
<Para Type="Programcode">context.fillStyle = '#339900';</Para>
<Para Type="Programcode">context.fill();</Para>
<Para>First, we set the <Literal>fillStyle</Literal> to the appropriate color. As we will see later, it is also possible to set the fill to be a gradient or an image pattern. Then, we simply call the context&#x2019;s <Literal>fill</Literal> function to let the canvas fill all the pixels inside all the closed paths of our current shape, as shown in Figure <InternalRef RefID="Fig8_2">2-8</InternalRef>.
<Figure ID="Fig8_2" Float="Yes" Category="Standard">
<Caption Language="En">
<CaptionNumber>Figure 2-8</CaptionNumber>
<CaptionContent>
<SimplePara>Filled tree canopy</SimplePara>
</CaptionContent>
</Caption>
<MediaObject ID="MO8_2">
<ImageObject FileRef="978-1-4302-3865-2_2_Fig8_HTML.gif" Format="GIF" Color="Color" Type="Linedraw" Rendition="HTML"/>
</MediaObject>
</Figure>
</Para>
<Para>Because we stroked our canopy before filling it, the fill covers part of the stroked path. This is due to the fact that the wide stroke&#x2014;in our case, four pixels wide&#x2014;is centered along the line of the path shape. The fill applies to all pixels on the interior of the shape, and as such it will cover half of the stroked line pixels. Should you prefer the full stroke to appear, you can simply fill <Emphasis Type="Italic">before</Emphasis> <IndexTerm><Primary>fill styles</Primary></IndexTerm><IndexTerm><Primary>Canvas API</Primary><Secondary>using fill styles</Secondary></IndexTerm>stroking the path.</Para>
</Section2>
<Section2 ID="Sec17_2">
<Heading>Filling Rectangular Content</Heading>
<Para>Every tree deserves a strong foundation. Thankfully, we left space for our tree trunk in the original shape path. Listing 2-12 shows how we can add the simplest rendering of a tree trunk by using the <Literal>fillRect</Literal> convenience function<IndexTerm><Primary>fillRect convenience function</Primary></IndexTerm>.</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 2-12.</Heading>
<Para>Using the fillRect Convenience Function</Para>
</FormalPara>
<Para Type="Programcode">// Change fill color to brown</Para>
<Para Type="Programcode">context.fillStyle = '#663300';</Para>
<Para Type="Programcode">// Fill a rectangle for the tree trunk</Para>
<Para Type="Programcode">context.fillRect(-5, -50, 10, 50);</Para>
<Para>Here, we once again set a brown fill style. But instead of explicitly drawing the corners of our trunk rectangle using the <Literal>lineTo</Literal> ability, we will draw the entire trunk in one step by using <Literal>fillRect</Literal>. The <Literal>fillRect</Literal> call takes the x and y location, as well as the width and height, and then immediately fills it with the current fill style.</Para>
<Para>Although we are not using them here, corresponding functions exist to <Literal>strokeRect</Literal> and <Literal>clearRect</Literal>. The former will draw the outline of the rectangle based on a given position and dimension, while the latter will remove any content from the rectangular area and reset it to <IndexTerm><Primary>fill styles</Primary></IndexTerm><IndexTerm><Primary>Canvas API</Primary><Secondary>using fill styles</Secondary></IndexTerm>its original, transparent color.</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Canvas animations</Heading>
<Para><Emphasis Type="Bold">Brian says</Emphasis>: &#x201C;The ability to<IndexTerm><Primary>Canvas API</Primary><Secondary>animations</Secondary></IndexTerm><IndexTerm><Primary>animation, canvas</Primary></IndexTerm> clear rectangles in the canvas is core to creating animations and games using the Canvas API. By repeatedly drawing and clearing sections of the canvas, it is possible to present the illusion of animation, and many examples of this already exist on the Web. However, to create animations that perform smoothly, you will need to utilize <Emphasis Type="Italic">clipping</Emphasis> features <IndexTerm><Primary>clipping features</Primary></IndexTerm>and perhaps even a secondary buffered canvas to minimize the flickering caused by frequent canvas clears. Although animations are not the focus of this book, check out the &#x2018;Practical Extra&#x2019; sections of this chapter for some tips on using HTML5 to animate your pages.&#x201D;</Para>
</FormalPara>
<Para>Figure <InternalRef RefID="Fig9_2">2-9</InternalRef> shows our simple, flatly filled <IndexTerm><Primary>fillRect convenience function</Primary></IndexTerm>tree trunk attached to our previous canopy path.
<Figure ID="Fig9_2" Float="Yes" Category="Standard">
<Caption Language="En">
<CaptionNumber>Figure 2-9</CaptionNumber>
<CaptionContent>
<SimplePara>
Tree with filled <IndexTerm><Primary>fill styles</Primary></IndexTerm><IndexTerm><Primary>Canvas API</Primary><Secondary>using fill styles</Secondary></IndexTerm>rectangular trunk</SimplePara>
</CaptionContent>
</Caption>
<MediaObject ID="MO9_2">
<ImageObject FileRef="978-1-4302-3865-2_2_Fig9_HTML.gif" Format="GIF" Color="Color" Type="Linedraw" Rendition="HTML"/>
</MediaObject>
</Figure>
</Para>
</Section2>
<Section2 ID="Sec18_2">
<Heading>Drawing Curves</Heading>
<Para>The world, particularly the<IndexTerm><Primary>Canvas API</Primary><Secondary>drawing curves</Secondary></IndexTerm> natural world, is not filled with straight lines and rectangles. Fortunately, the canvas provides a variety of functions for creating curves in our paths. We will demonstrate the simplest option&#x2014;a <Emphasis Type="Italic">quadratic</Emphasis> curve&#x2014;to form a path through our virtual forest. Listing 2-13 demonstrates the addition of two quadratic curves<IndexTerm><Primary>quadratic curves</Primary></IndexTerm>.</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 2-13.</Heading>
<Para>Drawing a Curve</Para>
</FormalPara>
<Para Type="Programcode">// Save the canvas state and draw the path</Para>
<Para Type="Programcode">context.save();</Para>
<Para Type="Programcode">context.translate(-10, 350);</Para>
<Para Type="Programcode">context.beginPath();</Para>
<Para Type="Programcode">// The first curve bends up and right</Para>
<Para Type="Programcode">context.moveTo(0, 0);</Para>
<Para Type="Programcode">context.quadraticCurveTo(170, -50, 260, -190);</Para>
<Para Type="Programcode">// The second curve continues down and right</Para>
<Para Type="Programcode">context.quadraticCurveTo(310, -250, 410,-250);</Para>
<Para Type="Programcode">// Draw the path in a wide brown stroke</Para>
<Para Type="Programcode">context.strokeStyle = '#663300';</Para>
<Para Type="Programcode">context.lineWidth = 20;</Para>
<Para Type="Programcode">context.stroke();</Para>
<Para Type="Programcode">// Restore the previous canvas state</Para>
<Para Type="Programcode">context.restore();</Para>
<Para>As before, one of the first things we will do is save our canvas context state, because we will be modifying the translation and stroke options here. For our forest path, we will start by moving back to the origin and drawing a first quadratic curve up and to the right.</Para>
<Para>As shown in Figure <InternalRef RefID="Fig10_2">2-10</InternalRef>, the <Literal>quadraticCurveTo</Literal> function<IndexTerm><Primary>quadraticCurveTo function</Primary></IndexTerm> begins at the current drawing location and takes two x, y point locations as its parameters. The second one is the final stop in our curve. The first one represents<IndexTerm><Primary>control points</Primary></IndexTerm> a <Emphasis Type="Italic">control point</Emphasis>. The control point sits to the side of the curve (not on it) and acts almost as a gravitational pull for the points along the curve path. By adjusting the location of the control point, you can adjust the curvature of the path you are drawing. We draw a <IndexTerm><Primary>Canvas API</Primary><Secondary>drawing curves</Secondary></IndexTerm>second quadratic curve up and to the right to complete our path; then stroke it just as we did for our tree canopy before (only wider).
<Figure ID="Fig10_2" Float="Yes" Category="Standard">
<Caption Language="En">
<CaptionNumber>Figure 2-10</CaptionNumber>
<CaptionContent>
<SimplePara>Quadratic curve start, end, and control points<!--<query ID="Q1_2"><query_paragraph>The word Y-Axis should be turned 180 degrees, as it is in the figure 1.</query_paragraph></query>--></SimplePara>
</CaptionContent>
</Caption>
<MediaObject ID="MO10_2">
<ImageObject FileRef="978-1-4302-3865-2_2_Fig10_HTML.gif" Format="GIF" Color="Color" Type="Linedraw" Rendition="HTML"/>
</MediaObject>
</Figure>
</Para>
<Para>Other options for curves in the HTML5 Canvas API include the <Literal>bezierCurveTo</Literal><IndexTerm><Primary>bezierCurveTo function</Primary></IndexTerm>, <Literal>arcTo</Literal><IndexTerm><Primary>arcTo function</Primary></IndexTerm>, and<IndexTerm><Primary>arc function</Primary></IndexTerm> <Literal>arc</Literal> functions. These curves take additional control points, a radius, or angles to determine the characteristics of the curve. Figure <InternalRef RefID="Fig11_2">2-11</InternalRef> shows the two <IndexTerm><Primary>Canvas API</Primary><Secondary>drawing curves</Secondary></IndexTerm>quadratic curves<IndexTerm><Primary>quadratic curves</Primary></IndexTerm> stroked on our canvas to create a path through the trees.
<Figure ID="Fig11_2" Float="Yes" Category="Standard">
<Caption Language="En">
<CaptionNumber>Figure 2-11</CaptionNumber>
<CaptionContent>
<SimplePara>Quadratic curves for a path</SimplePara>
</CaptionContent>
</Caption>
<MediaObject ID="MO11_2">
<ImageObject FileRef="978-1-4302-3865-2_2_Fig11_HTML.gif" Format="GIF" Color="Color" Type="Linedraw" Rendition="HTML"/>
</MediaObject>
</Figure>
</Para>
</Section2>
<Section2 ID="Sec19_2">
<Heading>Inserting Images into a Canvas</Heading>
<Para>Images can be extremely handy<IndexTerm><Primary>images inserting into a canvas</Primary></IndexTerm><IndexTerm><Primary>Canvas API</Primary><Secondary>inserting images</Secondary></IndexTerm> to display inside a canvas. They can be stamped, stretched, modified with transformations, and often be the focus of the entire canvas. Thankfully, the Canvas API includes a few simple commands for adding image content to the canvas.</Para>
<Para>But images also add a complication to the canvas operations: you must wait for them to load. Browsers will usually be loading images asynchronously as your page script is rendering. However, if you attempt to render an image onto a canvas before it has completely loaded, the canvas will fail to render any image at all. As such, you should be careful to make sure the image is loaded completely before you attempt to render it.</Para>
<Para>To solve this problem in our simple forest trail example, we will load an image of a bark texture to use directly in the canvas. In order to make sure that the image has completed loading before we render, we will switch the loading code to only execute as a callback from image loading completion, as shown in Listing 2-14.</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 2-14.</Heading>
<Para>Loading the Image</Para>
</FormalPara>
<Para Type="Programcode">// Load the bark image</Para>
<Para Type="Programcode">var bark = new Image();</Para>
<Para Type="Programcode">bark.src = "bark.jpg";</Para>
<Para Type="Programcode">// Once the image is loaded, draw on the canvas</Para>
<Para Type="Programcode">bark.onload = function () {</Para>
<Para Type="Programcode">  drawTrails();</Para>
<Para Type="Programcode">}</Para>
<Para>As you can see, we&#x2019;ve added an <Literal>onload</Literal> handler<IndexTerm><Primary>onload handler</Primary></IndexTerm> to the <Literal>bark.jpg</Literal> image to call the main <Literal>drawTrails</Literal> function only when the image loading has completed. This guarantees that the image will be available to the next calls we add to the canvas rendering, as shown in Listing 2-15.</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 2-15.</Heading>
<Para>Drawing an Image on a Canvas <IndexTerm><Primary>images inserting into a canvas</Primary></IndexTerm><IndexTerm><Primary>Canvas API</Primary><Secondary>inserting images</Secondary></IndexTerm>
</Para>
</FormalPara>
<Para Type="Programcode">// Draw the bark pattern image where</Para>
<Para Type="Programcode">//  the filled rectangle was before</Para>
<Para Type="Programcode">context.drawImage(bark, -5, -50, 10, 50);</Para>
<Para>Here, we have replaced the previous call to <Literal>fillRect</Literal> with a simple routine to display our bark image as the new trunk for our tree. Although the image is a subtle replacement, it provides more texture to our display. Note that in this call, we are specifying an x, y, width, and height argument in addition to the image itself. This option will scale the image to fit into the 10 &#x00D7; 50 pixel space that we have allocated for our trunk. We could also have passed in source dimensions to have more control over the clipping area of the incoming image to be displayed.</Para>
<Para>As you can see in Figure <InternalRef RefID="Fig12_2">2-12</InternalRef>, the change to the appearance of our trunk is only slightly different from the filled rectangle we used before.
<Figure ID="Fig12_2" Float="Yes" Category="Standard">
<Caption Language="En">
<CaptionNumber>Figure 2-12</CaptionNumber>
<CaptionContent>
<SimplePara>Tree with an image <IndexTerm><Primary>images inserting into a canvas</Primary></IndexTerm><IndexTerm><Primary>Canvas API</Primary><Secondary>inserting images</Secondary></IndexTerm> used for trunk</SimplePara>
</CaptionContent>
</Caption>
<MediaObject ID="MO12_2">
<ImageObject FileRef="978-1-4302-3865-2_2_Fig12_HTML.gif" Format="GIF" Color="Color" Type="Linedraw" Rendition="HTML"/>
</MediaObject>
</Figure>
</Para>
</Section2>
<Section2 ID="Sec20_2">
<Heading>Using Gradients</Heading>
<Para>Not satisfied with the<IndexTerm><Primary>gradients</Primary></IndexTerm><IndexTerm><Primary>Canvas API</Primary><Secondary>gradients</Secondary></IndexTerm> tree trunk? Well, neither are we. Let&#x2019;s take another approach to drawing our tree trunk that uses a little more finesse: gradients. Gradients allow you to apply a gradual algorithmic sampling of colors as either a stroke or fill style, just like the patterns were applied in the last section. Creating gradients requires a three-step process:<OrderedList>
<ListItem>
<ItemNumber>1.</ItemNumber>
<ItemContent><Para>Create the gradient object itself.</Para></ItemContent>
</ListItem>
<ListItem>
<ItemNumber>2.</ItemNumber>
<ItemContent><Para>Apply color stops to the gradient object, signaling changes in color along the transition.</Para></ItemContent>
</ListItem>
<ListItem>
<ItemNumber>3.</ItemNumber>
<ItemContent><Para>Set the gradient as either a fillStyle or a strokeStyle on the context.</Para></ItemContent>
</ListItem>
</OrderedList>
</Para>
<Para>It is perhaps easiest to think of gradients as a smooth change of color that moves along a line. For example, if you supply points A and B as the arguments to the creation of a gradient, the color will be transitioned for any stroke or fill that moves in the direction of point A to point B.</Para>
<Para>To determine what colors are displayed, simply use the <Literal>addColorStop</Literal> function<IndexTerm><Primary>addColorStop function</Primary></IndexTerm> on the gradient object itself. This function allows you to specify an offset and a color. The color argument is the color you want to be applied in the stroke or fill at the offset position. The offset position is a value between 0.0 and 1.0, representing how far along the gradient line the color should be reached.</Para>
<Para>If you create a gradient from point (0,0) to point (0,100) and specify a white color stop at offset 0.0 and a black offset at offset 1.0, then when the stroke or fill occurs, you will see the color gradually shift from white (the beginning color stop) to black (the end color stop) as the rendering moves from point (0,0) to point (0,100).</Para>
<Para>As with other color values, it is possible to supply an alpha (for example, transparency) value as part of the color and make that alpha value transition as well. To do so, you will need to use another textual representation of the color value, such as the CSS <Literal>rgba</Literal> function that includes an alpha component.</Para>
<Para>Let&#x2019;s see this in more detail <IndexTerm><Primary>gradients</Primary></IndexTerm><IndexTerm><Primary>Canvas API</Primary><Secondary>gradients</Secondary></IndexTerm>with a code sample that applies two gradients to a <Literal>fillRect</Literal> representing our final tree trunk, as shown in Listing 2-16.</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 2-16.</Heading>
<Para>Using a Gradient</Para>
</FormalPara>
<Para Type="Programcode">// Create a 3 stop gradient horizontally across the trunk</Para>
<Para Type="Programcode">var trunkGradient = context.createLinearGradient(-5, -50, 5, -50);</Para>
<Para Type="Programcode">// The beginning of the trunk is medium brown</Para>
<Para Type="Programcode">trunkGradient.addColorStop(0, '#663300');</Para>
<Para Type="Programcode">// The middle-left of the trunk is lighter in color</Para>
<Para Type="Programcode">trunkGradient.addColorStop(0.4, '#996600');</Para>
<Para Type="Programcode">// The right edge of the trunk is darkest</Para>
<Para Type="Programcode">trunkGradient.addColorStop(1, '#552200');</Para>
<Para Type="Programcode">// Apply the gradient as the fill style, and draw the trunk</Para>
<Para Type="Programcode">context.fillStyle = trunkGradient;</Para>
<Para Type="Programcode">context.fillRect(-5, -50, 10, 50);</Para>
<Para Type="Programcode">// A second, vertical gradient creates a shadow from the</Para>
<Para Type="Programcode">//  canopy on the trunk</Para>
<Para Type="Programcode">var canopyShadow = context.createLinearGradient(0, -50, 0, 0);</Para>
<Para Type="Programcode">// The beginning of the shadow gradient is black, but with</Para>
<Para Type="Programcode">//  a 50% alpha value</Para>
<Para Type="Programcode">canopyShadow.addColorStop(0, 'rgba(0, 0, 0, 0.5)');</Para>
<Para Type="Programcode">// Slightly further down, the gradient completely fades to</Para>
<Para Type="Programcode">//  fully transparent. The rest of the trunk gets no shadow.</Para>
<Para Type="Programcode">canopyShadow.addColorStop(0.2, 'rgba(0, 0, 0, 0.0)');</Para>
<Para Type="Programcode">// Draw the shadow gradient on top of the trunk gradient</Para>
<Para Type="Programcode">context.fillStyle = canopyShadow;</Para>
<Para Type="Programcode">context.fillRect(-5, -50, 10, 50);</Para>
<Para>Applying these two gradients creates a nice, smooth light source on our rendered tree as shown in Figure <InternalRef RefID="Fig13_2">2-13</InternalRef>, making <IndexTerm><Primary>gradients</Primary></IndexTerm><IndexTerm><Primary>Canvas API</Primary><Secondary>gradients</Secondary></IndexTerm>it appear curved and covered by a slight shadow from the canopy above. Let&#x2019;s keep it.
<Figure ID="Fig13_2" Float="Yes" Category="Standard">
<Caption Language="En">
<CaptionNumber>Figure 2-13</CaptionNumber>
<CaptionContent>
<SimplePara>Tree with gradient trunk</SimplePara>
</CaptionContent>
</Caption>
<MediaObject ID="MO13_2">
<ImageObject FileRef="978-1-4302-3865-2_2_Fig13_HTML.gif" Format="GIF" Color="Color" Type="Linedraw" Rendition="HTML"/>
</MediaObject>
</Figure></Para>
<Para>Besides the linear gradient used in our example, the Canvas API also supports a radial gradient<IndexTerm><Primary>radial gradient</Primary></IndexTerm> option that allows you to specify two circular representations in which the color stops are applied to the cone between the two circles. The radial gradient uses the same color stops as the linear gradient, but takes its arguments in the form shown in Listing 2-17.</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 2-17.</Heading>
<Para>Example of Applying a Radial Gradient</Para>
</FormalPara>
<Para Type="Programcode">createRadialGradient(x0, y0, r0, x1, y1, r1)</Para>
<Para>In this example, the first three arguments represent a circle centered at (x0, y0) with radius r0, and the last three arguments represent a second circle centered at (x1, y1) with radius r1. The gradient is drawn across the area between the two circles.</Para>
</Section2>
<Section2 ID="Sec21_2">
<Heading>Using Background Patterns</Heading>
<Para>Direct rendering of images has many<IndexTerm><Primary>background patterns</Primary></IndexTerm><IndexTerm><Primary>Canvas API</Primary><Secondary>background patterns</Secondary></IndexTerm> uses, but in some cases it is beneficial to use an image as a background tile, similar to the capability available in CSS. We&#x2019;ve already seen how it is possible to set a stroke or fill style to be a solid color. The HTML5 Canvas API also includes an option to set an image as a repeatable pattern for either a path stroke or fill.</Para>
<Para>To make our forest trail appear a bit more rugged, we will demonstrate the capability by replacing the previous stroked trail curve with one that uses a background image fill. In doing so, we&#x2019;ll swap out our now-unused bark image for a gravel image that we will put to use here. Listing 2-18 shows we replace the call to <Literal>drawImage</Literal> with a call to <Literal>createPattern</Literal>.</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 2-18.</Heading>
<Para>Using a Background Pattern</Para>
</FormalPara>
<Para Type="Programcode">// Replace the bark image with</Para>
<Para Type="Programcode">// a trail gravel image</Para>
<Para Type="Programcode">var gravel = new Image();</Para>
<Para Type="Programcode">gravel.src = "gravel.jpg";</Para>
<Para Type="Programcode">gravel.onload = function () {</Para>
<Para Type="Programcode">    drawTrails();</Para>
<Para Type="Programcode">}</Para>
<Para Type="Programcode">// Replace the solid stroke with a repeated</Para>
<Para Type="Programcode">// background pattern</Para>
<Para Type="Programcode">context.strokeStyle = context.createPattern(gravel, 'repeat');</Para>
<Para Type="Programcode">context.lineWidth = 20;</Para>
<Para Type="Programcode">context.stroke();</Para>
<Para>As you can see, we are still calling <Literal>stroke()</Literal> for our path. However, this time we have set a <Literal>strokeStyle</Literal> property<IndexTerm><Primary>strokeStyle property</Primary></IndexTerm> on the context first, passing in the result of a call to <Literal>context.createPattern</Literal>. Oh, and once again the image needs to be previously loaded in order for the canvas to perform the operation. The second argument is a repetition pattern that can be one of the choices shown in Table <InternalRef RefID="Tab2_2">2-2</InternalRef>.<Table ID="Tab2_2" Float="Yes">
<Caption Language="En">
<CaptionNumber>Table 2-2</CaptionNumber>
<CaptionContent>
<SimplePara>Repetition Patterns</SimplePara>
</CaptionContent>
</Caption>
<tgroup cols="2" align="left">
<colspec colnum="1" colname="c1" align="left"/>
<colspec colnum="2" colname="c2" align="left"/>
<thead>
<row>
<entry colname="c1">
<SimplePara>Repeat</SimplePara>
</entry>
<entry colname="c2">
<SimplePara>Value</SimplePara>
</entry>
</row>
</thead>
<tbody>
<row>
<entry colname="c1">
<SimplePara><Literal>repeat</Literal></SimplePara>
</entry>
<entry colname="c2">
<SimplePara>(Default) The image is repeated in both directions</SimplePara>
</entry>
</row>
<row>
<entry colname="c1">
<SimplePara><Literal>repeat-x</Literal></SimplePara>
</entry>
<entry colname="c2">
<SimplePara>The image is repeated only in the X dimension</SimplePara>
</entry>
</row>
<row>
<entry colname="c1">
<SimplePara><Literal>repeat-y</Literal></SimplePara>
</entry>
<entry colname="c2">
<SimplePara>The image is repeated only in the Y dimension</SimplePara>
</entry>
</row>
<row>
<entry colname="c1">
<SimplePara><Literal>no-repeat</Literal></SimplePara>
</entry>
<entry colname="c2">
<SimplePara>The image is displayed once and not repeated</SimplePara>
</entry>
</row>
</tbody>
</tgroup>
</Table>
</Para>
<Para>Figure <InternalRef RefID="Fig14_2">2-14</InternalRef> shows the result of the use of a background image rather than an explicitly drawn image to represent our trail.
<Figure ID="Fig14_2" Float="Yes" Category="Standard">
<Caption Language="En">
<CaptionNumber>Figure 2-14</CaptionNumber>
<CaptionContent>
<SimplePara>A trail with a repeating <IndexTerm><Primary>background patterns</Primary></IndexTerm><IndexTerm><Primary>Canvas API</Primary><Secondary>background patterns</Secondary></IndexTerm> background pattern</SimplePara>
</CaptionContent>
</Caption>
<MediaObject ID="MO14_2">
<ImageObject FileRef="978-1-4302-3865-2_2_Fig14_HTML.gif" Format="GIF" Color="Color" Type="Linedraw" Rendition="HTML"/>
</MediaObject>
</Figure>
</Para>
</Section2>
<Section2 ID="Sec22_2">
<Heading>Scaling Canvas Objects</Heading>
<Para>What kind of forest <IndexTerm><Primary>scaling canvas objects</Primary></IndexTerm><IndexTerm><Primary>Canvas API</Primary><Secondary>scaling canvas objects</Secondary></IndexTerm>has only one tree? Let&#x2019;s fix that right away. To make this a little easier, we will adjust our code sample to isolate the tree drawing operations to a single routine, called <Literal>drawTree</Literal>, as shown in Listing 2-19.</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 2-19.</Heading>
<Para>Function to Draw the Tree Object</Para>
</FormalPara>
<Para Type="Programcode">// Move tree drawing into its own function for reuse</Para>
<Para Type="Programcode">function drawTree(context) {</Para>
<Para Type="Programcode">  var trunkGradient = context.createLinearGradient(-5, -50, 5, -50);</Para>
<Para Type="Programcode">  trunkGradient.addColorStop(0, '#663300');</Para>
<Para Type="Programcode">  trunkGradient.addColorStop(0.4, '#996600');</Para>
<Para Type="Programcode">  trunkGradient.addColorStop(1, '#552200');</Para>
<Para Type="Programcode">  context.fillStyle = trunkGradient;</Para>
<Para Type="Programcode">  context.fillRect(-5, -50, 10, 50);</Para>
<Para Type="Programcode">  var canopyShadow = context.createLinearGradient(0, -50, 0, 0);</Para>
<Para Type="Programcode">  canopyShadow.addColorStop(0, 'rgba(0, 0, 0, 0.5)');</Para>
<Para Type="Programcode">  canopyShadow.addColorStop(0.2, 'rgba(0, 0, 0, 0.0)');</Para>
<Para Type="Programcode">  context.fillStyle = canopyShadow;</Para>
<Para Type="Programcode">  context.fillRect(-5, -50, 10, 50);</Para>
<Para Type="Programcode">  createCanopyPath(context);</Para>
<Para Type="Programcode">  context.lineWidth = 4;</Para>
<Para Type="Programcode">  context.lineJoin = 'round';</Para>
<Para Type="Programcode">  context.strokeStyle = '#663300';</Para>
<Para Type="Programcode">  context.stroke();</Para>
<Para Type="Programcode">  context.fillStyle = '#339900';</Para>
<Para Type="Programcode">  context.fill();</Para>
<Para Type="Programcode">}</Para>
<Para>As you can see, the <Literal>drawTree</Literal> function contains all the code we previously created to draw the canopy, trunk, and trunk gradient. Now we will use one of the transformation routines&#x2014; <Literal>context.scale</Literal><IndexTerm><Primary>context.scale function</Primary></IndexTerm>&#x2014;to draw a second tree at a new location and with a larger size, as <IndexTerm><Primary>scaling canvas objects</Primary></IndexTerm><IndexTerm><Primary>Canvas API</Primary><Secondary>scaling canvas objects</Secondary></IndexTerm>shown in Listing 2-20.</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 2-20.</Heading>
<Para>Drawing the Tree Objects</Para>
</FormalPara>
<Para Type="Programcode">// Draw the first tree at X=130, Y=250</Para>
<Para Type="Programcode">context.save();</Para>
<Para Type="Programcode">context.translate(130, 250);</Para>
<Para Type="Programcode">drawTree(context);</Para>
<Para Type="Programcode">context.restore();</Para>
<Para Type="Programcode">// Draw the second tree at X=260, Y=500</Para>
<Para Type="Programcode">context.save();</Para>
<Para Type="Programcode">context.translate(260, 500);</Para>
<Para Type="Programcode">// Scale this tree twice normal in both dimensions</Para>
<Para Type="Programcode">context.scale(2, 2);</Para>
<Para Type="Programcode">drawTree(context);</Para>
<Para Type="Programcode">context.restore();</Para>
<Para>The <Literal>scale</Literal> function<IndexTerm><Primary>scale function</Primary></IndexTerm> takes two factors for the x and y dimensions as its arguments. Each factor tells the canvas implementation how much larger (or smaller) to make the size in that dimension; an X factor of 2 would make all subsequent draw routines twice as wide, while a Y factor of 0.5 would make all subsequent operations half as tall as before. Using these routines, we now have an easy way to create a second tree in our trails canvas, as shown in Figure <InternalRef RefID="Fig15_2">2-15</InternalRef>.
<Figure ID="Fig15_2" Float="Yes" Category="Standard">
<Caption Language="En">
<CaptionNumber>Figure 2-15</CaptionNumber>
<CaptionContent>
<SimplePara>Tree with a<IndexTerm><Primary>scaling canvas objects</Primary></IndexTerm><IndexTerm><Primary>Canvas API</Primary><Secondary>scaling canvas objects</Secondary></IndexTerm> larger scale</SimplePara>
</CaptionContent>
</Caption>
<MediaObject ID="MO15_2">
<ImageObject FileRef="978-1-4302-3865-2_2_Fig15_HTML.gif" Format="GIF" Color="Color" Type="Linedraw" Rendition="HTML"/>
</MediaObject>
</Figure>
</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Always perform shape and path routines at the origin</Heading>
<Para><Emphasis Type="Bold">Brian says (and really means it, this time)</Emphasis>: &#x201C;This example illustrates one of the reasons why it is a good idea to perform <IndexTerm><Primary>shape routines</Primary></IndexTerm><IndexTerm><Primary>path routines</Primary></IndexTerm>shape and path routines at the origin; then translate them when complete, as we do here in our code. The reason is that transforms such as <Literal>scale</Literal> and <Literal>rotate</Literal> operate from the origin.</Para>
<Para>If you perform a <Literal>rotate</Literal> transform to a shape drawn off origin, a <Literal>rotate</Literal> transform will rotate the shape around the origin rather than rotating in place. Similarly, if you performed a scale operation to shapes before translating them to their proper position, all locations for path coordinates would also be multiplied by the scaling factor. Depending on the scale factor applied, this new location could even be off the canvas altogether, leaving you wondering why your scale operation just &#x2018;deleted&#x2019; the image.&#x201D;</Para>
</FormalPara>
</Section2>
<Section2 ID="Sec23_2">
<Heading>Using Canvas Transforms</Heading>
<Para>Transform operations are <IndexTerm><Primary>Canvas API</Primary><Secondary>using transformations</Secondary></IndexTerm>not limited to scales and translates. It is also possible to rotate the drawing context using the <Literal>context.rotate(angle)</Literal> function<IndexTerm><Primary>context.rotate(angle) function</Primary></IndexTerm> or even to modify the underlying transform directly for more advanced operations such as shearing of the rendered paths. If you wanted to rotate the display of an image, you would merely need to call the series of operations shown in Listing 2-21.</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 2-21.</Heading>
<Para>A Rotated Image</Para>
</FormalPara>
<Para Type="Programcode">context.save();</Para>
<Para Type="Programcode">// rotation angle is specified in radians</Para>
<Para Type="Programcode">context.rotate(1.57);</Para>
<Para Type="Programcode">context.drawImage(myImage, 0, 0, 100, 100);</Para>
<Para Type="Programcode">context.restore();</Para>
<Para>In Listing 2-22, however, we will show how you can apply an arbitrary transform to the path coordinates to radically alter the display of our existing tree path in order to create a shadow effect.</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 2-22.</Heading>
<Para>Using a Transform</Para>
</FormalPara>
<Para Type="Programcode">// Create a 3 stop gradient horizontally across the trunk</Para>
<Para Type="Programcode">// Save the current canvas state for later</Para>
<Para Type="Programcode">context.save();</Para>
<Para Type="Programcode">// Create a slanted tree as the shadow by applying</Para>
<Para Type="Programcode">//  a shear transform, changing X values to increase</Para>
<Para Type="Programcode">//  as Y values increase</Para>
<Para Type="Programcode">// With this transform applied, all coordinates are</Para>
<Para Type="Programcode">//  multiplied by the matrix.</Para>
<Para Type="Programcode">context.transform(1, 0,-0.5, 1, 0, 0);</Para>
<Para Type="Programcode">// Shrink the shadow down to 60% height in the Y dimension</Para>
<Para Type="Programcode">context.scale(1, 0.6);</Para>
<Para Type="Programcode">// Set the tree fill to be black, but at only 20% alpha</Para>
<Para Type="Programcode">context.fillStyle = 'rgba(0, 0, 0, 0.2)';</Para>
<Para Type="Programcode">context.fillRect(-5, -50, 10, 50);</Para>
<Para Type="Programcode">// Redraw the tree with the shadow effects applied</Para>
<Para Type="Programcode">createCanopyPath(context);</Para>
<Para Type="Programcode">context.fill();</Para>
<Para Type="Programcode">// Restore the canvas state</Para>
<Para Type="Programcode">context.restore();</Para>
<Para>Modifying the context transform directly as we&#x2019;ve done here is something you should attempt only if you are familiar with the matrix mathematics <IndexTerm><Primary>Canvas API</Primary><Secondary>using transformations</Secondary></IndexTerm>underpinning two-dimensional drawing systems. If you check the math behind this transform, you will see that we are shifting the X values of our drawing by a factor of the corresponding Y values in order to shear the gray tree being used as a shadow. Then, by applying a scale factor of 60%, the sheared tree is decreased in size.</Para>
<Para>Note that the sheared &#x201C;shadow&#x201D; tree is rendered first, so that the actual tree appears above<IndexTerm><Primary>Z-order</Primary></IndexTerm> it in <Emphasis Type="Italic">Z-order</Emphasis> (the order in which the canvas objects overlap). Also, the shadow tree is drawn using the CSS notation for RGBA, which allows us to set the alpha value to only 20% of normal. This creates the light, semitransparent look for the shadow tree. Once applied to our scaled trees, the output renders as shown in Figure <InternalRef RefID="Fig16_2">2-16</InternalRef>.
<Figure ID="Fig16_2" Float="Yes" Category="Standard">
<Caption Language="En">
<CaptionNumber>Figure 2-16</CaptionNumber>
<CaptionContent>
<SimplePara>Trees with <IndexTerm><Primary>Canvas API</Primary><Secondary>using transformations</Secondary></IndexTerm> transformed shadows</SimplePara>
</CaptionContent>
</Caption>
<MediaObject ID="MO16_2">
<ImageObject FileRef="978-1-4302-3865-2_2_Fig16_HTML.gif" Format="GIF" Color="Color" Type="Linedraw" Rendition="HTML"/>
</MediaObject>
</Figure>
</Para>
</Section2>
<Section2 ID="Sec24_2">
<Heading>Using Canvas Text</Heading>
<Para>As we approach the end<IndexTerm><Primary>Canvas API</Primary><Secondary>using text</Secondary></IndexTerm> of our trail creation, let&#x2019;s demonstrate the power of the Canvas API text functions by adding a fancy title to the top of our display. It is important to note that text rendering on a canvas is treated the same way as any other path object: text can be stroked or filled, and all rendering transformations and styles can apply to text just as they do to any other shape.</Para>
<Para>As you might expect, <IndexTerm><Primary>fillText function</Primary></IndexTerm><IndexTerm><Primary>strokeText function</Primary></IndexTerm>the text drawing routines consist of two functions on the context object:<UnorderedList Mark="Bullet">
<ItemContent>
<Para><Literal>fillText (text, x, y, maxwidth)</Literal></Para></ItemContent>
<ItemContent>
<Para><Literal>strokeText (text, x, y, maxwidth)</Literal></Para></ItemContent>
</UnorderedList>
</Para>
<Para>Both functions take the text as well as the location at which it should be drawn. Optionally, a <Literal>maxwidth</Literal> argument can be provided to constrain the size of the text by automatically shrinking the font to fit the given size. In addition, a <Literal>measureText</Literal> function is available to return a metrics object containing the width of the given text should it be rendered using the current context settings.</Para>
<Para>As is the case with all browser text display, the actual appearance of the text is highly configurable using context properties that are similar to their CSS counterparts, as shown in Table <InternalRef RefID="Tab3_2">2-3</InternalRef>.
<Table ID="Tab3_2" Float="Yes">
<Caption Language="En">
<CaptionNumber>Table 2-3</CaptionNumber>
<CaptionContent>
<SimplePara>Possible Settings for Background Pattern Repetition</SimplePara>
</CaptionContent>
</Caption>
<tgroup cols="3" align="left">
<colspec colnum="1" colname="c1" align="left"/>
<colspec colnum="2" colname="c2" align="left"/>
<colspec colnum="3" colname="c3" align="left"/>
<thead>
<row>
<entry colname="c1">
<SimplePara>Property</SimplePara>
</entry>
<entry colname="c2">
<SimplePara>Values</SimplePara>
</entry>
<entry colname="c3">
<SimplePara>Note</SimplePara>
</entry>
</row>
</thead>
<tbody>
<row>
<entry colname="c1">
<SimplePara><Literal>font</Literal></SimplePara>
</entry>
<entry colname="c2">
<SimplePara>CSS font string</SimplePara>
</entry>
<entry colname="c3">
<SimplePara>Example: italic Arial, sans-serif</SimplePara>
</entry>
</row>
<row>
<entry colname="c1">
<SimplePara><Literal>textAlign</Literal></SimplePara>
</entry>
<entry colname="c2">
<SimplePara>start, end, left, right, center</SimplePara>
</entry>
<entry colname="c3">
<SimplePara>Defaults to start</SimplePara>
</entry>
</row>
<row>
<entry colname="c1">
<SimplePara><Literal>textBaseline</Literal></SimplePara>
</entry>
<entry colname="c2">
<SimplePara>top, hanging, middle, alphabetic, ideographic, bottom</SimplePara>
</entry>
<entry colname="c3">
<SimplePara>Defaults to alphabetic</SimplePara>
</entry>
</row>
</tbody>
</tgroup>
</Table>
</Para>
<Para>All these context properties <IndexTerm><Primary>Canvas API</Primary><Secondary>using text</Secondary></IndexTerm>can be set to alter the context or accessed to query the current values. In Listing 2-23, we will create a large text message with the font face <Literal>Impact</Literal> and fill it with the background pattern of our existing bark image. In order to center the text across the top of our canvas, we will declare a maximum width and a <Literal>center</Literal> alignment.</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 2-23.</Heading>
<Para>Using Canvas Text</Para>
</FormalPara>
<Para Type="Programcode">// Draw title text on our canvas</Para>
<Para Type="Programcode">context.save();</Para>
<Para Type="Programcode">// The font will be 60 pixel, Impact face</Para>
<Para Type="Programcode">context.font = "60px impact";</Para>
<Para Type="Programcode">// Use a brown fill for our text</Para>
<Para Type="Programcode">context.fillStyle = '#996600';</Para>
<Para Type="Programcode">// Text can be aligned when displayed</Para>
<Para Type="Programcode">context.textAlign = 'center';</Para>
<Para Type="Programcode">// Draw the text in the middle of the canvas with a max</Para>
<Para Type="Programcode">//  width set to center properly</Para>
<Para Type="Programcode">context.fillText('Happy Trails!', 200, 60, 400);</Para>
<Para Type="Programcode">context.restore();</Para>
<Para>As you can see from the result in Figure <InternalRef RefID="Fig17_2">2-17</InternalRef>, the trail drawing just got a whole lot&#x2014;you guessed it&#x2014;happier.
<Figure ID="Fig17_2" Float="Yes" Category="Standard">
<Caption Language="En">
<CaptionNumber>Figure 2-17</CaptionNumber>
<CaptionContent>
<SimplePara>Background pattern-filled text<IndexTerm><Primary>Canvas API</Primary><Secondary>using text</Secondary></IndexTerm>
</SimplePara>
</CaptionContent>
</Caption>
<MediaObject ID="MO17_2">
<ImageObject FileRef="978-1-4302-3865-2_2_Fig17_HTML.gif" Format="GIF" Color="Color" Type="Linedraw" Rendition="HTML"/>
</MediaObject>
</Figure>
</Para>
</Section2>
<Section2 ID="Sec25_2">
<Heading>Applying Shadows</Heading>
<Para>Finally, we will use the<IndexTerm><Primary>shadows</Primary></IndexTerm><IndexTerm><Primary>Canvas API</Primary><Secondary>using shadows</Secondary></IndexTerm> built-in canvas shadow API to add a blurred shadow effect to our new text display. Like many graphical effects, shadows are best applied in moderation, even though the Canvas API allows you to apply shadows to any operation we have already covered.</Para>
<Para>Once again, shadows are controlled by a few global <Literal>context</Literal> properties, as shown in Table <InternalRef RefID="Tab4_2">2-4</InternalRef>.
<Table ID="Tab4_2" Float="Yes">
<Caption Language="En">
<CaptionNumber>Table 2-4</CaptionNumber>
<CaptionContent>
<SimplePara>Shadow Properties</SimplePara>
</CaptionContent>
</Caption>
<tgroup cols="3" align="left">
<colspec colnum="1" colname="c1" align="left"/>
<colspec colnum="2" colname="c2" align="left"/>
<colspec colnum="3" colname="c3" align="left"/>
<thead>
<row>
<entry colname="c1">
<SimplePara>Property</SimplePara>
</entry>
<entry colname="c2">
<SimplePara>Values</SimplePara>
</entry>
<entry colname="c3">
<SimplePara>Note</SimplePara>
</entry>
</row>
</thead>
<tbody>
<row>
<entry colname="c1">
<SimplePara><Literal>shadowColor</Literal><IndexTerm><Primary>shadowColor property</Primary></IndexTerm></SimplePara>
</entry>
<entry colname="c2">
<SimplePara>Any CSS color</SimplePara>
</entry>
<entry colname="c3">
<SimplePara>Can include an alpha component</SimplePara>
</entry>
</row>
<row>
<entry colname="c1">
<SimplePara><Literal>shadowOffsetX</Literal><IndexTerm><Primary>shadowOffsetX property</Primary></IndexTerm></SimplePara>
</entry>
<entry colname="c2">
<SimplePara>Pixel count</SimplePara>
</entry>
<entry colname="c3">
<SimplePara>Positive values move shadow to the right, negative left</SimplePara>
</entry>
</row>
<row>
<entry colname="c1">
<SimplePara><Literal>shadowOffsetY</Literal><IndexTerm><Primary>shadowOffsetY property</Primary></IndexTerm></SimplePara>
</entry>
<entry colname="c2">
<SimplePara>Pixel count</SimplePara>
</entry>
<entry colname="c3">
<SimplePara>Positive values move shadow down, negative up</SimplePara>
</entry>
</row>
<row>
<entry colname="c1">
<SimplePara><Literal>shadowBlur</Literal><IndexTerm><Primary>shadowBlur property</Primary></IndexTerm></SimplePara>
</entry>
<entry colname="c2">
<SimplePara>Gaussian blur</SimplePara>
</entry>
<entry colname="c3">
<SimplePara>Higher values cause blurrier shadow edges</SimplePara>
</entry>
</row>
</tbody>
</tgroup>
</Table>
</Para>
<Para>The shadow effect is triggered on any path, text, or image render if the <Literal>shadowColor</Literal> and at least one of the other properties is set to a nondefault value. Listing 2-24 shows how we can apply a shadow to our new trails title text.</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 2-24.</Heading>
<Para>Applying a Shadow</Para>
</FormalPara>
<Para Type="Programcode">// Set some shadow on our text, black with 20% alpha</Para>
<Para Type="Programcode">context.shadowColor = 'rgba(0, 0, 0, 0.2)';</Para>
<Para Type="Programcode">// Move the shadow to the right 15 pixels, up 10</Para>
<Para Type="Programcode">context.shadowOffsetX = 15;</Para>
<Para Type="Programcode">context.shadowOffsetY = -10;</Para>
<Para Type="Programcode">// Blur the shadow slightly</Para>
<Para Type="Programcode">context.shadowBlur = 2;</Para>
<Para>With these simple additions, the canvas renderer will automatically apply shadows until the canvas state is restored or the shadow properties are reset. Figure <InternalRef RefID="Fig18_2">2-18</InternalRef> shows <IndexTerm><Primary>shadows</Primary></IndexTerm><IndexTerm><Primary>Canvas API</Primary><Secondary>using shadows</Secondary></IndexTerm>the newly applied shadows.
<Figure ID="Fig18_2" Float="Yes" Category="Standard">
<Caption Language="En">
<CaptionNumber>Figure 2-18</CaptionNumber>
<CaptionContent>
<SimplePara>Title with shadowed text</SimplePara>
</CaptionContent>
</Caption>
<MediaObject ID="MO18_2">
<ImageObject FileRef="978-1-4302-3865-2_2_Fig18_HTML.gif" Format="GIF" Color="Color" Type="Linedraw" Rendition="HTML"/>
</MediaObject>
</Figure>
</Para>
<Para>As you can see, the shadow generated by CSS is positional only and not in sync with the transformational shadow we created for our tree. For the sake<IndexTerm><Primary>shadows</Primary></IndexTerm><IndexTerm><Primary>Canvas API</Primary><Secondary>using shadows</Secondary></IndexTerm> of consistency, you should probably only use one approach to drawing shadows in a given canvas scene.</Para>
</Section2>
<Section2 ID="Sec26_2">
<Heading>Working with Pixel Data</Heading>
<Para>One of the most<IndexTerm><Primary>pixel data</Primary></IndexTerm><IndexTerm><Primary>Canvas API</Primary><Secondary>working with pixel adata</Secondary></IndexTerm> useful&#x2014;albeit nonobvious&#x2014;aspects of the Canvas API is the ability for developers to easily get access to the underlying pixels in the canvas. This access works in both directions: it is trivial to get access to the pixel values as a numerical array, and it is equally easy to modify those values and apply them back to the canvas. In fact, it is entirely possible to manipulate the canvas entirely through the pixel value calls and forgo the rendering calls we&#x2019;ve discussed in this chapter. This is made possible by the existence of three functions on the <Literal>context</Literal> API.</Para>
<Para>First up is <Literal>context.getImageData(sx, sy, sw, sh)</Literal><IndexTerm><Primary>context.getImageData function</Primary></IndexTerm><IndexTerm><Primary>getImageData function</Primary></IndexTerm>. This function returns a representation of the current state of the canvas display as a collection of integers. Specifically, it returns an object containing three properties:<UnorderedList Mark="Bullet">
<ItemContent>
<Para><Literal>width</Literal>: The number of pixels in each row of the pixel data</Para></ItemContent>
<ItemContent>
<Para><Literal>height</Literal>: The number of pixels in each column of the pixel data<IndexTerm><Primary>pixel data</Primary></IndexTerm><IndexTerm><Primary>Canvas API</Primary><Secondary>working with pixel adata</Secondary></IndexTerm>
</Para></ItemContent>
<ItemContent>
<Para><Literal>data</Literal>: A one-dimensional array containing the actual RGBA values for each pixel retrieved from the canvas. This array contains four values for each pixel&#x2014;a red, green, blue, and alpha component&#x2014;each with a value from 0 to 255. Therefore, each pixel retrieved from the canvas becomes four integer values in the data array. The data array is populated by pixels from left to right and top to bottom (for example, across the first row, then across the second row, and so on), as shown in Figure <InternalRef RefID="Fig19_2">2-19</InternalRef>.
</Para></ItemContent>
</UnorderedList>
</Para>
<Para><Figure ID="Fig19_2" Float="Yes" Category="Standard">
<Caption Language="En">
<CaptionNumber>Figure 2-19</CaptionNumber>
<CaptionContent>
<SimplePara>Pixel data and the internal data structure that represents it</SimplePara>
</CaptionContent>
</Caption>
<MediaObject ID="MO19_2">
<ImageObject FileRef="978-1-4302-3865-2_2_Fig19_HTML.gif" Format="GIF" Color="Color" Type="Linedraw" Rendition="HTML"/>
</MediaObject>
</Figure>
</Para>
<Para>The data returned by the call to <Literal>getImageData</Literal> is limited to the region defined by the four parameters. Only canvas pixels contained in the <IndexTerm><Primary>pixel data</Primary></IndexTerm><IndexTerm><Primary>Canvas API</Primary><Secondary>working with pixel adata</Secondary></IndexTerm>rectangular region surrounded by the source <Literal>x</Literal>, <Literal>y</Literal>, <Literal>width</Literal>, and <Literal>height</Literal> parameters will be retrieved. Therefore, to access all pixel values as data, you should pass in <Literal>getImageData(0, 0, canvas.width, canvas.height)</Literal>.</Para>
<Para>Because there are four image data values representing each pixel, it can be a little tricky to calculate exactly which index represents the values for a given pixel. The formula is as follows.</Para>
<Para>For any pixel at coordinate (x,y) in a canvas <IndexTerm><Primary>context.getImageData function</Primary></IndexTerm><IndexTerm><Primary>getImageData function</Primary></IndexTerm>with a given width and height, you can locate the component values:<UnorderedList Mark="Bullet">
<ItemContent>
<Para><Emphasis Type="Bold">Red component</Emphasis>: ((width * y) + x) * 4</Para></ItemContent>
<ItemContent>
<Para><Emphasis Type="Bold">Green component</Emphasis>: ((width * y) + x) * 4 + 1</Para></ItemContent>
<ItemContent>
<Para><Emphasis Type="Bold">Blue component</Emphasis>: ((width * y) + x) * 4 + 2</Para></ItemContent>
<ItemContent>
<Para><Emphasis Type="Bold">Alpha component</Emphasis>: ((width * y) + x) * 4 + 3</Para></ItemContent>
</UnorderedList>
</Para>
<Para>Once you have access to the object with image data, it is quite easy to modify the pixel values in the data array mathematically, because they are each simply integers from 0 to 255. Changing the red, green, blue, or alpha values for one or more pixels makes it easy to update the canvas display by using the second function: <Literal>context.putImageData</Literal><IndexTerm><Primary>context.putImageData function</Primary></IndexTerm><IndexTerm><Primary>putImageData function</Primary></IndexTerm>(imagedata, dx, dy).</Para>
<Para><Literal>putImageData</Literal> allows you to pass in a set of image data in the same format as it was originally retrieved; that&#x2019;s quite handy because you can modify the values the canvas originally gave you and put them back. Once this function is called, the canvas will immediately update to reflect the new values of the pixels you passed in as the image data. The <Literal>dx</Literal> and <Literal>dy</Literal> parameters allow you to specify an offset for where to start applying your data array into the existing canvas, should you choose to use one.</Para>
<Para>Finally, if you want to start from scratch with a set of blank canvas data, you can call <Literal>context.createImageData</Literal><IndexTerm><Primary>context.createImageData function</Primary></IndexTerm><IndexTerm><Primary>createImageData function</Primary></IndexTerm>(sw, sh) to create a new set of image data tied to the canvas object. This set of data can be programmatically changed as before, even<IndexTerm><Primary>pixel data</Primary></IndexTerm><IndexTerm><Primary>Canvas API</Primary><Secondary>working with pixel adata</Secondary></IndexTerm> though it does not represent the current state of the canvas when retrieved.</Para>
<Para>There is yet another way to get data out of a canvas: the <Literal>canvas.toDataURL</Literal> API. This function gives you a programmatic way to retrieve the current rendering data of a canvas in a text format, but in this case the format is a standard representation of the data that browsers can interpret as images.</Para>
<Para>A data URL is a string containing the data of an image&#x2014;such as a PNG&#x2014;that a browser can display just like a normal image file. The format of a data URL is best illustrated with an example:</Para>
<Para Type="Programcode">data:image/png;base64, WCAYAAABkY9jZxn&#x2026;</Para>
<Para>This example shows that the format is the string <Literal>data:</Literal> followed by a MIME type (such as <Literal>image/png</Literal>), followed by a flag indicating whether or not the data is encoded in base64 format, and then the text representing the data itself.</Para>
<Para>Don&#x2019;t worry about the format, as you won&#x2019;t be generating it yourself. The important point is that with a simple call, you can get the content of a canvas delivered to you in one of these special URLs. When you call <Literal>canvas.toDataURL(type)</Literal>, you can pass in a type of image you would like the canvas data generated in, such as <Literal>image/png</Literal> (the default) or <Literal>image/jpeg</Literal>. The data URL returned to you can be used as the source of image elements in a page or CSS styles, as shown in Listing 2-25.</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 2-25.</Heading>
<Para>Creating an Image from a Canvas</Para>
</FormalPara>
<Para Type="Programcode">var myCanvas = document.getElementById("myCanvas");</Para>
<Para Type="Programcode">// draw operations into the canvas&#x2026;</Para>
<Para Type="Programcode">// get the canvas data as a data URL</Para>
<Para Type="Programcode">var canvasData = myCanvas.toDataURL();</Para>
<Para Type="Programcode">// set the data as the source of a new image</Para>
<Para Type="Programcode">var img = new Image();</Para>
<Para Type="Programcode">img.src = canvasData;</Para>
<Para>You don&#x2019;t have to use a data URL right away. You could even store the URL in your browser&#x2019;s local storage for later retrieval and manipulation. Browser storage will be covered later in this book.<IndexTerm><Primary>pixel data</Primary></IndexTerm><IndexTerm><Primary>Canvas API</Primary><Secondary>working with pixel adata</Secondary></IndexTerm>
</Para>
</Section2>
<Section2 ID="Sec27_2">
<Heading>Implementing Canvas Security</Heading>
<Para>There is an important <IndexTerm><Primary>Canvas API</Primary><Secondary>canvas security</Secondary></IndexTerm><IndexTerm><Primary>security, canvas</Primary></IndexTerm>caveat to using pixel manipulation, as described in the previous section. Although most developers would use pixel manipulation for legitimate means, it is quite possible that the ability to fetch and update data from a canvas could be used for nefarious purposes. For this reason, the concept of <IndexTerm><Primary>origin-clean canvas</Primary></IndexTerm>an <Emphasis Type="Italic">origin-clean</Emphasis> canvas was specified, so that canvases that are <Emphasis Type="Italic">tainted</Emphasis> with images from origins other than the source of the containing page cannot have their data retrieved.</Para>
<Para>As shown in Figure <InternalRef RefID="Fig20_2">2-20</InternalRef>, if a page served up from <Literal>http://www.example.com</Literal> contains a <Literal>canvas</Literal> element, it is entirely possible that the code in the page could try to render an image from <Literal>http://www.remote.com</Literal> inside the canvas. After all, it is perfectly acceptable to render images from remote sites inside any given web page.
<Figure ID="Fig20_2" Float="Yes" Category="Standard">
<Caption Language="En">
<CaptionNumber>Figure 2-20</CaptionNumber>
<CaptionContent>
<SimplePara>Local and remote image sources</SimplePara>
</CaptionContent>
</Caption>
<MediaObject ID="MO20_2">
<ImageObject FileRef="978-1-4302-3865-2_2_Fig20_HTML.gif" Format="GIF" Color="Color" Type="Linedraw" Rendition="HTML"/>
</MediaObject>
</Figure>
</Para>
<Para>However, before the arrival of the Canvas API, it was not possible to programmatically retrieve the pixel values of a downloaded image. Private images from other sites could be displayed in a page but not read or copied. Allowing scripts to read image data from other origins would effectively share users' photographs and other sensitive online image file with the entire web.</Para>
<Para>In order to prevent this, any canvas that contains images rendered from remote origins will throw a security exception if the <Literal>getImageData</Literal> or <Literal>toDataURL</Literal> functions<IndexTerm><Primary>getImageData function</Primary></IndexTerm> are called. It is perfectly acceptable to render remote images into a canvas from another origin as long as you (or any other scriptwriter) do not attempt to fetch the data from that canvas after it has been tainted. Be aware of this<IndexTerm><Primary>Canvas API</Primary><Secondary>canvas security</Secondary></IndexTerm><IndexTerm><Primary>security, canvas</Primary></IndexTerm> limitation and practice safe rendering.</Para>
</Section2>
</Section1>
<Section1 ID="Sec28_2">
<Heading>Building an Application with HTML5 Canvas</Heading>
<Para>There are many different <IndexTerm><Primary>Canvas API</Primary><Secondary>building application with</Secondary></IndexTerm>application possibilities for using the Canvas API: graphs, charts, image editing, and so on. However, one of the most intriguing uses for the canvas is to modify or overlay existing content. One popular type of overlay is known as a <IndexTerm><Primary>heatmaps</Primary></IndexTerm>heatmap. Although the name implies a temperature measurement, the heat in this case can refer to any level of measurable activity. Areas on the map with high levels of activity are colored as hot (for example, red, yellow, or white). Areas with less activity show no color change at all, or minimal blacks and grays.</Para>
<Para>For example, a heatmap can be used to indicate traffic on a city map, or storm activity on a global map. And situations such as these are easy to implement in HTML5 by combining a canvas display with an underlying map source. Essentially, the canvas can be used to overlay the map and draw the heat levels based on the appropriate activity data.</Para>
<Para>Let&#x2019;s build a simple heatmap using the capabilities we learned about in the Canvas API. In this case, our heat data source will be not external data, but the movement of our mouse across the map. Moving the mouse over a portion of the map will cause the heat to increase, and holding the mouse at a given position will rapidly increase the temperature to maximum levels. We can overlay such a heatmap display(shown in Figure <InternalRef RefID="Fig21_2">2-21</InternalRef>) on a nondescript terrain map, just to provide a sample case.
<Figure ID="Fig21_2" Float="Yes" Category="Standard">
<Caption Language="En">
<CaptionNumber>Figure 2-21</CaptionNumber>
<CaptionContent>
<SimplePara>The heatmap application</SimplePara>
</CaptionContent>
</Caption>
<MediaObject ID="MO21_2">
<ImageObject FileRef="978-1-4302-3865-2_2_Fig21_HTML.gif" Format="GIF" Color="Color" Type="Linedraw" Rendition="HTML"/>
</MediaObject>
</Figure>
</Para>
<Para>Now that you&#x2019;ve seen the end<IndexTerm><Primary>heatmaps</Primary></IndexTerm> result of our heatmap application, let&#x2019;s step through the code sample. As usual, the working examples are available online for your download and perusal.</Para>
<Para>Let&#x2019;s start with the HTML elements declared in this example. For this display, the HTML consists of only a title, a canvas, and a button we can use to<IndexTerm><Primary>Canvas API</Primary><Secondary>building application with</Secondary></IndexTerm> reset the heatmap. The background display for the canvas consists of a simple <Literal>mapbg.jpg</Literal> applied to the canvas via CSS as shown in Listing 2-26.</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 2-26.</Heading>
<Para>The Heatmap Canvas Element</Para>
</FormalPara>
<Para Type="Programcode">&#x003C;style type="text/css"&#x003E;</Para>
<Para Type="Programcode">  #heatmap {</Para>
<Para Type="Programcode">      background-image: url("mapbg.jpg");</Para>
<Para Type="Programcode">  }</Para>
<Para Type="Programcode">&#x003C;/style&#x003E;</Para>
<Para Type="Programcode">&#x003C;h2&#x003E;Heatmap &#x003C;/h2&#x003E;</Para>
<Para Type="Programcode">&#x003C;canvas id="heatmap" class="clear" style="border: 1px solid ; " height="300"</Para>
<Para Type="Programcode">width="300"&#x003E; &#x003C;/canvas&#x003E;</Para>
<Para Type="Programcode">&#x003C;button id="resetButton"&#x003E; Reset&#x003C;/button&#x003E;</Para>
<Para>We also declare some initial variables to be used later in the example.</Para>
<Para Type="Programcode">  var points = {};</Para>
<Para Type="Programcode">  var SCALE = 3;</Para>
<Para Type="Programcode">  var x = -1;</Para>
<Para Type="Programcode">  var y = -1;</Para>
<Para>Next, we will set the canvas to have a high transparency value for its global drawing operations, and set the composite mode to cause new draws to lighten the underlying pixels rather than replace them.</Para>
<Para>Then, as shown in Listing 2-27, we <IndexTerm><Primary>Canvas API</Primary><Secondary>building application with</Secondary></IndexTerm>will set a handler to change the display&#x2014; <Literal>addToPoint</Literal> &#x2014;every <IndexTerm><Primary>heatmaps</Primary></IndexTerm>time the mouse moves or one-tenth of a second passes.</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 2-27.</Heading>
<Para>The loadDemo<IndexTerm><Primary>loadDemo function</Primary></IndexTerm> <Emphasis Type="Italic">Function</Emphasis></Para>
</FormalPara>
<Para Type="Programcode">function loadDemo() {</Para>
<Para Type="Programcode">  document.getElementById("resetButton").onclick = reset;</Para>
<Para Type="Programcode">  canvas = document.getElementById("heatmap");</Para>
<Para Type="Programcode">  context = canvas.getContext('2d');</Para>
<Para Type="Programcode">  context.globalAlpha = 0.2;</Para>
<Para Type="Programcode">  context.globalCompositeOperation = "lighter"</Para>
<Para Type="Programcode">function sample() {</Para>
<Para Type="Programcode">  if (x != -1) {</Para>
<Para Type="Programcode">    addToPoint(x,y)</Para>
<Para Type="Programcode">  }</Para>
<Para Type="Programcode">  setTimeout(sample, 100);</Para>
<Para Type="Programcode">}</Para>
<Para Type="Programcode">canvas.onmousemove = function(e) {</Para>
<Para Type="Programcode">  x = e.clientX - e.target.offsetLeft;</Para>
<Para Type="Programcode">  y = e.clientY - e.target.offsetTop;</Para>
<Para Type="Programcode">  addToPoint(x,y)</Para>
<Para Type="Programcode">}</Para>
<Para Type="Programcode">  sample();</Para>
<Para Type="Programcode">}</Para>
<Para>If the user clicks <Emphasis Type="Bold">Reset</Emphasis>, the entire canvas area is cleared and reset to its original state by using the canvas&#x2019; <Literal>clearRect</Literal> function, as shown in Listing 2-28.</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 2-28.</Heading>
<Para>The<IndexTerm><Primary>reset function</Primary></IndexTerm> <Emphasis Type="Italic">reset Function</Emphasis></Para>
</FormalPara>
<Para Type="Programcode">function reset() {</Para>
<Para Type="Programcode">  points = {};</Para>
<Para Type="Programcode">  context.clearRect(0,0,300,300);</Para>
<Para Type="Programcode">  x = -1;</Para>
<Para Type="Programcode">  y = -1;</Para>
<Para Type="Programcode">}</Para>
<Para>Next we create a lookup table <IndexTerm><Primary>heatmaps</Primary></IndexTerm>of colors to use when drawing heat on the canvas. Listing 2-29 shows how the colors range in brightness from least to greatest, and they will be used to represent varying levels of heat on the display. The greater the value of the <Literal>intensity</Literal>, the brighter the returned color.</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 2-29.</Heading>
<Para>The<IndexTerm><Primary>getColor function</Primary></IndexTerm> <Emphasis Type="Italic">getColor Function</Emphasis></Para>
</FormalPara>
<Para Type="Programcode">function getColor(intensity) {</Para>
<Para Type="Programcode">  var colors = ["#072933", "#2E4045", "#8C593B", "#B2814E", "#FAC268", "#FAD237"];</Para>
<Para Type="Programcode">  return colors[Math.floor(intensity/2)];</Para>
<Para Type="Programcode">}</Para>
<Para>Whenever the mouse moves or hovers over an area of the canvas, a point is drawn. The point grows in size (and brightness) the longer the mouse stays in the immediate area. As shown in Listing 2-30, we use the <Literal>context.arc</Literal> function to draw a circle of a given <IndexTerm><Primary>Canvas API</Primary><Secondary>building application with</Secondary></IndexTerm>radius, and we draw a brighter, hotter color for larger radius values by passing the radius to our <Literal>getColor</Literal> function.</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 2-30.</Heading>
<Para>The<IndexTerm><Primary>drawPoint function</Primary></IndexTerm> <Emphasis Type="Italic">drawPoint Function</Emphasis></Para>
</FormalPara>
<Para Type="Programcode">function drawPoint(x, y, radius) {</Para>
<Para Type="Programcode">  context.fillStyle = getColor(radius);</Para>
<Para Type="Programcode">  radius = Math.sqrt(radius)*6;</Para>
<Para Type="Programcode">  context.beginPath();</Para>
<Para Type="Programcode">  context.arc(x, y, radius, 0, Math.PI*2, true)</Para>
<Para Type="Programcode">  context.closePath();</Para>
<Para Type="Programcode">  context.fill();</Para>
<Para Type="Programcode">}</Para>
<Para>In the <Literal>addToPoint</Literal> function<IndexTerm><Primary>addToPoint function</Primary></IndexTerm>&#x2014;which you will recall is accessed every time the mouse moves or hovers over a point&#x2014;a heat value is increased and stored for that particular point on the canvas. Listing 2-31 shows that the maximum point value is 10. Once the current value of heat for a given pixel is found, the appropriate pixel is passed to <Literal>drawPoint</Literal> with its corresponding heat/radius value.</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 2-31.</Heading>
<Para>The addToPoint Function</Para>
</FormalPara>
<Para Type="Programcode">function addToPoint(x, y) {</Para>
<Para Type="Programcode">  x = Math.floor(x/SCALE);</Para>
<Para Type="Programcode">  y = Math.floor(y/SCALE);</Para>
<Para Type="Programcode">  if (!points[[x,y]]) {</Para>
<Para Type="Programcode">    points[[x,y]] = 1;</Para>
<Para Type="Programcode">  } else if (points[[x,y]]==10) {</Para>
<Para Type="Programcode">    return</Para>
<Para Type="Programcode">  } else {</Para>
<Para Type="Programcode">    points[[x,y]]++;</Para>
<Para Type="Programcode">  }</Para>
<Para Type="Programcode">  drawPoint(x*SCALE,y*SCALE, points[[x,y]]);</Para>
<Para Type="Programcode">}</Para>
<Para>Finally, the <IndexTerm><Primary>heatmaps</Primary></IndexTerm>initial <Literal>loadDemo</Literal> function<IndexTerm><Primary>loadDemo function</Primary></IndexTerm> is registered to be called whenever the window completes loading.</Para>
<Para Type="Programcode">window.addEventListener("load", loadDemo, true);</Para>
<Para>Together, these one hundred or so lines of code illustrate how much you can do with the Canvas API in a short amount of time, without using any plug-ins or external rendering technology. With an infinite number of data sources available it is easy to see how they can be visualized simply and effectively.</Para>
<Section2 ID="Sec29_2">
<Heading>Practical Extra: Full Page Glass Pane</Heading>
<Para>In the example application, you<IndexTerm><Primary>Canvas API</Primary><Secondary>building application with</Secondary></IndexTerm> saw how you can apply a canvas on top of a graphic. You can also apply a canvas on top of the entire browser window or portions of the same&#x2014;a technique commonly referred to<IndexTerm><Primary>glass pane</Primary></IndexTerm> as glass pane. Once you have positioned the glass pane canvas on top of a web page, you can do all kinds of cool and handy things with it.</Para>
<Para>For example, you can use a routine to retrieve the absolute position of all the DOM elements on a page and create a step-by-step help function that can guide users of a web application through the steps they must perform to start and use the application.</Para>
<Para>Or, you can use the glass pane canvas to scribble feedback on someone&#x2019;s web page using the mouse events for drawing input. Some things to keep in mind if you try to use a canvas in this capacity:<UnorderedList Mark="Bullet">
<ItemContent>
<Para>You will need to set the canvas positioning to absolute and give it a specific position, width, and height. Without an explicit width and height setting, the canvas will remain at a zero pixel size.</Para></ItemContent>
<ItemContent>
<Para>Don&#x2019;t forget to set a high Z-index on the canvas so that it floats above all the visible content. A canvas rendered under all the existing content doesn&#x2019;t get much chance to shine.</Para></ItemContent>
<ItemContent>
<Para>Your glass pane<IndexTerm><Primary>glass pane</Primary></IndexTerm> canvas can block access to events in the content below, so be sparing in how you use it and remove it <IndexTerm><Primary>Canvas API</Primary><Secondary>building application with</Secondary></IndexTerm>when it is unnecessary.</Para></ItemContent>
</UnorderedList>
</Para>
</Section2>
<Section2 ID="Sec30_2">
<Heading>Practical Extra: Timing Your Canvas Animation<IndexTerm><Primary>animation, canvas</Primary></IndexTerm></Heading>
<Para>Earlier in the chapter, we mentioned that it is a common practice to animate elements on a canvas. This could be used for gaming, transitional effects, or simply to replace animated GIFs in an existing web page. But one area where JavaScript has been lacking is a reliable way to schedule your animation updates.</Para>
<Para>Today, most developers use the classic <Literal>setTimeout</Literal> or <Literal>setInterval</Literal> calls to schedule changes to a web page or application. Both of these calls allow you to schedule a callback after a certain number of milliseconds, which then allows you to make changes to the page during the callback. However, there are some significant problems with using that approach:<IndexTerm><Primary>Canvas API</Primary><Secondary>building application with</Secondary></IndexTerm>
<UnorderedList Mark="Bullet">
<ItemContent>
<Para>As a developer, you need to guess at the appropriate number of milliseconds in the future to schedule the next update. With the modern Web running on a wider variety of devices than ever, it is tricky to know the suggested frame rate for a high-powered desktop device versus a mobile phone. And even if you guess how many frames to schedule per second, you may end up competing with other pages or machine load.</Para></ItemContent>
<ItemContent>
<Para>It is more common than ever for users to browse with multiple windows or tabs, even on mobile devices. If you use <Literal>setTimeout</Literal> and <Literal>setInterval</Literal> to schedule your page updates, these will continue to happen even when the page is in the background. Running your scripts when they aren&#x2019;t even visible is a great way to convince users that your web application is draining their phone battery!</Para></ItemContent>
</UnorderedList>
</Para>
<Para>As an alternative, many browsers now offer a <Literal>requestAnimationFrame</Literal> function on the <Literal>window</Literal> object. This function takes a callback as its argument, and the callback will be invoked whenever the browser deems it appropriate for the animation to be updated.</Para>
<Para>Let&#x2019;s add another example (Listing 2-32) of our trail scene, this one with a crudely animated rain storm to signify the cancellation of our upcoming race. This code builds on the previous examples, and redundant code is not listed here.</Para>
<FormalPara RenderingStyle="Style1">
<Heading>Listing 2-32.</Heading>
<Para>Basic Animation<IndexTerm><Primary>animation, canvas</Primary></IndexTerm> <Emphasis Type="Italic">Frame Request</Emphasis>
</Para>
</FormalPara>
<Para Type="Programcode">// create an image for our rain texture</Para>
<Para Type="Programcode">var rain = new Image();</Para>
<Para Type="Programcode">rain.src = "rain.png";</Para>
<Para Type="Programcode">rain.onload = function () {</Para>
<Para Type="Programcode">  // Start off the animation with a single frame request</Para>
<Para Type="Programcode">  // once the rain is loaded</Para>
<Para Type="Programcode">  window.requestAnimFrame(loopAnimation, canvas);</Para>
<Para Type="Programcode">}</Para>
<Para Type="Programcode">// Previous code omitted&#x2026;</Para>
<Para Type="Programcode">// this function allows us to cover all browsers</Para>
<Para Type="Programcode">// by aliasing the different browser-specific</Para>
<Para Type="Programcode">// versions of the function to a single function</Para>
<Para Type="Programcode">window.requestAnimFrame = (function(){</Para>
<Para Type="Programcode">  return  window.requestAnimationFrame       ||</Para>
<Para Type="Programcode">          window.webkitRequestAnimationFrame ||</Para>
<Para Type="Programcode">          window.mozRequestAnimationFrame    ||</Para>
<Para Type="Programcode">          window.oRequestAnimationFrame      ||</Para>
<Para Type="Programcode">          window.msRequestAnimationFrame     ||</Para>
<Para Type="Programcode">          // fall back to the old setTimeout technique if nothing</Para>
<Para Type="Programcode">          // else is available</Para>
<Para Type="Programcode">          function(/* function */ callback, /* DOMElement */ element){</Para>
<Para Type="Programcode">            window.setTimeout(callback, 1000 / 60);</Para>
<Para Type="Programcode">          };</Para>
<Para Type="Programcode">;})();</Para>
<Para Type="Programcode">// This function is where we update the content of our canvas</Para>
<Para Type="Programcode">function drawAFrame() {</Para>
<Para Type="Programcode">  var context = canvas.getContext('2d');</Para>
<Para Type="Programcode">  // do some drawing on the canvas, using the elapsedTime</Para>
<Para Type="Programcode">  // as a guide for changes.</Para>
<Para Type="Programcode">  context.save();</Para>
<Para Type="Programcode">  // draw the existing trails picture first</Para>
<Para Type="Programcode">  drawTrails();</Para>
<Para Type="Programcode">  // Darken the canvas for an eerie sky.</Para>
<Para Type="Programcode">  // By only darkening most of the time, we create lightning flashes</Para>
<Para Type="Programcode">  if (Math.random() &#x003E; .01) {</Para>
<Para Type="Programcode">    context.globalAlpha = 0.65;</Para>
<Para Type="Programcode">    context.fillStyle = '#000000';</Para>
<Para Type="Programcode">    context.fillRect(0, 0, 400, 600);</Para>
<Para Type="Programcode">    context.globalAlpha = 1.0;</Para>
<Para Type="Programcode">  }</Para>
<Para><IndexTerm><Primary>Canvas API</Primary><Secondary>building application with</Secondary></IndexTerm>
</Para>
<Para Type="Programcode">  // then draw a rain image, adjusted by the current time</Para>
<Para Type="Programcode">  var now = Date.now();</Para>
<Para Type="Programcode">  context.fillStyle = context.createPattern(rain, 'repeat');</Para>
<Para Type="Programcode">  // We'll draw two translated rain images at different rates to</Para>
<Para Type="Programcode">  // show thick rain and snow</Para>
<Para Type="Programcode">  // Our rectangle will be bigger than the display size, and</Para>
<Para Type="Programcode">  // repositioned based on the time</Para>
<Para Type="Programcode">  context.save();</Para>
<Para Type="Programcode">  context.translate(-256 + (0.1 * now) % 256, -256 + (0.5 * now) % 256);</Para>
<Para Type="Programcode">  context.fillRect(0, 0, 400 + 256, 600 + 256);</Para>
<Para Type="Programcode">  context.restore();</Para>
<Para Type="Programcode">  // The second rectangle translates at a different rate for</Para>
<Para Type="Programcode">  // thicker rain appearance</Para>
<Para Type="Programcode">  context.save();</Para>
<Para Type="Programcode">  context.translate(-256 + (0.08 * now) % 256, -256 + (0.2 * now) % 256);</Para>
<Para Type="Programcode">  context.fillRect(0, 0, 400 + 256, 600 + 256);</Para>
<Para Type="Programcode">  context.restore();</Para>
<Para Type="Programcode">  // draw some explanatory text</Para>
<Para Type="Programcode">  context.font = '32px san-serif';</Para>
<Para Type="Programcode">  context.textAlign = 'center';</Para>
<Para Type="Programcode">  context.fillStyle = '#990000';</Para>
<Para Type="Programcode">  context.fillText('Event canceled due to weather!', 200, 550, 400);</Para>
<Para Type="Programcode">  context.restore();</Para>
<Para Type="Programcode">}</Para>
<Para Type="Programcode">// This function will be called whenever the browser is ready</Para>
<Para Type="Programcode">// for our application to render another frame.</Para>
<Para Type="Programcode">function loopAnimation(currentTime) {</Para>
<Para Type="Programcode">  // Draw a single frame of animation on our canvas</Para>
<Para Type="Programcode">  drawAFrame();</Para>
<Para Type="Programcode">  // After this frame is drawn, let the browser schedule</Para>
<Para Type="Programcode">  // the next one</Para>
<Para Type="Programcode">  window.requestAnimFrame(loopAnimation, canvas);</Para>
<Para Type="Programcode">}</Para>
<Para>Once we update our drawing, we can see the animating<IndexTerm><Primary>animation, canvas</Primary></IndexTerm> rain on top of our trail (see Figure <InternalRef RefID="Fig22_2">2-22</InternalRef>).<IndexTerm><Primary>Canvas API</Primary><Secondary>building application with</Secondary></IndexTerm>
<Figure ID="Fig22_2" Float="Yes" Category="Standard">
<Caption Language="En">
<CaptionNumber>Figure 2-22</CaptionNumber>
<CaptionContent>
<SimplePara>Still shot of canvas with rain animation<IndexTerm><Primary>animation, canvas</Primary></IndexTerm>
</SimplePara>
</CaptionContent>
</Caption>
<MediaObject ID="MO22_2">
<ImageObject FileRef="978-1-4302-3865-2_2_Fig22_HTML.gif" Format="GIF" Color="Color" Type="Linedraw" Rendition="HTML"/>
</MediaObject>
</Figure>
</Para>
<Para><IndexTerm><Primary>Canvas API</Primary><Secondary>building application with</Secondary></IndexTerm>It is up to the browser to decide how often to call the animation frame callback. Pages in the background will be called less frequently, and the browser may clip the rendering to the element provided to the <Literal>requestAnimationFrame</Literal> call (&#x201C;<Literal>canvas</Literal>&#x201D; in our example) to optimize drawing resources. You aren&#x2019;t guaranteed a frame rate, but you are spared the work of scheduling for different environments!</Para>
<Para>This technique is not limited to the Canvas API. You can use <Literal>requestAnimationFrame</Literal> to make changes anywhere on the page content or CSS. There are other ways to produce movement on a web page&#x2014;CSS animations<IndexTerm><Primary>animation, canvas</Primary></IndexTerm> come to mind&#x2014;but if you are working with script-based changes, the <Literal>requestAnimationFrame</Literal> function<IndexTerm><Primary>requestAnimationFrame function</Primary></IndexTerm> is the way to go<IndexTerm><Primary>Canvas API</Primary><Secondary>building application with</Secondary></IndexTerm>.</Para>
</Section2>
</Section1>
<Section1 ID="Sec31_2">
<Heading>Summary</Heading>
<Para>As you can see, the Canvas API provides a very powerful way to modify the appearance of your web application without resorting to odd document hacks. Images, gradients, and complex paths can be combined to create nearly any type of display you may be looking to present. Keep in mind that you generally need to draw at the origin, load any images you want to display before attempting to draw them, and be mindful of tainting your canvas with foreign image sources. However, if you learn to harness the power of the canvas, you can create applications that were never possible in a web page before.</Para>
</Section1>
</Body>
<BodyRef FileRef="978-1-4302-3865-2_2_Chapter_OnlinePDF.pdf" TargetType="OnlinePDF" PDFType="Typeset" OutputMedium="Online"/>
</Chapter>