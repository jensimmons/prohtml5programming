<!doctype html>

<!--[if lt IE 7]>      <html class="ie6 ie6-7 ie6-8"> <![endif]-->
<!--[if IE 7]>         <html class="ie7 ie6-7 ie7-8 ie6-8"> <![endif]-->
<!--[if IE 8]>         <html class="ie8 ie7-8 ie6-8"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

    <title>Pro HTML5 Programming: Chapter 9 | Working with HTML5 Drag-and-Drop</title>

    <meta name="description" content="">
    <meta name="author" content="">

    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- CSS -->
    <link rel="stylesheet" href="codemirror/lib/codemirror.css">
    <link rel="stylesheet" href="codemirror/theme/ambiance.css">
    <link rel="stylesheet" href="codemirror/theme/static.css">
  	<link rel="stylesheet" href="stylesheets/style.css" />

    <!-- JavaScript -->
    <!--[if (lt IE 9) & (!IEMobile)]>
    <script src="js/selectivizr-min.js"></script>
    <![endif]-->

    <script type="text/javascript" charset="utf-8">

      (function () {
        "use strict";
        window.ISBNOnline = '978-1-4302-3865-2';
      })();

    </script>
    
    <!-- MOD: LOAD JQUERY + COLORBOX SUPPORT FOR CODE VIEW -->
    <script src="js/jquery-1.8.0.min.js"></script>
    <script src="js/navigation.js"></script>
    <script src="js/jpanelmenu-1.0.0.js"></script>
    <script src="js/bootstrap-dropdown.js"></script>
    <script src="codemirror/lib/codemirror.js"></script>
    <script src="codemirror/mode/xml/xml.js"></script>
    <script src="codemirror/mode/javascript/javascript.js"></script>
    <script src="codemirror/mode/css/css.js"></script>
    <script src="codemirror/mode/htmlmixed/htmlmixed.js"></script>
    <script src="js/code_editor.js"></script>
    <script src="js/code_listings_ch9.js" type="text/javascript"></script>
    <script src="js/toc.js"></script>  


    <!-- For iPhone 4 -->
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="images/icons/apple-touch-icon-114x114-precomposed.png">
    <!-- For iPad 1-->
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="images/icons/apple-touch-icon-72x72-precomposed.png">
    <!-- For the new iPad -->
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="images/icons/apple-touch-icon-144x144-precomposed.png">
    <!-- For iPhone 3G, iPod Touch and Android -->
    <link rel="apple-touch-icon-precomposed" href="images/icons/apple-touch-icon-precomposed.png">
    <!-- For Nokia -->
    <link rel="shortcut icon" href="images/icons/apple-touch-icon.png">
    <!-- For everything else -->
    <link rel="shortcut icon" href="/favicon.ico">
    
    <!--iOS -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-startup-image" href="images/cover/cover.jpg">
    
    <meta http-equiv="cleartype" content="on">

  </head>

  <body>


    <div class="controls-bar">
      <div class="menu-link orig-menu menu-trigger">
        <a class="svg-menu" href="#main-navigation">Chapter Contents</a>
      </div>

      <div class="font-size-controls" style="position: fixed; top: 0px; left: 200px;">
        <a class="btn btn-fs fs-smaller">Smaller</a>
        <a class="btn btn-fs fs-default">Default</a>
        <a class="btn btn-fs fs-larger">Larger</a>
      </div>
    
      <div class="btn-group toc-link" id="toc">
        <a class="btn dropdown-toggle" data-toggle="dropdown" href="#">
          Table of Contents
          <span class="caret"></span>
        </a>
      </div>
    </div>


  
<!--======================== CONTENT ========================-->

<article role="main">
<div id="wrapper">


<hgroup>
  <a id="chapter_title" class="section-anchor"></a>
  <h1>Chapter 9</h1>
  <h1>Working with HTML5 Drag-and-Drop</h1>
</hgroup>

<p>Traditional drag-and-drop has been popular with users since the days of the original Apple Macintosh. But today’s computers and mobile devices have much more sophisticated drag-and-drop behavior. Drag-and-drop is used in file management, transferring data, diagramming, and many other operations where moving an object is more naturally envisioned with a gesture than a key command. Ask developers on the street what drag-and-drop encompasses, and you are likely to get a myriad of different answers depending on their favorite programs and current work assignments. Ask non-technical users about drag-and-drop, and they may stare at you blankly; the feature is now so ingrained into computing that it does not often get called out by name anymore.</p>

<p>And yet, HTML has not had drag-and-drop as a core feature in its first 15 years of existence. Although some developers have used the built-in ability to handle low-level mouse events as a way to hack up primitive drag-and-drop, those efforts paled in comparison to the type of drag-and-drop features that have been available in desktop applications for decades. With the arrival of a well-specified set of drag-and-drop functionality, HTML applications have advanced one step closer to matching the capabilities of their desktop counterparts.</p>

<section id="sec2_9">
<a id="hdr_sec2_9" class="section-anchor"></a>

<h2>Web <span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">Web</span></span>Drag-and-Drop: The Story So Far</h2>
<p>You may have seen examples of drag-and-drop on the Web already and are wondering if these are uses of HTML5 drag-and-drop. The answer? Probably not.</p>

<p>The reason is that HTML and DOM have exposed low-level mouse events since the early days of DOM events, and that has been sufficient for creative developers to craft a rudimentary drag-and-drop capability. When coupled with CSS positioning, it is possible to approximate a drag-and-drop system through the creation of complex JavaScript libraries and a firm knowledge of DOM events.</p>

<p>For example, by handling the following DOM events, it is possible to move items around in a web page if you code a set of logical steps (and some caveats):</p>
<ul>
<li>
<p><code>mousedown</code>: The user is starting some mouse operation. (Is it a drag or just a click?)</p>
</li>
<li>
<p><code>mousemove</code>: If the mouse is not up yet, a move operation is starting. (Is it a drag or a select?)</p>
</li>
<li>
<p><code>mouseover</code>: The mouse has moved over an element. (Is it one of the ones I want to drop on?)</p>
</li>
<li>
<p><code>mouseout</code>: The mouse has left an element that will no longer be a possible place to drop. (Do I need to draw feedback?)</p>
</li>
<li>
<p><code>mouseup</code>: The mouse has released, possibly triggering a drop operation. (Should the drop complete on this location based on where it started from?)</p>
</li>
</ul>
<p>Although modeling a crude drag-and-drop system using low-level events is possible, it suffers from some notable drawbacks. First, the logic necessary to handle the mouse events is more complex than you might imagine, as each of the listed events has many edge cases that must be accounted for. Although some were in the previous list, the reality is that there are enough of them to warrant their own chapter. During these events, CSS must be carefully updated to provide feedback to the user about the possibility of dragging or dropping at any particular location.</p>

<p>However, an even more <span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">web</span></span>serious drawback is that this type of ad hoc drag-and-drop implementation relies on total control of the system. If you try mixing your app content with other content in the same page, things quickly spiral out of control when different developers start using events for their own means. Similarly, if you try to drag-and-drop content from someone else’s code, you may have trouble unless the two codebases are carefully coordinated beforehand. Also, ad hoc drag-and-drop does not interact with the user’s desktop or work across windows.</p>

<p>The new HTML5 drag-and-drop API has been designed to address these limitations, borrowing from the way drag-and-drop has been provided in other user interface frameworks.</p>

<aside>
<h3>Note</h3>
<p>Even when properly implemented, beware of the limitations of drag-and-drop in any application. Mobile devices that use drag gestures to navigate might not function correctly if drag behavior is overridden. Also, drag-and-drop can interfere with drag selection. Take care to use it sparingly and appropriately.</p>

</aside>
</section>

<section id="sec3_9">
<a id="hdr_sec3_9" class="section-anchor"></a>

<h2>Overview of HTML5 Drag-and-Drop</h2>
<p>If you have used the drag-and-drop APIs in programming technologies such as Java or Microsoft MFC, then you’re in luck. The new HTML5 drag-and-drop API is closely modeled on the concepts of these environments. Getting started is easy, but mastering the new functionality means that you will need to become acquainted with a new set of DOM events, though this time at a higher level of abstraction.</p>

<section id="sec4_9">
<a id="hdr_sec4_9" class="section-anchor"></a>

<h3>The Big Picture</h3>
<p>The easiest way to learn the new API is to map it to the concepts with which you are already familiar. If you are reading a book on pro HTML5 programming, we’ll make a bold assumption that you are experienced with using drag-and-drop in your day-to-day computing. Nonetheless, we can start by putting some standard terms on the major concepts.</p>

<p>As shown in Figure <span class="internal-reference" id="ir_fig1_9">9-1</span>, when you (as a user) start a drag-and-drop operation, you start by clicking and dragging the pointer. The item or region where you began the drag is known as the<span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary"><strong>drag source</strong></span></span> <strong>drag source</strong>. When you release the pointer and complete the operation, the region or item you are targeting at the end is known as the<span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary"><strong>drop target</strong></span></span> <strong>drop target</strong>. As the mouse moves across the page, you may traverse a series of drop targets before you actually release the mouse.
</p>

<figure id="fig1_9" class="image"><img src="images/ch9/fig9-1.jpg"><figcaption>Figure 9-1. Drag sources and drop targets</figcaption></figure>

<p>So far, so good. But simply holding down the mouse and moving it to another part of an application is not what constitutes a drag-and-drop. Rather, it is the feedback during the operation that makes for a <span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">successful interaction</span></span>successful interaction. Consider your own uses of drag-and-drop in past experiences; the ones that are the most intuitive are those where the system is giving constant updates to let you know what will happen if you release at this point in time:</p>
<ul>
<li>
<p>Does the cursor indicate that the current position is a valid drop target, or does it imply a rejection with a “forbidden” cursor indicator?</p>
</li>
<li>
<p>Does the cursor imply to the user that the operation will be a move, link, or a copy, such as with a “plus” sign indicator on the cursor?</p>
</li>
<li>
<p>Does the area or target you are hovering over change its appearance in any way to indicate that it is currently selected as a drop if you release right now?</p>
</li>
</ul>
<p>In order to give similar feedback<span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">feedback</span></span> to users over the course of an HTML drag-and-drop operation, the browsers will emit a whole slew of events over the course of a single drag. This proves quite handy, as during these events we will have full power to change the DOM and style of the page elements to give just the type of feedback that users will be expecting.</p>

<p>Beyond the drag source and drop target, there is one more key concept to learn in the new API: the<span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">data transfer</span></span> <strong>data transfer</strong>. The specification describes the data transfer as the set of objects used to expose the drag data store that underlies a drag-and-drop operation. However, it may be easier just to think of the data transfer as being the central control of drag-and-drop. The operation type (e.g., move, copy, or link), the image to use as feedback during the drag, and the retrieval of the data itself are all managed here.</p>

<p>Regarding the data itself, the <code>dataTransfer</code> mechanism for completing the drop directly addresses one of the limitations of the old ad hoc drag-and-drop techniques described previously. Instead of forcing all drag sources and drop targets to be aware of each other, the data transfer mechanism works similar to a network protocol negotiation. In this case, the negotiation is performed via<span class="index-term"><span class="primary">Multipurpose Internet Mail Exchange (MIME)</span></span> Multipurpose Internet Mail Exchange <span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">MIME types</span></span>(MIME) types.</p>

<aside>
<h3>Note</h3>
<p>MIME types are the same types used to attach files to e-mail. They are an Internet standard that is used pervasively in all types of Web traffic, and they are very common in HTML5. In short, MIME types are standardized text strings used to classify the type of unknown content, such as “text/plain” for plain text and “image/png” for PNG images.</p>

</aside><p>The purpose of using MIME types is to allow the source and target to negotiate on which format best suits the needs of the drop target. As shown in Figure <span class="internal-reference" id="ir_fig2_9">9-2</span>, during a drag start, the <code>dataTransfer</code> object is loaded up with data representing all reasonable types, or “flavors,” by which the data can be transferred. Then, when the drop completes, the drop handler code can scan the available types of data and decide which MIME type format best suits its needs.

</p>
<figure id="fig2_9" class="image"><img src="images/ch9/fig9-2.jpg"><figcaption>Figure 9-2. Drag and drop<span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">negotiation, data flavors</span></span> negotiation of data “flavors”</figcaption></figure><p>For example, imagine a list item in a web page representing a person. There are many different ways to represent the data for a person; some are standard, some are not. When a drag starts on a particular person’s list item, the drag start handler can declare that the person’s data is available in a few formats, as shown in Table <span class="internal-reference" id="ir_tab1_9">9-1</span>.
</p>

<figure class="table">
  <figcaption>Table 9-1. Examples of MIME Types in Data Transfer of a Person</figcaption>
  <table id="tab1_9">
  <thead><tr>
  <th>MIME Type</th>
  <th>Result</th>
  </tr></thead>
  <tbody>
  <tr>
  <td>text/plain</td>
  <td>A standard MIME type for unformatted text. We can use it as the most common representation, such as the person’s name.</td>
  </tr>
  <tr>
  <td>image/png</td>
  <td>A standard MIME type for PNG images. Here, it could represent the person’s picture in PNG format.</td>
  </tr>
  <tr>
  <td>image/jpeg</td>
  <td>The standard MIME type for JPEG images. It could be used to transfer the person’s picture in that format.</td>
  </tr>
  <tr>
  <td>text/x-age</td>
  <td>A non-standard MIME type (as indicated by the x- prefix). We could use this format to transfer our own types of information, such as the person’s age.</td>
  </tr>
  </tbody>
  </table>
</figure>



<p>When the drop completes, the drop handler can query for a list of available data types. From the provided list, the handler can choose which type is most appropriate. A text list drop target may choose to grab the text/plain “flavor” of data to <span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">data retrieval</span></span>retrieve the person’s name, while a more advanced control might choose to retrieve and display the person’s PNG image as a result of the drop. And, if the source and target have coordinated on non-standard types, the target could also retrieve the person’s <span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">negotiation, data flavors</span></span>age at the time of the drop (see Figure <span class="internal-reference" id="ir_fig2_9">9-2</span>).</p>

<p>It is this negotiation process that allows for drag sources and drop targets to be decoupled. As long as the drag sources provide data in a choice of MIME types, the drop target can choose which format suits its operation the best, even if the two came from different developers. In later sections of this chapter, we’ll explore how even more unusual MIME types, such as files, can be used.</p>
</section>

<section id="sec5_9">
<a id="hdr_sec5_9" class="section-anchor"></a>

<h3>Events to Remember</h3>
<p>Now that we’ve explored the key concepts of the drag-and-drop API, let’s focus on the <span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">events</span></span>events that can be used throughout the process. As you’ll see, the events operate at a higher level than the mouse events previously utilized to mock up a drag-and-drop system. However, drag-and-drop events extend the DOM mouse event. Therefore, you still have access to the low-level mouse information, such as coordinates, if you need it.</p>
</section>

<section id="sec6_9">
<a id="hdr_sec6_9" class="section-anchor"></a>

<h3>Propagation and Prevention<span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">propagation and prevention</span></span>
</h3>
<p>But before we focus on drag and-drop-itself, let’s refresh on two DOM event functions that have been around since the browsers standardized on DOM Level 3 events: the <span class="index-term"><span class="primary">stopPropagation</span></span><code>stopPropagation</code> and <span class="index-term"><span class="primary">preventDefault</span></span><code>preventDefault</code> functions.</p>

<p>Consider the case where one element in a page is nested inside another element. We will refer to them as the child and parent elements, respectively. The child takes up some, but not all, of the visible space of the parent. Although we are only referring to two elements in our example, in practice a web page often has many levels of nesting.</p>

<p>When a user clicks a mouse on the child, which element should actually receive the event: the child, the parent, or both? And if both, in which order? The answer to this question was settled by the World Wide Web Consortium (W3C) in the DOM events specification. Events flow from a parent, through intermediaries, and down to the most specific child first in a process known as <span class="index-term"><span class="primary">Event capture process</span></span>“event capture.” Once the child has had access to the event, the event flows back up the element hierarchy via a process known as <span class="index-term"><span class="primary">Event building process</span></span>“event bubbling.” Together, these two flows allow developers to catch and process the event in the way that is most suitable to their page architecture. Only elements with handlers actually registered will process the event, which keeps the system lightweight. The overall approach is a compromise among different behaviors from multiple browser vendors, and it is consistent with other native development frameworks, some of which capture and some of which bubble.</p>

<p>However, at any time a handler can call the <span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">propagation and prevention</span></span><code>stopPropagation</code> function on the event, which will stop it from further traversing down the event capture chain or up through the bubbling phase.</p>

<aside>
<h3>Note</h3>
<p>Microsoft has provided a great interactive demo of event models at <code>http://ie.microsoft.com/testdrive/HTML5/ComparingEventModels</code>.</p>

</aside><p>Browsers also have default implementations for how some events will be handled. For example, when a user clicks on a page link, the default behavior is to navigate the browser to the destination specified by the link. Developers can prevent this by intercepting the event in a handler and calling <code>preventDefault</code> on it. This allows code to override the default behaviors of some built-in events. It is also how a developer can cancel a drag-and-drop operation in an event handler.</p>

<p>Both <code>stopPropagation</code><span class="index-term"><span class="primary">stopPropagation</span></span> and <code>preventDefault</code><span class="index-term"><span class="primary">preventDefault</span></span> will be handy in our examples of the drag-and-drop API.</p>
</section>

<section id="sec7_9">
<a id="hdr_sec7_9" class="section-anchor"></a>

<h3>Drag-and-Drop Event Flow<span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">event flow</span></span>
</h3>
<p>When a user initiates a drag-and-drop operation in an HTML5-ready browser, a series of events trigger at the start and continue throughout the course of the whole operation. We will examine them in turn here.</p>

<section id="sec27_9">
<a id="hdr_sec27_9" class="section-anchor"></a>

<h4>dragstart</h4>
<p>The <span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">event flow</span><tertiary>dragstart</tertiary></span><code>dragstart</code> event is fired on an element in the page when the user begins to drag on it. In other words, once the mouse is down and the user moves the mouse, the <code>dragstart</code> is initiated. The <code>dragstart</code> event is of key importance, as it is the only event where the <code>dataTransfer</code> can have data set on it using the <code>setData</code> call. This means that in a <code>dragStart</code> handler, the possible data types need to be set up so that they can be queried at the end of the drop, as described previously.</p>

<aside>
<h3>Interception!</h3>
<p><strong>Brian says</strong>: “If you are wondering why the data types can only be set during the <code>dragStart</code> event, there’s actually a very good reason for that.</p>

<p>Because drag-and-drop has been designed to work across windows and across content from various sources, it would be a security risk if <code>drag</code> event listeners were able to insert or replace data when the drag passed over them. Imagine a malicious section of code event listeners inserted that queried and replaced drag data of any drag travelling by. This would misrepresent the intentions of the drag source, and as such any data replacements after the start are forbidden.”</p>

</aside>
</section>

<section id="sec28_9">
<a id="hdr_sec28_9" class="section-anchor"></a>

<h4>drag</h4>
<p>The <code>drag</code> event can be thought of as the continuous event of a drag operation. As the user moves the mouse cursor around the page, the <code>drag</code> event is called repeatedly on the <span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">event flow</span><tertiary>drag</tertiary></span>drag <em>source</em>. The <code>drag</code> event will fire a few times each second during the operation. Although the visuals of the drag feedback can be modified during a <code>drag</code> event, the data on the <code>dataTransfer</code> is off-limits.</p>

</section>
<section id="sec29_9">
<a id="hdr_sec29_9" class="section-anchor"></a>

<h4>dragenter</h4>
<p>When the drag crosses into a new element on the page, a <span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">event flow</span><tertiary>dragenter</tertiary></span><code>dragenter</code> event fires on that element. This event is a good time to set drop feedback on the element based on whether or not it can receive the drop.</p>

</section>

<section id="sec30_9">
<a id="hdr_sec30_9" class="section-anchor"></a>

<h4>dragleave</h4>
<p>Conversely, the browser will fire a <span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">event flow</span><tertiary>dragleave</tertiary></span><code>dragleave</code> event whenever the user moves the drag out of the element where dragenter was previously called. Drop feedback can be restored at this time, as the mouse is no longer<span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">event flow</span><tertiary>dragleave</tertiary></span> over this target.</p>

</section>
<section id="sec31_9">
<a id="hdr_sec31_9" class="section-anchor"></a>

<h4>dragover</h4>
<p>The <code>dragover</code><span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">event flow</span><tertiary>dragover</tertiary></span> event is called at frequent intervals as the mouse moves over an element during a drag operation. Unlike its counterpart <code>drag</code> event, which is called on the drag source, this event is called on the current target of the mouse.</p>

</section>
<section id="sec32_9">
<a id="hdr_sec32_9" class="section-anchor"></a>

<h4>drop</h4>
<p>The <code>drop</code> event<span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">event flow</span><tertiary>drop</tertiary></span> is called on the current mouse target when the user releases the mouse. Based on the result of the <code>dataTransfer</code> object, this is where the code to handle the drop should be executed.</p>

</section>
<section id="sec33_9">
<a id="hdr_sec33_9" class="section-anchor"></a>

<h4>dragend</h4>
<p>The final event in the chain, <span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">event flow</span><tertiary>dragend fire</tertiary></span><code>dragend</code> fires on the drag source, indicating that the drag completed. It is particularly suitable for cleaning up the state used during the drag, as it is called regardless of whether or not the drop completes.</p>

<p>Altogether, there are plenty of ways for you to intercept the drag-and-drop operations and take action. The drag-and-drop event chain is summarized in Figure <span class="internal-reference" id="ir_fig3_9">9-3</span>.

</p>
<figure id="fig3_9" class="image"><img src="images/ch9/fig9-3.jpg"><figcaption>Figure 9-3. Drag-and-drop event flow<span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">event flow</span></span>
</figcaption></figure>

</section>

</section>

<section id="sec8_9">
<a id="hdr_sec8_9" class="section-anchor"></a>

<h3>Drag Participation<span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">event flow</span><tertiary>drag participation</tertiary></span>
</h3>
<p>Now that you’ve seen the different events that can be triggered during a drag-and-drop operation, you might be wondering what it takes to mark elements in your web application as draggable. That’s easy!</p>

<p>Aside from a few elements—such as text controls—elements in a page are not draggable by default. In order to mark a specific element as draggable, however, all you need to do is add one attribute: draggable.</p>

<pre><code>&lt;div id=”myDragSource” <strong>draggable=”true”</strong>&gt;</code></pre>
<p>Simply by adding that attribute, you cause the browser to fire the aforementioned events. Then, you only need to add the event handlers to manage them.</p>
</section>

<section id="sec9_9">
<a id="hdr_sec9_9" class="section-anchor"></a>

<h3>Transfer and Control</h3>
<p>Before we move into our example, let’s assess the<span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">event flow</span><tertiary>transfer and control</tertiary></span> <code>dataTransfer</code> object in more detail. The <code>dataTransfer</code> is available from every drag-and-drop event, as shown in Listing 9-1.</p>

<figure class="listing"><figcaption>Listing 9-1. Retrieving the dataTransfer Object</figcaption><pre><code data-cm-mode="text/javascript">Function handleDrag(evt) {
    var transfer = evt.dataTransfer;
    // …
}</code></pre></figure>

<p>As discussed in Listing 9-1, the <code>dataTransfer</code> is used to get and set the actual drop data during the negotiation between source and target. This is done using the following functions and properties:</p>
<ul>
<li>
<p><code>setData(format, data)</code>: Calling this function during <code>dragStart</code> allows you to register one transfer item under a MIME type format.</p>
</li>
<li>
<p><code>getData(format)</code>: This function allows the registered data item for a given type to be retrieved.</p>
</li>
<li>
<p><code>types</code>: This property returns an array of all currently registered formats.</p>
</li>
<li>
<p><code>items</code>: This property returns a list of all items and their associated formats together.</p>
</li>
<li>
<p><code>files</code>: This property returns any files associated with the drop. This is discussed in more detail in a later section.</p>
</li>
<li>
<p><code>clearData()</code>: Calling this function with no argument clears out all registered data. Calling it with a format argument removes only that specific registration.</p>
</li>
</ul>
<p>Two more functions can be used to alter the feedback during a drag operation:</p>
<ul>
<li>
<p><code>setDragImage(element, x, y)</code><span class="index-term"><span class="primary">setDragImage</span></span>: Tells the browser to use an existing image element as the drag image, which will display alongside the cursor to hint to the user about the drag operation effects. If x and y coordinates are provided, then those coordinates will be considered as the drop point for the mouse.</p>
</li>
<li>
<p><code>addElement(element)</code><span class="index-term"><span class="primary">addElement</span></span>: By calling this function with a provided page element, you tell the browser to draw that element as a drag feedback image.</p>
</li>
</ul>
<p>A final set of properties allows the developer to set and/or query the types of drag operations that are allowed:</p>
<ul>
<li>
<p><code>effectAllowed</code><span class="index-term"><span class="primary">effectAllowed</span></span>: Setting this property to one of none, copy, copyLink, copyMove, link, linkMove, move, or all tells the browser that only the type(s) of operations listed here are to be allowed for the user. For example, if copy is set, only copy operations will be allowed, and move or link operations will be prevented.</p>
</li>
<li>
<p><code>dropEffect</code><span class="index-term"><span class="primary">dropEffect</span></span>: This property can be used to determine which type of operation is currently underway or set to force a particular operation type. The types of operations are copy, link, and move. Or, the value none can be set to prevent any drop from happening at that point in time.</p>
</li>
</ul>
<p>Together, these operations give a fine level of <span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">event flow</span><tertiary>transfer and control</tertiary></span>control over drag-and-drop. Now, let’s see them in action.</p>

</section>
</section>

<section id="sec10_9">
<a id="hdr_sec10_9" class="section-anchor"></a>

<h2>Building an Application with Drag-and-Drop</h2>
<p>Using the concepts we’ve already learned, we’ll build a simple drag-and-drop page in the theme of our Happy Trails Running Club. This page lets the club race organizers drag members of the club into one of two lists: racers and volunteers. In order to sort them into competitive groups, racers will be sorted by their age. Volunteers, on the other hand, are only sorted by their names, as their ages don’t matter when they are not competing.</p>

<p>The sorting<span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">racers sorted</span></span> of the lists is done automatically. The application itself will show feedback indicating where proper drop areas are for members into the two lists as shown in Figure <span class="internal-reference" id="ir_fig4_9">9-4</span>.

</p>
<figure id="fig4_9" class="image"><img src="images/ch9/fig9-4.png"><figcaption>Figure 9-4. Example page showing <span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">racers sorted</span></span>racers sorted into lists</figcaption></figure>

<p>All of the code for this example is included with the book’s samples. We’ll step through the page and explain how it works in practice.</p>

<p>First, let’s look at the markup for the page. At the top, we’ve declared the data on our club members (see Listing 9-2).</p>

<figure class="listing"><figcaption>Listing 9-2. Markup Displaying <span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">draggable member names and ages</span></span> Draggable Member Names and Ages</figcaption><pre><code data-cm-mode="text/html">&lt;p&gt;Drag members to either the Racers or Volunteers list.&lt;/p&gt;
  
&lt;ul id="members"&gt;
  &lt;li draggable="true" data-age="38"&gt;Brian Albers&lt;/li&gt;
  &lt;li draggable="true" data-age="25"&gt;Frank Salim&lt;/li&gt;
  &lt;li draggable="true" data-age="47"&gt;Jennifer Clark&lt;/li&gt;
  &lt;li draggable="true" data-age="18"&gt;John Kemble&lt;/li&gt;
  &lt;li draggable="true" data-age="20"&gt;Lorraine Gaunce&lt;/li&gt;
  &lt;li draggable="true" data-age="30"&gt;Mark Wang&lt;/li&gt;
  &lt;li draggable="true" data-age="41"&gt;Morgan Stephen&lt;/li&gt;
  &lt;li draggable="true" data-age="39"&gt;Peter Lubbers&lt;/li&gt;
  &lt;li draggable="true" data-age="33"&gt;Vanessa Combs&lt;/li&gt;
  &lt;li draggable="true" data-age="54"&gt;Vivian Lopez&lt;/li&gt;
&lt;/ul&gt;</code></pre></figure><p>As you can see, each of the<span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">draggable member names and ages</span></span> member list elements is marked as <code>draggable</code>. This tells the browser to let drags start on each of them. The next thing you’ll notice is that the age of a given member is encoded as a data attribute. The data- notation is a standard way to store non-standard attributes on an HTML element.</p>

<p>Our next section contains the target lists (see Listing 9-3).</p>

<figure class="listing"><figcaption>Listing 9-3. Markup for <span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">drop list target</span></span> Drop List Targets</figcaption><pre><code data-cm-mode="text/html">&lt;div class="dropList"&gt;
&lt;fieldset id="racersField"&gt;
&lt;legend&gt;Racers (by Age):&lt;/legend&gt;
&lt;ul id="racers"&gt;&lt;/ul&gt;
&lt;/fieldset&gt;
&lt;/div&gt;
&lt;div class="dropList"&gt;
&lt;fieldset id="volunteersField"&gt;
&lt;legend&gt;Volunteers (by Name):&lt;/legend&gt;
&lt;ul id="volunteers"&gt;&lt;/ul&gt;
&lt;/fieldset&gt;
&lt;/div&gt;</code></pre></figure>

<p>The unordered lists identified as racers and volunteers are the ultimate destinations where our members will be inserted. The fieldsets surrounding them serve as functional equivalents of a moat around a castle. When the user drags into the fieldset, we’ll know that they have exited the contained list and we’ll update our visual feedback accordingly.</p>

<p>Speaking of feedback, there are a few CSS styles in our page that are important to note (see Listing 9-4).</p>

<figure class="listing"><figcaption>Listing 9-4. Styles for Drag-and-Drop <span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">demo, styles for</span></span> Demo</figcaption><pre><code data-cm-mode="text/css">#members li {
  cursor: move;
}
.highlighted {
  background-color: yellow;
}
.validtarget {
  background-color: lightblue;
}</code></pre></figure>

<p>First, we make sure that every member in our source list shows a move cursor. This gives a hint to the user that the items are draggable.</p>

<p>Next, we define two style classes: highlighted and validtarget. These are used to draw background colors on our lists as the drag-and-drop is in progress. The validtarget background will be displayed on our destination lists during the entire drag to hint that they are valid drop targets. When the user actually moves a member over a target list it will change to the highlighted style, indicating that the user is actually over a drop target.</p>

<p>To keep track of the state on our page, we’ll declare a few variables (see Listing 9-5).</p>

<figure class="listing"><figcaption>Listing 9-5. List Item <span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">variable declaration</span></span> Declarations</figcaption><pre><code data-cm-mode="text/javascript">// these arrays hold the names of the members who are
// chosen to be racers and volunteers, respectively
var racers = [];
var volunteers = [];

// these variables store references to the visible
// elements for displaying who is a racer or volunteer
var racersList;
var volunteersList;</code></pre></figure>
    
    <p>The first two variables will serve as internal arrays, which keep track of which members are in the racers and volunteers lists.</p>

<p>The second two variables are only going to be used as handy references to the unordered lists containing the visual display of members in the respective lists.</p>

<p>Now, let’s set all of our page items up to handle drag-and-drop (see Listing 9-6).</p>

<figure class="listing"><figcaption>Listing 9-6. Event Handler Registration <span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">event handler registration</span></span>
</figcaption><pre><code>function loadDemo() {
  racersList = document.getElementById("racers");
  volunteersList = document.getElementById("volunteers");
  
  // our target lists get handlers for drag enter, leave, and drop
  var lists = [racersList, volunteersList];
  [].forEach.call(lists, function(list) {
    list.addEventListener("dragenter", handleDragEnter, false);
    list.addEventListener("dragleave", handleDragLeave, false);
    list.addEventListener("drop", handleDrop, false);
  });
  
  // each target list gets a particular dragover handler
  racersList.addEventListener("dragover", handleDragOverRacers, false);
  volunteersList.addEventListener("dragover", handleDragOverVolunteers, false);
  
  // the fieldsets around our lists serve as buffers for resetting
  // the style during drag over
  var fieldsets = document.querySelectorAll("#racersField, #volunteersField");
  [].forEach.call(fieldsets, function(fieldset) {
    fieldset.addEventListener("dragover", handleDragOverOuter, false);
  });
  
  // each draggable member gets a handler for drag start and end
  var members = document.querySelectorAll("#members li");
  [].forEach.call(members, function(member) {HTML5 drag-and-dropevent handler registration
    member.addEventListener("dragstart", handleDragStart, false);
    member.addEventListener("dragend", handleDragEnd, false);
  });
}

window.addEventListener("load", loadDemo, false);</code></pre></figure>
    
<p>When the window initially loads, we call a loadDemo function to set up all of our drag-and-drop event handlers. Most of them don’t need event capture, and we will set the capture argument accordingly.</p>

<p>Both the racersList and the volunteersList will receive handlers for dragenter, dragleave, and drop events, as these are fired on drop targets. Each list will receive a separate dragover event listener, as that will allow us to easily update the drag feedback based on the target the user is currently dragging over.</p>

<p>As mentioned previously, we are also adding dragover handlers on the fieldsets surrounding the target lists. Why do we do this? To make it easier to detect when a drag has exited our target lists. Although it is easy for us to detect that a user has dragged an item over our list, it is not so easy to determine when the user has dragged an item <em>out</em> of our list. This is because the dragleave events fire both when an item is dragged out of our list <em>and</em> when the item is dragged over a child already in the destination list. Essentially, when you drag from a parent element over one of its contained children, the drag exits the parent and enters the child. Although this provides a lot of information, it actually makes it tricky to know when a drag is leaving the outer boundaries of a parent element. Therefore, we will use a notification<span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">notification</span></span> that we are dragging over an element <em>surrounding</em> our list to inform us that we have exited the list. More information on this will be provided later.</p>

<aside>
<h3>This Way to the eGRESS</h3>
<p><strong>Brian says</strong>: “One of the more counter-intuitive aspects of the drag-and-drop specification is the order of events. Although you might expect that a dragged item would exit one target before it entered another, you’d be wrong!</p>

<p>The order of events fired during a drag from element A into element B is that a dragenter event is fired on element B before the dragleave is fired on element A. This maintains consistency with the HTML mouse event specification, but it is one of the odder aspects of the design. There are more of these quirks ahead, to be sure.”</p>

</aside>

<p>Our final set of handlers registers dragstart and dragend listeners on every draggable club member in our initial list. We will use them to initialize and clean up any drag. You might notice that we don’t add handlers for the drag event, which fires periodically on the drag source. As we will not be updating the appearance of the dragged item, it will be unnecessary for our example.</p>

<p>Now, we’ll go through the actual event handlers in turn, based on the order in which they generally fire (see Listing 9-7).</p>

<figure class="listing"><figcaption>Listing 9-7. dragstart Event Handler</figcaption><pre><code>// called at the beginning of any drag
function handleDragStart(evt) {
  
  // our drag only allows copy operations
  evt.effectAllowed = "copy";
  
  // the target of a drag start is one of our members
  // the data for a member is either their name or age
  evt.dataTransfer.setData("text/plain", evt.target.textContent);
  evt.dataTransfer.setData("text/html", evt.target.dataset.age);
  
  // highlight the potential drop targets
  racersList.className = "validtarget";
  volunteersList.className = "validtarget";
  
  return true;
}</code></pre></figure>
    
<p>The handler for <span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">dragstart handler</span></span>dragstart is called on the draggable item where the users begin the operation. It is a somewhat special handler, as it sets up the capabilities of the entire process. First, we set the effectAllowed, which tells the browser that only copies are allowed when dragging from this element—no moves or links.</p>

<p>Next, we preload all of the possible flavors of data that might be requested at the end of a successful drop. Naturally, we want to support a text version of our element, so we set the MIME type text/plain to return the text inside our draggable node, (i.e., the club member’s name).</p>

<p>For our second data flavor, we would like the drop operation to transfer another type of data about the drag source; in our case, it is the age of the club member. Unfortunately, due to bugs, not all browsers support user-defined MIME types such as application/x-age yet, which would be the best fit for such an arbitrary flavor. Instead, we will reuse another commonly supported MIME format—text/html—to stand in for an age flavor for now. Hopefully the WebKit browsers will address this limitation soon.</p>

<p>Don’t forget that the dragstart handler is the only handler where data transfer values can be set. Attempting to do so in other handlers will fail in order to prevent rogue code from changing the data mid-drag.</p>

<p>Our final action in the start handler is purely for demo purposes. We will change the background color of our potential drop target lists to give the user a hint about what is possible.</p>

<p>Our next handlers will process events as the dragged item enters and leaves elements on the page (see Listing 9-8).</p>

<figure class="listing"><figcaption>Listing 9-8. dragenter and dragleave Event Handlers</figcaption><pre><code>// stop propagation and prevent default drag behavior
// to show that our target lists are valid drop targets
function handleDragEnter(evt) {
  evt.stopPropagation();
  evt.preventDefault();
  return false;
}

function handleDragLeave(evt) {
  return false;
}</code></pre></figure>
    
<p>The <span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">dragleave and dragenter</span></span>dragleave event is not used by our demo, and we handle it purely for illustrative purposes.</p>

<p>The dragenter event, however, can be handled and canceled by calling preventDefault on it when it is fired over a valid drop target. This informs the browser that the current target is a valid drop target, as the <em>default</em> behavior is to assume that any target is not a valid drop target.</p>

<p>Next, we will look at the dragover handlers (see Listing 9-9). Recall that these fire at regular intervals whenever the drag hovers over the elements in question.</p>

<figure class="listing"><figcaption>Listing 9-9. dragover Handler <span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">dragover Handler</span></span> for Outer Container</figcaption><pre><code data-cm-mode="text/javascript">// for better drop feedback, we use an event for dragging
// over the surrounding control as a flag to turn off
// drop highlighting
function handleDragOverOuter(evt) {
  
  // due to Mozilla firing drag over events to
  // parents from nested children, we check the id
  // before handling
  if (evt.target.id == "racersField")
    racersList.className = "validtarget";
    
  else if (evt.target.id == "volunteersField")
    volunteersList.className = "validtarget";
    
  evt.stopPropagation();
  return false;
}</code></pre></figure>
    
<p>Our first of three dragover handlers will be used only to adjust the drag feedback. Recall that it is difficult to detect when a drag has left a target, such as our intended racers and volunteers lists. Therefore, we use a drag movement over the fieldsets surrounding the lists to indicate that the drag has exited the vicinity of the lists. This allows us to turn off the drop highlighting on the lists accordingly.</p>

<p>Note that our simple code, as listed, will change the CSS className repeatedly if the user hovers in the fieldset area. For optimization purposes, it is good practice to only change the className once, as it may cause the browser to do more work than necessary.</p>

<p>Finally, we stop propagation of the event to any other handlers in the page. We don’t want any other handlers to override our logic. In the next two dragover handlers, we take a different approach (see Listing 9-10).</p>

<figure class="listing"><figcaption>Listing 9-10. dragover Handler <span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">dragover Handler</span></span> for Target Lists</figcaption><pre><code data-cm-mode="text/javascript">// if the user drags over our list, show
// that it allows copy and highlight for better feedback
function handleDragOverRacers(evt) {
  evt.dataTransfer.dropEffect = "copy";
  evt.stopPropagation();
  evt.preventDefault();
  
  racersList.className = "highlighted";
  return false;
}

function handleDragOverVolunteers(evt) {
  evt.dataTransfer.dropEffect = "copy";
  evt.stopPropagation();
  evt.preventDefault();
  
  volunteersList.className = "highlighted";
  return false;
}</code></pre></figure>
    
<p>These two handlers, while somewhat verbose, are listed in full to clarify our demo. The first handles dragover events in the racers list, and the second handles dragover events identically in the volunteers list.</p>

<p>The first action we take is to set the dropEffect to indicate that only copies are allowed on this node, not moves or links. This is a good practice, even though our original dragstart handler already limited the drag-and-drop operation to be copy-only.</p>

<p>Next we prevent other handlers from accessing the event and cancel it. Canceling a dragover event has an important function: it tells the browser that the default operation—<em>not</em> allowing a drop here—is not valid. Essentially, we are telling the browser that it should not not allow a drop; and so, the drop is allowed. Although this may seem counter-intuitive, recall that preventDefault is used to tell the browser not to do its normal built-in operation for an event. For example, calling preventDefault on a click on a link tells the browser to not navigate to the link’s reference. The specification designers could have created a new event or API for this dragover, but they opted to keep to the API patterns that were already used throughout HTML.</p>

<p>We will also give the user visual feedback by changing the background color to yellow via the highlighted CSS class whenever the user drags over our lists.</p>

<p>The main work of the drag-and-drop is done in the <span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">drop handler</span></span>drop handler, which we examine next in Listing 9-11.</p>

<figure class="listing"><figcaption>Listing 9-11. Drop Handler for Target Lists</figcaption><pre><code>// when the user drops on a target list, transfer the data
function handleDrop(evt) {
  evt.preventDefault();
  evt.stopPropagation();
  
  var dropTarget = evt.target;
  
  // use the text flavor to get the name of the dragged item
  var text = evt.dataTransfer.getData("text/plain");
  
  var group = volunteers;
  var list = volunteersList;
  
  // if the drop target list was the racer list, grab an extra
  // flavor of data representing the member age and prepend it
  if ((dropTarget.id != "volunteers") &amp;&amp;
    (dropTarget.parentNode.id != "volunteers")) {
    text = evt.dataTransfer.getData("text/html") + ": " + text;
    group = racers;
    list = racersList;
  }
  
  // for simplicity, fully clear the old list and reset it
  if (group.indexOf(text) == -1) {
    group.push(text);
    group.sort();
    
    // remove all old children
    while (list.hasChildNodes()) {
        list.removeChild(list.lastChild);
    }
    
    // push in all new children
    [].forEach.call(group, function(person) {
        var newChild = document.createElement("li");
        newChild.textContent = person;
        list.appendChild(newChild);
    });
  }
  
  return false;
}</code></pre></figure>
    
<p>Once again, we start by preventing the default drop behavior and preventing the control from propagating to other handlers. The default drop event depends on the location and type of element dropped. For example, dropping an image dragged in from another source displays it in the browser window, and dropping a link into a window navigates to it by default. We want total control of drop behavior in our demo, so we cancel any default behaviors.</p>

<p>Recall that our demo shows how multiple data flavors set up in the dragstart can be retrieved from a dropped element. Here, we see how that retrieval completes. By default, we get the plain text data representing the club member’s name by using the text/plain MIME format. If the user drops into the volunteers list, this is sufficient.</p>

<p>However, if the user is dropping the club member into the racers list, we take one additional step to fetch the age of the club member, which we previously set using the text/html flavor during dragstart. We prepend it to the club member’s name to display both age and name in the racers list.</p>

<p>Our final block of code is a simple, albeit unoptimized, routine to clear out all previous members of the target list, add our new member (if he didn’t exist already), sort, and refill the list. The end result is a sorted list containing the old members and the newly dropped member, if he was not present before.</p>

<p>Regardless of whether or not the user completed the drag-and-drop, we need a dragend handler to clean up (see Listing 9-12).</p>

<figure class="listing"><figcaption>Listing 9-12. dragend Handler <span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">clean up process</span></span> for Clean Up</figcaption><pre><code data-cm-mode="text/javascript">    // make sure to clean up any drag operation
function handleDragEnd(evt) {
      
  // restore the potential drop target styles
  racersList.className = null;
  volunteersList.className = null;
  return false;
}</code></pre></figure>
    
<p>A dragend handler is called at the end of the drag, whether or not a drop actually occurred. If the user canceled the drag or completed it, the dragend handler is still called. This gives us a good place to clean up any state we changed at the beginning of the process. Not surprisingly, we reset the CSS classes of our lists to their default, unstyled state.</p>

<aside>
<h3>Sharing Is Caring</h3>
<p><strong>Brian says</strong>: “If you are wondering whether or not the drag-and-drop functionality is worth all of the event handler code, don’t forget one of the key benefits of the API: sharing drags across windows and even across browsers.</p>

<p>Because the design of HTML5 drag-and-drop was built to mirror that of desktop capabilities, it is not surprising that it also supports sharing across applications. You can try this out by loading our example in multiple browser windows and dragging members from one source list to the racers and volunteers lists of another window. Although our simple highlighting feedback was not designed for this case, the actual drop capability works across windows and even across browsers if they support the API.”</p>

</aside>
<p>Our drag-and-drop example is a simple one, but it illustrates the full capability of the API.</p>

<section id="sec11_9">
<a id="hdr_sec11_9" class="section-anchor"></a>

<h3>Getting Into the <span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">dropzone</span></span>dropzone</h3>
<p>If you’re thinking that handling all of the drag-and-drop events is complicated, you’re not alone. The authors of the specification have designed an alternative, shorthand mechanism to support drop events: the dropzone attribute.</p>

<p>The dropzone provides developers with a compact way to register that an element is willing to accept drops without coding up lengthy event handlers. The attribute consists of a few space-separated patterns that, when provided, allow the browser to automatically wire up the drop behavior for you (see Table <span class="internal-reference" id="ir_tab2_9">9-2</span>).
</p>

<figure class="table">
  <figcaption>Table 9-2. Tokens of the dropzone Attribute</figcaption>
  <table id="tab2_9">
  <thead><tr>
  <th>Token</th>
  <th>Result</th>
  </tr></thead>
  <tbody>
  <tr>
  <td>copy, move, link</td>
  <td>Only one of the three operation types is allowed. If none is specified, copy is assumed.</td>
  </tr>
  <tr>
  <td>s:&lt;mime&gt;</td>
  <td>Using the characters s: followed by a MIME type indicates that data of that MIME type is allowed to be dropped on the element.</td>
  </tr>
  <tr>
  <td>f:&lt;mime&gt;</td>
  <td>Using the characters f: followed by a MIME type indicates that files of that MIME type are allowed to be dropped on the element.</td>
  </tr>
  </tbody>
  </table>
</figure>

<p>Borrowing from our example application, the racers list element could be specified as having the following attribute:</p>

<pre><code>&lt;ul id="racers" dropzone=”copy s:text/plain s:text/html” <span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">dropzone</span></span>ondrop=”handleDrop(event)”&gt;</code></pre>
<p>This provides a quick way of telling the browser that copy operations for elements that support either the plain text or HTML data format are allowed to drop on our list.</p>

<p>The dropzone is not supported by most major browser vendors at the time of writing, but support for it is likely forthcoming.</p>

</section>
</section>

<section id="sec12_9">
<a id="hdr_sec12_9" class="section-anchor"></a>

<h2>Handling Drag-and-Drop for Files<span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">file handling</span></span>
</h2>
<p>If you’ve ever wanted an easier way to add files to your web application, or you’ve wondered how some of the newest sites allow you to drag files directly into a page and upload them, the answer is the HTML5 File API. Although the size and status of the entire <span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">file handling</span><tertiary>W3C file API</tertiary></span>W3C File API is out of scope for this discussion, many browsers already support a subset of the standard, which allows files to be dragged into an application.</p>

<aside>
<h3>Note</h3>
<p>The W3C File API is documented online at <code>www.w3.org/TR/FileAPI</code>.</p>

</aside><p>The File API contains functionality for asynchronously reading files in a web page, uploading them to servers while tracking process, and turning files into page elements. However, affiliated specifications such as drag-and-drop use a subset of the File API, and that is the area where we will focus our attention in this chapter.</p>

<p>Recall that we’ve already alluded to file drag-and-drop twice in this chapter. First, the <span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">file handling</span><tertiary>dataTransfer object</tertiary></span>dataTransfer object contains a property named files, which will contain a list of files attached to the drag, if appropriate. For example, if a user drags a file or set of files in from the desktop into your application’s web page, the browser will fire drag-and-drop events where the dataTransfer.files object has a value. Additionally, browsers that support the previously mentioned dropzone attribute allow files of specific MIME types to be valid drops on an element by using the f: MIME type prefix.</p>

<aside>
<h3>Note</h3>
<p>Currently, the Safari browser <em>only</em> supports drag-and-drop operations for files. Drags initiated inside a page will fire most drag-and-drop events, but drop events only occur if the type of drag is a file.</p>

</aside><p>As usual, you cannot access the files during most drag-and-drop events, because they are protected for security reasons. Although some browsers might let you get access to the list of files during drag events, no browser will let you get access to the file data. In addition, the dragstart, drag, and dragend events that are fired at the drag source element are not triggered in a file drag-and-drop, as the source is the file system itself.</p>

<p>The file items<span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">file handling</span><tertiary>items</tertiary></span> in our file list support the following properties:</p>
<ul>
<li>
<p><strong>name</strong>: The full filename with extension</p>
</li>
<li>
<p><strong>type</strong>: The MIME type of the file</p>
</li>
<li>
<p><strong>size</strong>: The size of the file in bytes</p>
</li>
<li>
<p><strong>lastModifiedDate</strong>: The timestamp for when the file contents were last modified</p>
</li>
</ul>
<p>Let’s walk through a simple example of file drag-and-drop where we will show the characteristics of any file dropped onto our page, shown in Figure <span class="internal-reference" id="ir_fig5_9">9-5</span>. This code is contained in the <span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">file handling</span><tertiary>fileDrag.html</tertiary></span>fileDrag.html example included with the book.

</p>
<figure id="fig5_9" class="image"><img src="images/ch9/fig9-5.png"><figcaption>Figure 9-5. Demo page displaying the characteristics <span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">file handling</span><tertiary>fileDrag.html</tertiary></span> of dropped files</figcaption></figure><p>The HTML for our demo is actually quite simple (see Listing 9-13).</p>

<figure class="listing"><figcaption>Listing 9-13. Markup for File Drop Demo</figcaption><pre><code data-cm-mode="text/html">&lt;body&gt;
&lt;div id="droptarget"&gt;
&lt;div id="status"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;</code></pre></figure><p>We have only two elements in the page. A drop target where files will be dropped and a status display area.</p>

<p>As with our last example, we will register drag-and-drop event handlers during page load (see Listing 9-14).</p>

<figure class="listing"><figcaption>Listing 9-14. Loading and Initialization <span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">file handling</span><tertiary>file drop demo</tertiary></span> Code for File Drop Demo</figcaption><pre><code data-cm-mode="text/javascript">var droptarget;
// set the status text in our display
function setStatus(text) {
  document.getElementById("status").innerHTML = text;
}
// …
function loadDemo() {
  droptarget = document.getElementById("droptarget");
  droptarget.className = "validtarget";
  droptarget.addEventListener("dragenter", handleDragEnter, false);
  droptarget.addEventListener("dragover", handleDragOver, false);
  droptarget.addEventListener("dragleave", handleDragLeave, false);
  droptarget.addEventListener("drop", handleDrop, false);
  setStatus("Drag files into this area.");
}
window.addEventListener("load", loadDemo, false);
</code></pre></figure>

<p>This time, the drop target receives all of the event handlers. Only a subset of handlers is needed, and we can ignore events that take place at the drag source.</p>

<p>When the user drags files into our drop target, we will display what we know about the drop candidates (see Listing 9-15).</p>

<figure class="listing"><figcaption>Listing 9-15. File Drop Drag Enter Handler <span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">file handling</span><tertiary>file drop drag</tertiary></span>
</figcaption><pre><code>// handle drag events in the drop target
function handleDragEnter(evt) {
  // if the browser supports accessing the file
  // list during drag, we display the file count
  var files = evt.dataTransfer.files;
  if (files)
    setStatus("There are " + evt.dataTransfer.files.length + 
          " files in this drag.");
  else
    setStatus("There are unknown items in this drag.");
  droptarget.className = "highlighted";
  evt.stopPropagation();
  evt.preventDefault();
  return false;
}</code></pre></figure>
    
<p>Although some browsers allow access to the dataTransfer files mid-drag, we will handle the case where that information is off-limits. When the count is known, we will display it in the status.</p>

<p>Handling dragover and dragleave events is straightforward (see Listing 9-16).</p>

<figure class="listing"><figcaption>Listing 9-16. File Drop dragover and dragleave Handlers</figcaption><pre><code data-cm-mode="text/javascript">// preventing the default dragover behavior
// is necessary for successful drops
function handleDragOver(evt) {
  evt.stopPropagation();
  evt.preventDefault();
  return false;
}
// reset the text and status when drags leave
function handleDragLeave(evt) {
  setStatus("Drag files into this area.");
  droptarget.className = "validtarget";
  return false;
}</code></pre></figure>
    
<p>As always, we must cancel<span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">file handling</span><tertiary>dragover and dragleave handler</tertiary></span> dragover events to allow drops to be handled by our own code rather than the browser’s default behavior, which is usually to display them inline.</p>

<p>For a dragleave, we only set the status text and style to indicate that drops are no longer valid when the mouse leaves.</p>

<p>The bulk of our work is done in the drop handler (see Listing 9-17).</p>

<figure class="listing" data-listing="9-17" data-preview-height="300"><figcaption>Listing 9-17. File Drop Handler</figcaption><pre><code data-cm-mode="text/html">// handle the drop of files
function handleDrop(evt) {
  // cancel the event to prevent viewing the file
  evt.preventDefault();
  evt.stopPropagation();
  var filelist = evt.dataTransfer.files;
  var message = "There were " + filelist.length + " files dropped.";
  // show a detail list for each file in the drag
  message += "&lt;ol&gt;";
  [].forEach.call(filelist, function(file) {
    message += "&lt;li&gt;";
    message += "&lt;strong&gt;" + file.name + "&lt;/strong&gt; ";
    message += "(&lt;em&gt;" + file.type + "&lt;/em&gt;) : ";
    message += "size: " + file.size + " bytes - ";
    message += "modified: " + file.lastModifiedDate;
    message += "&lt;/li&gt;";
  });
  message += "&lt;/ol&gt;";
  setStatus(message);
  droptarget.className = "validtarget";
  return false;
}</code></pre></figure>

<p>As discussed previously, it is necessary to cancel the event using preventDefault so that the browser’s default drop code is never triggered.</p>

<p>Then, because we have more access to data in the drop handler than during the drag, we can inspect the files attached to the dataTransfer and discover the characteristics of the dropped files. In our example, we will merely display the properties of the files, but with full use of the HTML5 File API, you can read in the contents for local display or upload them to the server powering your application.</p>
</section>

<section id="sec13_9">
<a id="hdr_sec13_9" class="section-anchor"></a>

<h2>Practical Extras</h2>
<p>Sometimes there are techniques that don’t fit into our regular examples but which nonetheless apply to many types of HTML5 applications. We present to you a short, but common, practical extra here.</p>

<section id="sec14_9">
<a id="hdr_sec14_9" class="section-anchor"></a>

<h3>Customizing the Drag Display<span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">dispaly customization</span></span>
</h3>
<p>Usually, the browser will default the visual cursor indicator for a drag operation. An image or link will move with the cursor (sometimes sized down for practical viewing), or a ghosted image of the dragged element will hover at the drag position.</p>

<p>However, if you need to change the default drag image display, the API provides you with a simple API for doing just that. It is only possible to change the drag image during the dragstart handler—once again due to security concerns—but you can do so easily by simply passing the element that represents the appearance of the cursor to the dataTransfer.</p>

<pre><code>var dragImage = document.getElementById("happyTrails");
evt.dataTransfer.setDragImage(dragImage, 5, 10);</code></pre>

<p>Note the offset coordinates passed to the setDragImage call. These x and y coordinates tell the browser which pixel inside the image to use as the point underneath the mouse cursor. For example, by passing in the values 5 and 10 for x and y, respectively, the image will be positioned such that the cursor is 5 pixels from the left and 10 pixels from the top, as shown in Figure <span class="internal-reference" id="ir_fig6_9">9-6</span>.

</p>
<figure id="fig6_9" class="image"><img src="images/ch9/fig9-6.png"><figcaption>Figure 9-6. Demo page with a drag image set to the Happy Trails logo</figcaption></figure>

<p>The drag image does not need to be an image, <span class="index-term"><span class="primary">HTML5 drag-and-drop</span><span class="secondary">dispaly customization</span></span>however. Any element can be set as the drag image; if it is not an image, the browser will create a visual snapshot of it to serve as the cursor display.</p>

</section>
</section>

<section id="sec15_9">
<a id="hdr_sec15_9" class="section-anchor"></a>

<h2>Summary</h2>
<p>The drag-and-drop API can be a tricky one to master. It involves the correct handling of many events, some of which may be hard to manage if your drop target layout is complex. However, if you are looking for drag operations that cross windows or browsers, or even interact with the desktop, you will need to learn the subtleties of the API. By design, it combines the power of native application drag-and-drop while still working inside the security restrictions of an environment where data must be protected from third-party code.</p>

<p>For more information on using dropped files as application data, make sure to check out the W3C File API. In the next chapter, we will examine the Web Workers API, which will allow you to spawn background scripts outside of your main page to speed up execution and improve the user experience.</p>

</section>

</div>
</article>

<!--====================== END CONTENT ======================-->

<a id="main-navigation"></a>
<div class="nav-container">
<nav id="menu" role="navigation">
  <ul>
    <li class="current">
      <a href="#chapter_title">Chapter 9</a>
      <ul>
        <li><a href="#hdr_sec2_9">Web Drag-and-Drop: The Story So Far</a></li>
        <li>
          <a href="#hdr_sec3_9">Overview of HTML5 Drag-and-Drop</a>
          <ul>
            <li><a href="#hdr_sec4_9">The Big Picture</a></li>
            <li><a href="#hdr_sec5_9">Events to Remember</a></li>
            <li><a href="#hdr_sec6_9">Propagation and Prevention</a></li>
            <li><a href="#hdr_sec7_9">Drag-and-Drop Event Flow</a></li>
            <li><a href="#hdr_sec8_9">Drag Participation</a></li>
            <li><a href="#hdr_sec9_9">Transfer and Control</a></li>
          </ul>
        </li>
        <li>
          <a href="#hdr_sec10_9">Building an Application with Drag-and-Drop</a>
          <ul>
            <li><a href="#hdr_sec11_9">Getting Into the dropzone</a></li>
          </ul>
        </li>
        <li><a href="#hdr_sec12_9">Handling Drag-and-Drop for Files</a></li>
        <li>
          <a href="#hdr_sec13_9">Practical Extras</a>
          <ul>
            <li><a href="#hdr_sec14_9">Customizing the Drag Display</a></li>
          </ul>
        </li>
        <li><a href="#hdr_sec15_9">Summary</a></li>
      </ul>
    </li>
  </ul>
</nav>
</div>

  </body>

</html>
